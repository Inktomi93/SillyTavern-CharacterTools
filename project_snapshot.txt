# PROJECT SNAPSHOT
Generated: Fri Dec 26 09:18:23 AM MST 2025

## DIRECTORY STRUCTURE
```
.
├── CONTRIBUTING.md
├── eslint.config.mjs
├── globals.d.ts
├── LICENSE
├── manifest.json
├── package.json
├── package-lock.json
├── project_snapshot.txt
├── README.md
├── snapshot.sh
├── src
│   ├── character.ts
│   ├── constants.ts
│   ├── debug.ts
│   ├── generator.ts
│   ├── index.ts
│   ├── persistence.ts
│   ├── pipeline.ts
│   ├── presets.ts
│   ├── schema.ts
│   ├── settings.ts
│   ├── types.ts
│   └── ui
│       ├── components
│       │   ├── character-select.ts
│       │   ├── iteration-history.ts
│       │   ├── pipeline-nav.ts
│       │   ├── results-panel.ts
│       │   └── stage-config.ts
│       ├── formatter.ts
│       ├── panel.ts
│       ├── popup.ts
│       └── settings-modal.ts
├── style.css
├── templates
│   └── panel.html
├── tsconfig.json
└── webpack.config.js
```

## FILE: src/index.ts
```ts
// src/index.ts
//
// Extension entry point

import { getSettings } from './settings';
import { initPanel } from './ui/panel';
import { debugLog, logError } from './debug';

function init(): void {
    try {
        debugLog('info', 'Extension initializing', { version: '1.0.0' });

        initPanel();
        registerEventListeners();

        debugLog('info', 'Extension loaded', getSettings());
    } catch (error) {
        logError('Extension initialization failed', error);
        toastr.error('Character Tools failed to initialize. Check console for details.');
    }
}

function registerEventListeners(): void {
    const { eventSource, eventTypes } = SillyTavern.getContext();

    // Log API changes for debugging
    eventSource.on(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, () => {
        debugLog('info', 'Chat completion source changed', null);
    });

    eventSource.on(eventTypes.CHATCOMPLETION_MODEL_CHANGED, () => {
        debugLog('info', 'Chat completion model changed', null);
    });

    debugLog('info', 'Event listeners registered', null);
}

// Wait for app ready
const { eventSource, eventTypes } = SillyTavern.getContext();
eventSource.on(eventTypes.APP_READY, init);
```

## FILE: src/types.ts
```ts
// src/types.ts

// ============================================================================
// CORE TYPES
// ============================================================================

export type StageName = 'score' | 'rewrite' | 'analyze';

export type StageStatus = 'pending' | 'running' | 'complete' | 'skipped';

// ============================================================================
// CHARACTER
// ============================================================================

export interface Character {
    name: string;
    avatar: string;
    description: string;
    personality: string;
    first_mes: string;
    mes_example: string;
    scenario: string;
    system_prompt?: string;
    post_history_instructions?: string;
    creator_notes?: string;
    tags?: string[];
}

export interface CharacterField {
    key: keyof Character;
    label: string;
    scoreable: boolean;
}

export interface PopulatedField {
    key: string;
    label: string;
    value: string;
    charCount: number;
    scoreable: boolean;
}

// ============================================================================
// GENERATION
// ============================================================================

export interface GenerationConfig {
    source: string;
    model: string;
    temperature: number;
    maxTokens: number;
    frequencyPenalty: number;
    presencePenalty: number;
    topP: number;
}

export type GenerationResult =
    | { success: true; response: string; isStructured: boolean }
    | { success: false; error: string };

// ============================================================================
// SCHEMA
// ============================================================================

export interface StructuredOutputSchema {
    name: string;
    strict?: boolean;
    value: JsonSchemaValue;
}

export interface JsonSchemaValue {
    $schema?: string;
    type: string;
    properties?: Record<string, unknown>;
    required?: string[];
    additionalProperties?: boolean;
    items?: unknown;
    $defs?: Record<string, JsonSchemaValue>;
    definitions?: Record<string, JsonSchemaValue>;
    anyOf?: unknown[];
    allOf?: unknown[];
    enum?: unknown[];
    const?: unknown;
    format?: string;
    pattern?: string;
    description?: string;
    title?: string;
    default?: unknown;
    $ref?: string;
    minItems?: number;
    [key: string]: unknown;
}

export interface SchemaValidationResult {
    valid: boolean;
    error?: string;
    warnings?: string[];
    info?: string[];
    schema?: StructuredOutputSchema;
}

// ============================================================================
// PRESETS
// ============================================================================

export interface PromptPreset {
    id: string;
    name: string;
    prompt: string;
    stages: StageName[];  // Empty array = available for all stages
    isBuiltin: boolean;
    createdAt: number;
    updatedAt: number;
}

export interface SchemaPreset {
    id: string;
    name: string;
    schema: StructuredOutputSchema;
    stages: StageName[];  // Empty array = available for all stages
    isBuiltin: boolean;
    createdAt: number;
    updatedAt: number;
}

// ============================================================================
// STAGE CONFIGURATION
// ============================================================================

export interface StageDefaults {
    promptPresetId: string | null;  // null = use customPrompt
    customPrompt: string;
    schemaPresetId: string | null;  // null = use customSchema or none
    customSchema: string;           // JSON string, empty = no schema
    useStructuredOutput: boolean;
}

export interface StageConfig {
    promptPresetId: string | null;
    customPrompt: string;
    schemaPresetId: string | null;
    customSchema: string;
    useStructuredOutput: boolean;
}

// ============================================================================
// ITERATION SYSTEM
// ============================================================================

export type IterationVerdict = 'accept' | 'needs_refinement' | 'regression';

export interface IterationSnapshot {
    iteration: number;
    rewriteResponse: string;
    rewritePreview: string;  // First 200 chars for UI display
    analysisResponse: string;
    analysisPreview: string;
    verdict: IterationVerdict;
    timestamp: number;
}

// ============================================================================
// PARSED REWRITE
// ============================================================================

export interface ParsedRewriteField {
    key: string;
    label: string;
    value: string;
}

export interface ParsedRewrite {
    fields: ParsedRewriteField[];
    raw: string;
    parseMethod: 'json' | 'markdown' | 'heuristic' | 'raw';
}

// ============================================================================
// PIPELINE
// ============================================================================

export interface StageResult {
    response: string;
    isStructured: boolean;
    promptUsed: string;
    schemaUsed: StructuredOutputSchema | null;
    timestamp: number;
    locked: boolean;
}

export interface PipelineState {
    // Selected character
    character: Character | null;
    characterIndex: number | null;

    // Stage results
    results: {
        score: StageResult | null;
        rewrite: StageResult | null;
        analyze: StageResult | null;
    };

    // Stage configs (runtime, may differ from defaults)
    configs: {
        score: StageConfig;
        rewrite: StageConfig;
        analyze: StageConfig;
    };

    // Pipeline flow
    selectedStages: StageName[];
    currentStage: StageName | null;
    stageStatus: Record<StageName, StageStatus>;

    // Iteration system
    iterationCount: number;
    iterationHistory: IterationSnapshot[];
    isRefining: boolean;  // True when in refinement mode (after first analyze)

    // Export
    exportData: string | null;
}

// ============================================================================
// SETTINGS
// ============================================================================

export interface Settings {
    // Generation settings
    useCurrentSettings: boolean;
    generationConfig: GenerationConfig;
    systemPrompt: string;

    // Presets
    promptPresets: PromptPreset[];
    schemaPresets: SchemaPreset[];

    // Per-stage defaults
    stageDefaults: Record<StageName, StageDefaults>;

    // Refinement settings
    refinementPrompt: string;

    // Debug
    debugMode: boolean;

    // Version for migrations
    settingsVersion: number;
}

// ============================================================================
// DEBUG
// ============================================================================

export type DebugLogType = 'request' | 'response' | 'error' | 'info' | 'state';

export interface DebugLogEntry {
    timestamp: Date;
    type: DebugLogType;
    label: string;
    data: unknown;
}

// ============================================================================
// UI STATE
// ============================================================================

export interface PopupState {
    isOpen: boolean;
    isGenerating: boolean;
    abortController: AbortController | null;
    activePanel: 'main' | 'settings';
    expandedFields: Set<string>;  // Character field keys that are expanded
    historyLoaded: boolean;  // Track if we've loaded persisted iteration history
}

// ============================================================================
// COMPONENT PROPS (for future component isolation)
// ============================================================================

export interface CharacterSelectProps {
    characters: Character[];
    selectedIndex: number | null;
    onSelect: (char: Character, index: number) => void;
    onClear: () => void;
}

export interface PipelineNavProps {
    selectedStages: StageName[];
    stageStatus: Record<StageName, StageStatus>;
    currentStage: StageName | null;
    onToggleStage: (stage: StageName) => void;
    onSelectStage: (stage: StageName) => void;
    onRunSelected: () => void;
    onRunAll: () => void;
    onReset: () => void;
    hasCharacter: boolean;
}

export interface StageConfigProps {
    stage: StageName;
    config: StageConfig;
    promptPresets: PromptPreset[];
    schemaPresets: SchemaPreset[];
    onConfigChange: (config: Partial<StageConfig>) => void;
    onSavePromptPreset: (name: string) => void;
    onSaveSchemaPreset: (name: string) => void;
    tokenEstimate: number | null;
    contextSize: number;
}

export interface ResultsPanelProps {
    stage: StageName;
    result: StageResult | null;
    status: StageStatus;
    onRegenerate: () => void;
    onLock: () => void;
    onUnlock: () => void;
    onContinue: () => void;
    onCopy: () => void;
    nextStage: StageName | null;
    canContinue: boolean;
}
```

## FILE: src/constants.ts
```ts
// src/constants.ts
import type {
    CharacterField,
    StructuredOutputSchema,
    PromptPreset,
    SchemaPreset,
    StageDefaults,
    StageName,
    GenerationConfig,
    Settings,
} from './types';

// ============================================================================
// MODULE INFO
// ============================================================================

export const MODULE_NAME = 'character_tools';
export const EXTENSION_PATH = 'third-party/my-extension';
export const SETTINGS_VERSION = 3;

// ============================================================================
// CHARACTER FIELDS
// ============================================================================

export const CHARACTER_FIELDS: readonly CharacterField[] = Object.freeze([
    { key: 'description', label: 'Description', scoreable: true },
    { key: 'personality', label: 'Personality', scoreable: true },
    { key: 'first_mes', label: 'First Message', scoreable: true },
    { key: 'scenario', label: 'Scenario', scoreable: true },
    { key: 'mes_example', label: 'Example Messages', scoreable: true },
    { key: 'system_prompt', label: 'System Prompt', scoreable: true },
    { key: 'post_history_instructions', label: 'Post-History Instructions', scoreable: false },
    { key: 'creator_notes', label: 'Creator Notes', scoreable: false },
]);

// ============================================================================
// STAGE DEFINITIONS
// ============================================================================

export const STAGES: readonly StageName[] = Object.freeze(['score', 'rewrite', 'analyze']);

export const STAGE_LABELS: Record<StageName, string> = {
    score: 'Score',
    rewrite: 'Rewrite',
    analyze: 'Analyze',
};

export const STAGE_ICONS: Record<StageName, string> = {
    score: 'fa-star-half-stroke',
    rewrite: 'fa-pen-fancy',
    analyze: 'fa-magnifying-glass-chart',
};

export const STAGE_DESCRIPTIONS: Record<StageName, string> = {
    score: 'Rate and critique the character card',
    rewrite: 'Generate an improved version',
    analyze: 'Compare original vs rewrite, check for soul loss',
};

// ============================================================================
// DEFAULT SYSTEM PROMPT
// ============================================================================

export const DEFAULT_SYSTEM_PROMPT = `You are a creative writing assistant specializing in character development for roleplay and fiction. Analyze character cards and provide thoughtful, actionable feedback.

Adapt your response style to the task:
- For scoring: Be critical but fair, rate 1-10 with specific justifications
- For rewrites: Preserve the character's core identity while improving weak areas
- For analysis: Compare versions objectively, identify what was lost or gained
- For refinement: Address specific issues from analysis while keeping improvements

Focus on: writing quality, character depth, consistency, roleplay usability, and potential issues (contradictions, clichés, underdeveloped areas).

Always maintain the character's essential personality and unique traits. Improvements should enhance, not replace, what makes the character interesting.`;

// ============================================================================
// DEFAULT REFINEMENT PROMPT
// ============================================================================

export const DEFAULT_REFINEMENT_PROMPT = `You are refining a character card rewrite based on analysis feedback.

## Original Character (Ground Truth)
{{original_character}}

## Current Rewrite (Iteration {{iteration_number}})
{{current_rewrite}}

## Analysis of Current Rewrite
{{current_analysis}}

{{#if score_results}}
## Original Score Feedback (Reference)
{{score_results}}
{{/if}}

---

## Your Task

Create an improved version that:

1. **Addresses Issues**: Fix the specific problems identified in the analysis
2. **Preserves Wins**: Keep what the analysis said was working well
3. **Maintains Soul**: The character must still feel like the original, just better
4. **Avoids Regression**: Don't reintroduce problems that were already fixed

Output the complete refined character card with all fields. Mark significantly changed sections with [REFINED] at the start.

Do NOT explain your changes - just output the improved character card.`;

// ============================================================================
// BUILTIN PROMPT PRESETS
// ============================================================================

export const BUILTIN_PROMPT_PRESETS: readonly PromptPreset[] = Object.freeze([
    {
        id: 'builtin_score_default',
        name: 'Default Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Rate this character card on a scale of 1-10 for each populated field. For each field, provide:

1. **Score** (1-10)
2. **Strengths** - What works well
3. **Weaknesses** - What needs improvement
4. **Specific Suggestions** - Concrete changes to improve it

After scoring all fields, provide:
- **Overall Score** (weighted average, with First Message and Description weighted higher)
- **Top 3 Priority Improvements** - The changes that would have the biggest impact
- **Summary** - A brief overall assessment

Be critical but constructive. Vague praise is useless. Specific, actionable feedback is gold.`,
    },
    {
        id: 'builtin_score_quick',
        name: 'Quick Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Give a quick assessment of this character card:

1. Overall score (1-10)
2. Three biggest strengths
3. Three areas needing work
4. One-sentence summary

Keep it concise but useful.`,
    },
    {
        id: 'builtin_rewrite_default',
        name: 'Default Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Based on the scoring feedback, rewrite this character card to address the identified weaknesses while preserving its strengths.

Guidelines:
- Maintain the character's core personality and unique traits
- Improve weak areas identified in the score
- Keep the same general length unless brevity/expansion was specifically noted
- Preserve any distinctive voice or style that works
- Fix contradictions and fill gaps
- Make the character more engaging for roleplay

Output the complete rewritten character card with all fields, using the same field structure as the original. Mark significantly changed sections with [REVISED] at the start.

{{score_results}}`,
    },
    {
        id: 'builtin_rewrite_conservative',
        name: 'Conservative Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Make minimal, surgical improvements to this character card. Only change what's clearly broken or weak.

Rules:
- Change as little as possible
- Preserve the author's voice completely
- Only fix obvious issues (contradictions, grammar, clarity)
- Do NOT add new content unless filling a critical gap
- Do NOT change style or tone

Output only the fields you changed, with [ORIGINAL] and [REVISED] versions for comparison.

{{score_results}}`,
    },
    {
        id: 'builtin_rewrite_expansive',
        name: 'Expansive Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Significantly expand and enhance this character card. Add depth, detail, and richness.

Goals:
- Flesh out underdeveloped areas
- Add sensory details and specific examples
- Deepen personality with quirks, contradictions, history
- Improve example messages with more variety
- Make the character feel more three-dimensional

Don't change the core concept, but make it shine. Output the complete expanded character card.

{{score_results}}`,
    },
    {
        id: 'builtin_analyze_default',
        name: 'Default Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Compare the original character card with the rewritten version. Analyze:

## What Was Preserved
- Core personality traits that remained intact
- Distinctive elements that were kept
- Voice and style consistency

## What Was Lost
- Any personality aspects that were diminished or removed
- Unique quirks that disappeared
- Tone shifts that changed the character's feel

## What Was Gained
- New depth or detail added
- Improvements that enhance the character
- Better clarity or consistency

## Soul Check
Does the rewritten version still feel like the same character? Rate the "soul preservation" from 1-10 and explain.

## Verdict
State clearly: **ACCEPT** (ready to use), **NEEDS REFINEMENT** (good progress but has issues), or **REGRESSION** (worse than before).

## Specific Issues to Address
If verdict is NEEDS REFINEMENT, list the specific problems that should be fixed in the next iteration.

---

### Original Character:
{{original_character}}

### Rewritten Version:
{{rewrite_results}}

### Score Feedback:
{{score_results}}`,
    },
    {
        id: 'builtin_analyze_iteration',
        name: 'Iteration Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `This is iteration {{iteration_number}} of refinement. Compare the current rewrite against the original.

## Progress Check
- What issues from previous analysis were addressed?
- What new issues (if any) were introduced?
- Is this version better, worse, or lateral move from the last?

## Current State Assessment

### Preserved from Original
Core traits and elements that remain intact.

### Still Missing or Lost
Things from the original that should be restored.

### Successfully Improved
What's genuinely better now.

### New Problems
Any issues introduced by this iteration.

## Soul Preservation Score
Rate 1-10: Does this still feel like the original character?

## Verdict
**ACCEPT** - Ready to use, no more iterations needed
**NEEDS REFINEMENT** - Making progress, but specific issues remain
**REGRESSION** - This iteration made things worse, consider reverting

## Next Steps
If NEEDS REFINEMENT: List exactly what the next iteration should fix.
If REGRESSION: Explain what went wrong and what to preserve from previous version.

---

### Original Character:
{{original_character}}

### Current Rewrite (Iteration {{iteration_number}}):
{{rewrite_results}}`,
    },
    {
        id: 'builtin_analyze_quick',
        name: 'Quick Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Quick comparison of original vs rewrite:

1. Soul preserved? (Yes/Partially/No)
2. Best improvement made
3. Biggest thing lost (if any)
4. Verdict: ACCEPT / NEEDS REFINEMENT / REGRESSION

{{original_character}}

{{rewrite_results}}`,
    },
    {
        id: 'builtin_freeform',
        name: 'Freeform',
        stages: [],  // Available for all stages
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: '[Enter your custom instructions here]',
    },
]);

// ============================================================================
// BUILTIN SCHEMA PRESETS
// ============================================================================

const SCORE_SCHEMA: StructuredOutputSchema = {
    name: 'CharacterScore',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            fieldScores: {
                type: 'array',
                items: {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        field: { type: 'string' },
                        score: { type: 'number' },
                        strengths: { type: 'string' },
                        weaknesses: { type: 'string' },
                        suggestions: { type: 'string' },
                    },
                    required: ['field', 'score', 'strengths', 'weaknesses', 'suggestions'],
                },
            },
            overallScore: { type: 'number' },
            priorityImprovements: {
                type: 'array',
                items: { type: 'string' },
            },
            summary: { type: 'string' },
        },
        required: ['fieldScores', 'overallScore', 'priorityImprovements', 'summary'],
    },
};

const QUICK_SCORE_SCHEMA: StructuredOutputSchema = {
    name: 'QuickScore',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            overallScore: { type: 'number' },
            strengths: {
                type: 'array',
                items: { type: 'string' },
            },
            weaknesses: {
                type: 'array',
                items: { type: 'string' },
            },
            summary: { type: 'string' },
        },
        required: ['overallScore', 'strengths', 'weaknesses', 'summary'],
    },
};

const ANALYZE_SCHEMA: StructuredOutputSchema = {
    name: 'CharacterAnalysis',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            preserved: {
                type: 'array',
                items: { type: 'string' },
            },
            lost: {
                type: 'array',
                items: { type: 'string' },
            },
            gained: {
                type: 'array',
                items: { type: 'string' },
            },
            soulPreservationScore: { type: 'number' },
            soulAssessment: { type: 'string' },
            verdict: {
                type: 'string',
                enum: ['ACCEPT', 'NEEDS_REFINEMENT', 'REGRESSION'],
            },
            issuesToAddress: {
                type: 'array',
                items: { type: 'string' },
            },
            recommendations: {
                type: 'array',
                items: { type: 'string' },
            },
        },
        required: ['preserved', 'lost', 'gained', 'soulPreservationScore', 'soulAssessment', 'verdict', 'issuesToAddress', 'recommendations'],
    },
};

export const BUILTIN_SCHEMA_PRESETS: readonly SchemaPreset[] = Object.freeze([
    {
        id: 'builtin_schema_score',
        name: 'Default Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: SCORE_SCHEMA,
    },
    {
        id: 'builtin_schema_quick_score',
        name: 'Quick Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: QUICK_SCORE_SCHEMA,
    },
    {
        id: 'builtin_schema_analyze',
        name: 'Default Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: ANALYZE_SCHEMA,
    },
]);

// ============================================================================
// DEFAULT STAGE CONFIGS
// ============================================================================

export const DEFAULT_STAGE_DEFAULTS: Record<StageName, StageDefaults> = {
    score: {
        promptPresetId: 'builtin_score_default',
        customPrompt: '',
        schemaPresetId: 'builtin_schema_score',
        customSchema: '',
        useStructuredOutput: false,  // Off by default, user can enable
    },
    rewrite: {
        promptPresetId: 'builtin_rewrite_default',
        customPrompt: '',
        schemaPresetId: null,  // Rewrite typically doesn't use structured output
        customSchema: '',
        useStructuredOutput: false,
    },
    analyze: {
        promptPresetId: 'builtin_analyze_default',
        customPrompt: '',
        schemaPresetId: 'builtin_schema_analyze',
        customSchema: '',
        useStructuredOutput: false,
    },
};

// ============================================================================
// DEFAULT GENERATION CONFIG
// ============================================================================

export const DEFAULT_GENERATION_CONFIG: GenerationConfig = {
    source: 'openrouter',
    model: 'anthropic/claude-sonnet-4',
    temperature: 1,
    maxTokens: 4096,
    frequencyPenalty: 0,
    presencePenalty: 0,
    topP: 1,
};

// ============================================================================
// COMPLETE DEFAULT SETTINGS
// ============================================================================

export const DEFAULT_SETTINGS: Settings = Object.freeze({
    useCurrentSettings: true,
    generationConfig: DEFAULT_GENERATION_CONFIG,
    systemPrompt: DEFAULT_SYSTEM_PROMPT,
    promptPresets: [...BUILTIN_PROMPT_PRESETS],
    schemaPresets: [...BUILTIN_SCHEMA_PRESETS],
    stageDefaults: DEFAULT_STAGE_DEFAULTS,
    refinementPrompt: DEFAULT_REFINEMENT_PROMPT,
    debugMode: false,
    settingsVersion: SETTINGS_VERSION,
});

// ============================================================================
// TEMPLATE PLACEHOLDERS
// ============================================================================

/**
 * Template placeholders that can be used in prompts.
 * These are replaced at runtime with actual values.
 *
 * @property ORIGINAL_CHARACTER - The full character card being analyzed/rewritten.
 *           Includes all populated fields formatted as markdown sections.
 *
 * @property SCORE_RESULTS - Output from the Score stage. Available in Rewrite and Analyze stages.
 *           Empty string if Score stage wasn't run.
 *
 * @property REWRITE_RESULTS - Output from the Rewrite stage. Available in Analyze stage.
 *           Empty string if Rewrite stage wasn't run.
 *
 * @property CURRENT_REWRITE - Alias for REWRITE_RESULTS, used in refinement context.
 *
 * @property CURRENT_ANALYSIS - Output from the Analyze stage. Used in refinement prompts.
 *           Empty string if Analyze stage wasn't run.
 *
 * @property ITERATION_NUMBER - Current refinement iteration number (1-based).
 *           "1" for first iteration, increments with each refinement cycle.
 *
 * @property CHARACTER_NAME - The character's name (e.g., "Luna").
 *
 * @property USER_NAME - The user's configured name in SillyTavern.
 */
export const TEMPLATE_PLACEHOLDERS = {
    ORIGINAL_CHARACTER: '{{original_character}}',
    SCORE_RESULTS: '{{score_results}}',
    REWRITE_RESULTS: '{{rewrite_results}}',
    CURRENT_REWRITE: '{{current_rewrite}}',
    CURRENT_ANALYSIS: '{{current_analysis}}',
    ITERATION_NUMBER: '{{iteration_number}}',
    CHARACTER_NAME: '{{char_name}}',
    USER_NAME: '{{user_name}}',
} as const;

// ============================================================================
// UI CONSTANTS
// ============================================================================

export const TOKEN_WARNING_THRESHOLD = 0.5;   // 50% of context
export const TOKEN_DANGER_THRESHOLD = 0.8;    // 80% of context

export const DEBOUNCE_DELAY = {
    SEARCH: 150,
    TOKEN_ESTIMATE: 300,
    SAVE: 500,
    VALIDATE: 500,
} as const;

export const MAX_DROPDOWN_RESULTS = 10;
export const MAX_DEBUG_LOG_ENTRIES = 100;
export const MAX_ITERATION_HISTORY = 20;  // Don't keep more than this many snapshots

// ============================================================================
// CSS CLASS PREFIX
// ============================================================================

// All CSS classes should use this prefix
export const CSS_PREFIX = 'character_tools';

// Helper to generate prefixed class names
export function css(...names: string[]): string {
    return names.map(n => `${CSS_PREFIX}_${n}`).join(' ');
}

// Helper for BEM-style classes
export function bem(block: string, element?: string, modifier?: string): string {
    let className = `${CSS_PREFIX}_${block}`;
    if (element) className += `__${element}`;
    if (modifier) className += `--${modifier}`;
    return className;
}
```

## FILE: src/settings.ts
```ts
// src/settings.ts
import {
    MODULE_NAME,
    DEFAULT_SETTINGS,
    DEFAULT_SYSTEM_PROMPT,
    DEFAULT_GENERATION_CONFIG,
    DEFAULT_STAGE_DEFAULTS,
    DEFAULT_REFINEMENT_PROMPT,
    BUILTIN_PROMPT_PRESETS,
    BUILTIN_SCHEMA_PRESETS,
    SETTINGS_VERSION,
} from './constants';
import type {
    Settings,
    GenerationConfig,
    StageName,
    StageDefaults,
    PromptPreset,
    SchemaPreset,
    StructuredOutputSchema,
    JsonSchemaValue,
} from './types';
import { debugLog } from './debug';

// ============================================================================
// MIGRATION REGISTRY
// ============================================================================

type MigrationFn = (settings: Partial<Settings>) => void;

const migrations: Record<number, MigrationFn> = {
    // v1 -> v2: Add preset system, stage defaults
    2: (settings) => {
        // Handle old useRawMode -> useCurrentSettings
        const oldSettings = settings as Record<string, unknown>;
        if (oldSettings.useRawMode !== undefined) {
            settings.useCurrentSettings = !oldSettings.useRawMode;
            delete oldSettings.useRawMode;
        }

        // Handle old jsonSchema -> discard (can't migrate custom schemas reliably)
        if (oldSettings.jsonSchema !== undefined) {
            delete oldSettings.jsonSchema;
        }

        // Handle old useStructuredOutput -> apply to score stage
        if (oldSettings.useStructuredOutput !== undefined) {
            if (!settings.stageDefaults) {
                settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
            }
            settings.stageDefaults!.score.useStructuredOutput = !!oldSettings.useStructuredOutput;
            delete oldSettings.useStructuredOutput;
        }
    },

    // v2 -> v3: Add refinement prompt
    3: (settings) => {
        if (!settings.refinementPrompt) {
            settings.refinementPrompt = DEFAULT_REFINEMENT_PROMPT;
        }
    },
};

/**
 * Run all migrations from oldVersion to current version
 */
function runMigrations(settings: Partial<Settings>, oldVersion: number): boolean {
    let migrated = false;

    for (let v = oldVersion + 1; v <= SETTINGS_VERSION; v++) {
        const migration = migrations[v];
        if (migration) {
            debugLog('info', `Running migration to v${v}`, null);
            migration(settings);
            migrated = true;
        }
    }

    return migrated;
}

// ============================================================================
// SETTINGS ACCESS
// ============================================================================

/**
 * Get current settings, initializing with defaults if needed.
 * Handles migrations from older versions.
 */
export function getSettings(): Settings {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const { lodash } = SillyTavern.libs;

    if (!extensionSettings[MODULE_NAME]) {
        debugLog('info', 'Initializing settings with defaults', null);
        extensionSettings[MODULE_NAME] = structuredClone(DEFAULT_SETTINGS);
        saveSettingsDebounced();
        return extensionSettings[MODULE_NAME] as Settings;
    }

    const existing = extensionSettings[MODULE_NAME] as Partial<Settings>;
    const oldVersion = existing.settingsVersion || 1;
    let needsSave = false;

    // Run migrations if version is old
    if (oldVersion < SETTINGS_VERSION) {
        needsSave = runMigrations(existing, oldVersion);
        existing.settingsVersion = SETTINGS_VERSION;
    }

    // Merge with defaults to ensure all fields exist
    // lodash.merge does deep merge, existing values override defaults
    const merged = lodash.merge(
        structuredClone(DEFAULT_SETTINGS),
        existing,
    ) as Settings;

    // Ensure builtin presets exist (they might be missing if user has old settings)
    const builtinsAdded = ensureBuiltinPresets(merged);
    needsSave = needsSave || builtinsAdded;

    // Write back merged settings
    extensionSettings[MODULE_NAME] = merged;

    if (needsSave) {
        saveSettingsDebounced();
    }

    return merged;
}

/**
 * Ensure all builtin presets exist in settings
 */
function ensureBuiltinPresets(settings: Settings): boolean {
    let modified = false;

    // Ensure prompt presets
    const existingPromptIds = new Set(settings.promptPresets.map(p => p.id));
    for (const builtin of BUILTIN_PROMPT_PRESETS) {
        if (!existingPromptIds.has(builtin.id)) {
            settings.promptPresets.push(structuredClone(builtin));
            modified = true;
        }
    }

    // Ensure schema presets
    const existingSchemaIds = new Set(settings.schemaPresets.map(p => p.id));
    for (const builtin of BUILTIN_SCHEMA_PRESETS) {
        if (!existingSchemaIds.has(builtin.id)) {
            settings.schemaPresets.push(structuredClone(builtin));
            modified = true;
        }
    }

    return modified;
}

// ============================================================================
// SETTINGS UPDATES
// ============================================================================

/**
 * Update a single setting value
 */
export function updateSetting<K extends keyof Settings>(key: K, value: Settings[K]): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    settings[key] = value;
    saveSettingsDebounced();
    debugLog('info', 'Setting updated', { key, value: typeof value === 'object' ? '[object]' : value });
}

/**
 * Update generation config (partial update)
 */
export function updateGenerationConfig(updates: Partial<GenerationConfig>): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.generationConfig) {
        settings.generationConfig = structuredClone(DEFAULT_GENERATION_CONFIG);
    }

    settings.generationConfig = { ...settings.generationConfig, ...updates };
    saveSettingsDebounced();
    debugLog('info', 'Generation config updated', updates);
}

/**
 * Update system prompt
 */
export function updateSystemPrompt(prompt: string): void {
    updateSetting('systemPrompt', prompt);
}

/**
 * Reset system prompt to default
 */
export function resetSystemPrompt(): void {
    updateSetting('systemPrompt', DEFAULT_SYSTEM_PROMPT);
}

/**
 * Update refinement prompt
 */
export function updateRefinementPrompt(prompt: string): void {
    updateSetting('refinementPrompt', prompt);
}

/**
 * Reset refinement prompt to default
 */
export function resetRefinementPrompt(): void {
    updateSetting('refinementPrompt', DEFAULT_REFINEMENT_PROMPT);
}

/**
 * Update stage defaults
 */
export function updateStageDefaults(stage: StageName, updates: Partial<StageDefaults>): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.stageDefaults) {
        settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
    }

    if (!settings.stageDefaults[stage]) {
        settings.stageDefaults[stage] = structuredClone(DEFAULT_STAGE_DEFAULTS[stage]);
    }

    settings.stageDefaults[stage] = { ...settings.stageDefaults[stage], ...updates };
    saveSettingsDebounced();
    debugLog('info', 'Stage defaults updated', { stage, updates });
}

/**
 * Reset stage defaults to builtin values
 */
export function resetStageDefaults(stage: StageName): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.stageDefaults) {
        settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
    }

    settings.stageDefaults[stage] = structuredClone(DEFAULT_STAGE_DEFAULTS[stage]);
    saveSettingsDebounced();
    debugLog('info', 'Stage defaults reset', { stage });
}

/**
 * Set debug mode
 */
export function setDebugMode(enabled: boolean): void {
    updateSetting('debugMode', enabled);
}

// ============================================================================
// PRESET MANAGEMENT
// ============================================================================

/**
 * Get all prompt presets, optionally filtered by stage
 */
export function getPromptPresets(stage?: StageName): PromptPreset[] {
    const settings = getSettings();

    if (!stage) {
        return settings.promptPresets;
    }

    return settings.promptPresets.filter(p =>
        p.stages.length === 0 || p.stages.includes(stage),
    );
}

/**
 * Get a specific prompt preset by ID
 */
export function getPromptPreset(id: string): PromptPreset | null {
    const settings = getSettings();
    return settings.promptPresets.find(p => p.id === id) || null;
}

/**
 * Save a new prompt preset
 */
export function savePromptPreset(preset: Omit<PromptPreset, 'id' | 'isBuiltin' | 'createdAt' | 'updatedAt'>): PromptPreset {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    const { uuidv4 } = SillyTavern.getContext();

    const now = Date.now();
    const newPreset: PromptPreset = {
        ...preset,
        id: `custom_prompt_${uuidv4()}`,
        isBuiltin: false,
        createdAt: now,
        updatedAt: now,
    };

    settings.promptPresets.push(newPreset);
    saveSettingsDebounced();
    debugLog('info', 'Prompt preset saved', { id: newPreset.id, name: newPreset.name });

    return newPreset;
}

/**
 * Update an existing prompt preset (only custom presets)
 */
export function updatePromptPreset(id: string, updates: Partial<Omit<PromptPreset, 'id' | 'isBuiltin' | 'createdAt'>>): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.promptPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.promptPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot update builtin preset', { id });
        return false;
    }

    settings.promptPresets[index] = {
        ...preset,
        ...updates,
        updatedAt: Date.now(),
    };

    saveSettingsDebounced();
    debugLog('info', 'Prompt preset updated', { id });
    return true;
}

/**
 * Delete a prompt preset (only custom presets)
 * Returns the deleted preset ID if successful, null otherwise
 */
export function deletePromptPreset(id: string): string | null {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.promptPresets.findIndex(p => p.id === id);
    if (index === -1) return null;

    const preset = settings.promptPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot delete builtin preset', { id });
        return null;
    }

    settings.promptPresets.splice(index, 1);

    // Clear any stage defaults that reference this preset
    for (const stage of ['score', 'rewrite', 'analyze'] as const) {
        if (settings.stageDefaults[stage]?.promptPresetId === id) {
            settings.stageDefaults[stage].promptPresetId = null;
        }
    }

    saveSettingsDebounced();
    debugLog('info', 'Prompt preset deleted', { id });
    return id;
}

/**
 * Get all schema presets, optionally filtered by stage
 */
export function getSchemaPresets(stage?: StageName): SchemaPreset[] {
    const settings = getSettings();

    if (!stage) {
        return settings.schemaPresets;
    }

    return settings.schemaPresets.filter(p =>
        p.stages.length === 0 || p.stages.includes(stage),
    );
}

/**
 * Get a specific schema preset by ID
 */
export function getSchemaPreset(id: string): SchemaPreset | null {
    const settings = getSettings();
    return settings.schemaPresets.find(p => p.id === id) || null;
}

/**
 * Save a new schema preset
 */
export function saveSchemaPreset(preset: Omit<SchemaPreset, 'id' | 'isBuiltin' | 'createdAt' | 'updatedAt'>): SchemaPreset {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    const { uuidv4 } = SillyTavern.getContext();

    // Auto-fix schema before saving
    const fixedSchema = ensureSchemaHasAdditionalProperties(preset.schema);

    const now = Date.now();
    const newPreset: SchemaPreset = {
        ...preset,
        schema: fixedSchema,
        id: `custom_schema_${uuidv4()}`,
        isBuiltin: false,
        createdAt: now,
        updatedAt: now,
    };

    settings.schemaPresets.push(newPreset);
    saveSettingsDebounced();
    debugLog('info', 'Schema preset saved', { id: newPreset.id, name: newPreset.name });

    return newPreset;
}

/**
 * Update an existing schema preset (only custom presets)
 */
export function updateSchemaPreset(id: string, updates: Partial<Omit<SchemaPreset, 'id' | 'isBuiltin' | 'createdAt'>>): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.schemaPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.schemaPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot update builtin preset', { id });
        return false;
    }

    // Auto-fix schema if provided
    if (updates.schema) {
        updates.schema = ensureSchemaHasAdditionalProperties(updates.schema);
    }

    settings.schemaPresets[index] = {
        ...preset,
        ...updates,
        updatedAt: Date.now(),
    };

    saveSettingsDebounced();
    debugLog('info', 'Schema preset updated', { id });
    return true;
}

/**
 * Delete a schema preset (only custom presets)
 * Returns the deleted preset ID if successful, null otherwise
 */
export function deleteSchemaPreset(id: string): string | null {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.schemaPresets.findIndex(p => p.id === id);
    if (index === -1) return null;

    const preset = settings.schemaPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot delete builtin preset', { id });
        return null;
    }

    settings.schemaPresets.splice(index, 1);

    // Clear any stage defaults that reference this preset
    for (const stage of ['score', 'rewrite', 'analyze'] as const) {
        if (settings.stageDefaults[stage]?.schemaPresetId === id) {
            settings.stageDefaults[stage].schemaPresetId = null;
        }
    }

    saveSettingsDebounced();
    debugLog('info', 'Schema preset deleted', { id });
    return id;
}

// ============================================================================
// SCHEMA HELPERS
// ============================================================================

/**
 * Recursively add additionalProperties: false to all object types in a schema
 */
function ensureSchemaHasAdditionalProperties(schema: StructuredOutputSchema): StructuredOutputSchema {
    const fixed = structuredClone(schema);
    addAdditionalPropertiesToNode(fixed.value);
    return fixed;
}

function addAdditionalPropertiesToNode(node: JsonSchemaValue): void {
    if (node.type === 'object') {
        node.additionalProperties = false;

        if (node.properties && typeof node.properties === 'object') {
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    addAdditionalPropertiesToNode(prop as JsonSchemaValue);
                }
            }
        }
    }

    if (node.type === 'array' && node.items && typeof node.items === 'object') {
        if (!Array.isArray(node.items)) {
            addAdditionalPropertiesToNode(node.items as JsonSchemaValue);
        } else {
            node.items.forEach(item => {
                if (item && typeof item === 'object') {
                    addAdditionalPropertiesToNode(item as JsonSchemaValue);
                }
            });
        }
    }

    if (node.anyOf && Array.isArray(node.anyOf)) {
        node.anyOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                addAdditionalPropertiesToNode(variant as JsonSchemaValue);
            }
        });
    }

    if (node.allOf && Array.isArray(node.allOf)) {
        node.allOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                addAdditionalPropertiesToNode(variant as JsonSchemaValue);
            }
        });
    }

    // Handle $defs
    if (node.$defs && typeof node.$defs === 'object') {
        for (const def of Object.values(node.$defs)) {
            if (def && typeof def === 'object') {
                addAdditionalPropertiesToNode(def);
            }
        }
    }

    if (node.definitions && typeof node.definitions === 'object') {
        for (const def of Object.values(node.definitions)) {
            if (def && typeof def === 'object') {
                addAdditionalPropertiesToNode(def as JsonSchemaValue);
            }
        }
    }
}

// ============================================================================
// EXPORT HELPERS
// ============================================================================

/**
 * Export all custom presets as JSON (for backup/sharing)
 */
export function exportCustomPresets(): string {
    const settings = getSettings();

    const customPrompts = settings.promptPresets.filter(p => !p.isBuiltin);
    const customSchemas = settings.schemaPresets.filter(p => !p.isBuiltin);

    return JSON.stringify({
        version: SETTINGS_VERSION,
        exportedAt: new Date().toISOString(),
        promptPresets: customPrompts,
        schemaPresets: customSchemas,
    }, null, 2);
}

/**
 * Import presets from JSON
 */
export function importPresets(json: string): { prompts: number; schemas: number; errors: string[] } {
    const errors: string[] = [];
    let promptsImported = 0;
    let schemasImported = 0;

    try {
        const data = JSON.parse(json);

        if (data.promptPresets && Array.isArray(data.promptPresets)) {
            for (const preset of data.promptPresets) {
                try {
                    if (preset.name && preset.prompt) {
                        savePromptPreset({
                            name: preset.name,
                            prompt: preset.prompt,
                            stages: preset.stages || [],
                        });
                        promptsImported++;
                    }
                } catch (e) {
                    errors.push(`Failed to import prompt "${preset.name}": ${e}`);
                }
            }
        }

        if (data.schemaPresets && Array.isArray(data.schemaPresets)) {
            for (const preset of data.schemaPresets) {
                try {
                    if (preset.name && preset.schema) {
                        saveSchemaPreset({
                            name: preset.name,
                            schema: preset.schema,
                            stages: preset.stages || [],
                        });
                        schemasImported++;
                    }
                } catch (e) {
                    errors.push(`Failed to import schema "${preset.name}": ${e}`);
                }
            }
        }
    } catch (e) {
        errors.push(`Failed to parse JSON: ${e}`);
    }

    debugLog('info', 'Presets imported', { promptsImported, schemasImported, errors });
    return { prompts: promptsImported, schemas: schemasImported, errors };
}
```

## FILE: src/character.ts
```ts
// src/character.ts
//
// Character utilities - field extraction, formatting, etc.

import { CHARACTER_FIELDS } from './constants';
import type { Character, PopulatedField } from './types';

// ============================================================================
// FIELD EXTRACTION
// ============================================================================

/**
 * Get all populated fields from a character
 */
export function getPopulatedFields(char: Character): PopulatedField[] {
    return CHARACTER_FIELDS
        .filter(field => {
            const val = char[field.key];
            return val && typeof val === 'string' && val.trim().length > 0;
        })
        .map(field => {
            const value = (char[field.key] as string).trim();
            return {
                key: field.key,
                label: field.label,
                value,
                charCount: value.length,
                scoreable: field.scoreable,
            };
        });
}

/**
 * Get total character count across all fields
 */
export function getTotalCharCount(char: Character): number {
    return getPopulatedFields(char).reduce((sum, f) => sum + f.charCount, 0);
}

/**
 * Get count of populated fields
 */
export function getPopulatedFieldCount(char: Character): number {
    return getPopulatedFields(char).length;
}

// ============================================================================
// FORMATTING
// ============================================================================

/**
 * Build a formatted character summary for prompts
 */
export function buildCharacterSummary(char: Character): string {
    const fields = getPopulatedFields(char);
    const sections = fields.map(f => `### ${f.label}\n${f.value}`);
    return `# CHARACTER: ${char.name}\n\n${sections.join('\n\n')}`;
}

/**
 * Build a compact character summary (for display)
 */
export function buildCompactSummary(char: Character): string {
    const fields = getPopulatedFields(char);
    return `${char.name} - ${fields.length} fields, ${getTotalCharCount(char).toLocaleString()} chars`;
}

/**
 * Get a preview of a field value (truncated)
 */
export function getFieldPreview(value: string, maxLength: number = 100): string {
    if (value.length <= maxLength) {
        return value;
    }
    return value.substring(0, maxLength - 3) + '...';
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Check if a character has enough content to analyze
 */
export function hasAnalyzableContent(char: Character): boolean {
    const fields = getPopulatedFields(char);
    return fields.length > 0;
}

/**
 * Get validation issues with a character
 */
export function validateCharacter(char: Character): string[] {
    const issues: string[] = [];

    if (!char.name?.trim()) {
        issues.push('Character has no name');
    }

    const fields = getPopulatedFields(char);
    if (fields.length === 0) {
        issues.push('Character has no populated fields');
    }

    // Check for very short fields
    for (const field of fields) {
        if (field.charCount < 20 && field.scoreable) {
            issues.push(`${field.label} is very short (${field.charCount} chars)`);
        }
    }

    return issues;
}

// ============================================================================
// SEARCH
// ============================================================================

/**
 * Prepare character data for fuzzy search
 */
export function prepareForSearch(chars: Character[]): Array<{ char: Character; index: number; searchText: string }> {
    return chars
        .map((char, index) => ({
            char,
            index,
            searchText: [
                char.name,
                char.description?.substring(0, 200),
                char.personality?.substring(0, 100),
            ].filter(Boolean).join(' ').toLowerCase(),
        }))
        .filter(item => item.char?.name);
}
```

## FILE: src/generator.ts
```ts
// src/generator.ts
//
// Handles LLM generation for pipeline stages and refinement.
// Supports both ST's current settings and custom API configuration.
//
// NOTE: Abort/cancel only works between API calls, not during active streaming.
// Once a streaming request starts, it will complete or error - the abort signal
// is checked before starting and after completion, but cannot interrupt mid-stream.

import { getSettings } from './settings';
import { debugLog, logError } from './debug';
import type {
    StructuredOutputSchema,
    GenerationResult,
    PipelineState,
    StageName,
} from './types';
import { buildStagePrompt, buildRefinementPrompt, getStageSchema } from './pipeline';

// ============================================================================
// API STATUS
// ============================================================================

/**
 * Check if the API is ready for generation
 */
export function isApiReady(): boolean {
    const { onlineStatus } = SillyTavern.getContext();
    return onlineStatus === 'Valid' || onlineStatus === 'Connected';
}

/**
 * Get current API info for display
 */
export function getApiInfo(): { source: string; model: string; isReady: boolean } {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    if (settings.useCurrentSettings) {
        return {
            source: context.chatCompletionSettings?.chat_completion_source || context.mainApi || 'unknown',
            model: context.chatCompletionSettings?.openrouter_model ||
             context.chatCompletionSettings?.model_openai_select ||
             'unknown',
            isReady: isApiReady(),
        };
    }

    return {
        source: settings.generationConfig.source,
        model: settings.generationConfig.model,
        isReady: isApiReady(),
    };
}

// ============================================================================
// MAIN GENERATION FUNCTION
// ============================================================================

/**
 * Run generation for a pipeline stage.
 *
 * NOTE: The abort signal is checked before and after generation, but cannot
 * interrupt an active streaming request mid-stream.
 */
export async function runStageGeneration(
    state: PipelineState,
    stage: StageName,
    signal?: AbortSignal,
): Promise<GenerationResult> {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    // Pre-flight checks
    if (signal?.aborted) {
        return { success: false, error: 'Generation cancelled' };
    }

    if (!state.character) {
        return { success: false, error: 'No character selected' };
    }

    if (!isApiReady()) {
        logError('API not ready', { onlineStatus: context.onlineStatus });
        return { success: false, error: 'API is not connected. Check your connection settings.' };
    }

    // Build prompt
    const userPrompt = buildStagePrompt(state, stage);
    if (!userPrompt) {
        return { success: false, error: 'No prompt configured for this stage' };
    }

    // Get schema if structured output is enabled
    const config = state.configs[stage];
    const jsonSchema = config.useStructuredOutput ? getStageSchema(state, stage) : null;

    // Substitute character placeholders in the prompt
    const processedPrompt = substituteCharacterPlaceholders(
        userPrompt,
        state.character.name,
        context.name1 || 'User',
    );

    debugLog('info', 'Starting stage generation', {
        stage,
        character: state.character.name,
        useCurrentSettings: settings.useCurrentSettings,
        useStructured: !!jsonSchema,
        schemaName: jsonSchema?.name,
        promptLength: processedPrompt.length,
    });

    const result = await executeGeneration(
        settings.systemPrompt,
        processedPrompt,
        jsonSchema,
        signal,
        settings.useCurrentSettings,
    );

    // If structured output was requested, validate the response
    if (result.success && jsonSchema) {
        return validateStructuredResponse(result.response, jsonSchema);
    }

    return result;
}

/**
 * Run refinement generation.
 *
 * NOTE: The abort signal is checked before and after generation, but cannot
 * interrupt an active streaming request mid-stream.
 */
export async function runRefinementGeneration(
    state: PipelineState,
    signal?: AbortSignal,
): Promise<GenerationResult> {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    // Pre-flight checks
    if (signal?.aborted) {
        return { success: false, error: 'Generation cancelled' };
    }

    if (!state.character) {
        return { success: false, error: 'No character selected' };
    }

    if (!state.results.rewrite || !state.results.analyze) {
        return { success: false, error: 'Refinement requires both rewrite and analyze results' };
    }

    if (!isApiReady()) {
        logError('API not ready', { onlineStatus: context.onlineStatus });
        return { success: false, error: 'API is not connected. Check your connection settings.' };
    }

    // Build refinement prompt
    const userPrompt = buildRefinementPrompt(state);
    if (!userPrompt) {
        return { success: false, error: 'Failed to build refinement prompt' };
    }

    // Substitute character placeholders
    const processedPrompt = substituteCharacterPlaceholders(
        userPrompt,
        state.character.name,
        context.name1 || 'User',
    );

    debugLog('info', 'Starting refinement generation', {
        iteration: state.iterationCount + 1,
        character: state.character.name,
        promptLength: processedPrompt.length,
    });

    // Refinement doesn't use structured output - we want free-form character card
    return await executeGeneration(
        settings.systemPrompt,
        processedPrompt,
        null,
        signal,
        settings.useCurrentSettings,
    );
}

/**
 * Validate structured response and fall back gracefully if parsing fails
 */
function validateStructuredResponse(
    response: string,
    schema: StructuredOutputSchema,
): GenerationResult {
    try {
        const parsed = JSON.parse(response);

        // Basic structure validation - check required fields exist
        if (schema.value.required && Array.isArray(schema.value.required)) {
            const missing = schema.value.required.filter(
                field => !(field in parsed),
            );

            if (missing.length > 0) {
                debugLog('info', 'Structured response missing required fields, returning as unstructured', {
                    missing,
                    schemaName: schema.name,
                });
                // Return as unstructured rather than failing
                return {
                    success: true,
                    response,
                    isStructured: false,
                };
            }
        }

        // Valid structured response
        return {
            success: true,
            response,
            isStructured: true,
        };
    } catch (e) {
        debugLog('info', 'Failed to parse structured response, returning as unstructured', {
            error: (e as Error).message,
            schemaName: schema.name,
            responsePreview: response.substring(0, 200),
        });

        // Fall back to unstructured rather than failing
        return {
            success: true,
            response,
            isStructured: false,
        };
    }
}

/**
 * Core generation execution
 */
async function executeGeneration(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal: AbortSignal | undefined,
    useCurrentSettings: boolean,
): Promise<GenerationResult> {
    try {
        let response: string;

        if (useCurrentSettings) {
            response = await generateWithCurrentSettings(
                systemPrompt,
                userPrompt,
                jsonSchema,
                signal,
            );
        } else {
            response = await generateWithCustomSettings(
                systemPrompt,
                userPrompt,
                jsonSchema,
                signal,
            );
        }

        // Check abort after generation
        if (signal?.aborted) {
            return { success: false, error: 'Generation cancelled' };
        }

        if (!response || response.trim() === '') {
            logError('Empty response', null);
            return { success: false, error: 'Empty response from API' };
        }

        debugLog('info', 'Generation complete', {
            responseLength: response.length,
            isStructured: !!jsonSchema,
        });

        return {
            success: true,
            response,
            isStructured: !!jsonSchema,
        };
    } catch (err) {
        // Handle abort errors gracefully
        if ((err as Error).name === 'AbortError' || signal?.aborted) {
            debugLog('info', 'Generation aborted', null);
            return { success: false, error: 'Generation cancelled' };
        }

        logError('Generation exception', {
            message: err instanceof Error ? err.message : String(err),
        });

        const errorMessage = err instanceof Error ? err.message : String(err);
        return { success: false, error: errorMessage };
    }
}

// ============================================================================
// GENERATION METHODS
// ============================================================================

/**
 * Generate using ST's current API settings
 */
async function generateWithCurrentSettings(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal?: AbortSignal,
): Promise<string> {
    const { generateRaw, substituteParams } = SillyTavern.getContext();

    // Run ST's macro substitution on system prompt
    const processedSystemPrompt = substituteParams(systemPrompt);

    debugLog('request', 'generateRaw request', {
        hasSchema: !!jsonSchema,
        schemaName: jsonSchema?.name,
        systemPromptLength: processedSystemPrompt.length,
        userPromptLength: userPrompt.length,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const rawResponse = await generateRaw({
        prompt: [
            { role: 'system', content: processedSystemPrompt },
            { role: 'user', content: userPrompt },
        ],
        jsonSchema: jsonSchema as StructuredOutputSchema | null,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const response = ensureString(rawResponse);

    debugLog('response', 'generateRaw response', {
        type: typeof rawResponse,
        length: response.length,
        preview: response.substring(0, 200),
    });

    return response;
}

/**
 * Generate using custom API settings
 */
async function generateWithCustomSettings(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal?: AbortSignal,
): Promise<string> {
    const { ChatCompletionService, substituteParams } = SillyTavern.getContext();
    const settings = getSettings();
    const config = settings.generationConfig;

    // Run ST's macro substitution on system prompt
    const processedSystemPrompt = substituteParams(systemPrompt);

    const requestOptions: Record<string, unknown> = {
        stream: true,
        messages: [
            { role: 'system', content: processedSystemPrompt },
            { role: 'user', content: userPrompt },
        ],
        chat_completion_source: config.source,
        model: config.model,
        temperature: config.temperature,
        max_tokens: config.maxTokens,
        frequency_penalty: config.frequencyPenalty,
        presence_penalty: config.presencePenalty,
        top_p: config.topP,
    };

    if (jsonSchema) {
        requestOptions.json_schema = jsonSchema;
    }

    debugLog('request', 'ChatCompletionService request', {
        source: config.source,
        model: config.model,
        stream: true,
        hasSchema: !!jsonSchema,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const result = await ChatCompletionService.sendRequest(requestOptions);

    debugLog('response', 'ChatCompletionService result type', {
        type: typeof result,
        isFunction: typeof result === 'function',
        isGenerator: result && typeof result === 'object' && Symbol.asyncIterator in result,
    });

    let response: string;

    // When stream: true, result is a generator function - consume it
    if (typeof result === 'function') {
        response = await consumeStreamGenerator(result, signal);
    } else if (result && typeof result === 'object') {
        const resultObj = result as Record<string, unknown>;

        if (resultObj.error) {
            logError('API returned error', result);
            throw new Error(`API error: ${JSON.stringify(result)}`);
        }

        response = ensureString(resultObj.content || result);
    } else {
        response = ensureString(result);
    }

    debugLog('response', 'Final response', {
        length: response.length,
        preview: response.substring(0, 200),
    });

    return response;
}

/**
 * Consume a streaming generator and return the final accumulated text
 */
async function consumeStreamGenerator(
    generatorFn: () => AsyncGenerator<unknown>,
    signal?: AbortSignal,
): Promise<string> {
    let finalText = '';

    try {
        const generator = generatorFn();

        for await (const chunk of generator) {
            // Check abort during streaming
            if (signal?.aborted) {
                debugLog('info', 'Stream aborted', { textSoFar: finalText.length });
                throw new DOMException('Aborted', 'AbortError');
            }

            const chunkObj = chunk as Record<string, unknown>;

            if (typeof chunkObj.text === 'string') {
                finalText = chunkObj.text;
            }

            if (chunkObj.error) {
                throw new Error(ensureString(chunkObj.error));
            }
        }
    } catch (err) {
        if ((err as Error).name === 'AbortError') {
            throw err;
        }

        logError('Stream consumption error', {
            error: err,
            textSoFar: finalText.length,
        });

        // Return partial response if we have one
        if (finalText) {
            debugLog('info', 'Returning partial response after stream error', {
                length: finalText.length,
            });
            return finalText;
        }

        throw err;
    }

    debugLog('info', 'Stream consumed', { finalLength: finalText.length });
    return finalText;
}

// ============================================================================
// TOKEN ESTIMATION
// ============================================================================

/**
 * Get accurate token count for a stage
 */
export async function getStageTokenCount(
    state: PipelineState,
    stage: StageName,
): Promise<{ promptTokens: number; contextSize: number; percentage: number } | null> {
    const { getTokenCountAsync, maxContext } = SillyTavern.getContext();
    const settings = getSettings();

    if (!state.character) return null;

    try {
        const prompt = buildStagePrompt(state, stage);
        if (!prompt) return null;

        const fullPrompt = settings.systemPrompt + '\n\n' + prompt;
        const promptTokens = await getTokenCountAsync(fullPrompt);
        const percentage = Math.round((promptTokens / maxContext) * 100);

        return {
            promptTokens,
            contextSize: maxContext,
            percentage,
        };
    } catch (e) {
        logError('Token count failed', e);
        return null;
    }
}

/**
 * Get token count for refinement prompt
 */
export async function getRefinementTokenCount(
    state: PipelineState,
): Promise<{ promptTokens: number; contextSize: number; percentage: number } | null> {
    const { getTokenCountAsync, maxContext } = SillyTavern.getContext();
    const settings = getSettings();

    if (!state.character || !state.results.rewrite || !state.results.analyze) return null;

    try {
        const prompt = buildRefinementPrompt(state);
        if (!prompt) return null;

        const fullPrompt = settings.systemPrompt + '\n\n' + prompt;
        const promptTokens = await getTokenCountAsync(fullPrompt);
        const percentage = Math.round((promptTokens / maxContext) * 100);

        return {
            promptTokens,
            contextSize: maxContext,
            percentage,
        };
    } catch (e) {
        logError('Refinement token count failed', e);
        return null;
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Safely convert response to string
 */
function ensureString(value: unknown): string {
    if (typeof value === 'string') return value;
    if (value === null || value === undefined) return '';
    if (typeof value === 'object') {
        try {
            return JSON.stringify(value);
        } catch {
            return String(value);
        }
    }
    return String(value);
}

/**
 * Replace {{char}} and {{user}} placeholders with actual names.
 * This is needed because we're not in a chat context where ST auto-substitutes.
 */
function substituteCharacterPlaceholders(
    text: string,
    charName: string,
    userName: string,
): string {
    return text
        .replace(/\{\{char\}\}/gi, charName)
        .replace(/\{\{user\}\}/gi, userName);
}
```

## FILE: src/schema.ts
```ts
// src/schema.ts
import type { StructuredOutputSchema, SchemaValidationResult, JsonSchemaValue } from './types';

// ============================================================================
// PROVIDER LIMITS
// ============================================================================

// Anthropic limits (strictest - design for these)
const ANTHROPIC_LIMITS = {
    MAX_ANYOF_VARIANTS: 8,
    MAX_DEFS: 100,
    MAX_NESTING_DEPTH: 10,
    MAX_PROPERTIES_PER_OBJECT: 100,
    MAX_ENUM_VALUES: 500,
    SUPPORTED_STRING_FORMATS: [
        'date-time', 'time', 'date', 'duration',
        'email', 'hostname', 'uri', 'ipv4', 'ipv6', 'uuid',
    ] as const,
    SUPPORTED_MINMAX_ITEMS: [0, 1] as const,
} as const;

// Features that will be silently ignored (not errors, but won't work)
const IGNORED_CONSTRAINTS = {
    numeric: ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum', 'multipleOf'],
    string: ['minLength', 'maxLength'],
    array: ['maxItems', 'uniqueItems', 'contains', 'minContains', 'maxContains'],
    object: ['minProperties', 'maxProperties', 'propertyNames', 'patternProperties'],
} as const;

// Completely unsupported features (will cause errors)
const UNSUPPORTED_FEATURES = [
    'if', 'then', 'else',           // Conditional schemas
    'not',                           // Negation
    'oneOf',                         // Use anyOf instead
    'dependentRequired',             // Dependent requirements
    'dependentSchemas',              // Dependent schemas
    'unevaluatedProperties',         // OpenAPI 3.1 feature
    'unevaluatedItems',              // OpenAPI 3.1 feature
    '$dynamicRef',                   // Dynamic references
    '$dynamicAnchor',                // Dynamic anchors
] as const;

// Regex features NOT supported
const UNSUPPORTED_REGEX_FEATURES = [
    { pattern: /\(\?[=!<]/, name: 'lookahead/lookbehind assertions' },
    { pattern: /\\[1-9]/, name: 'backreferences' },
    { pattern: /\\[bB]/, name: 'word boundaries' },
] as const;

// ============================================================================
// VALIDATION TYPES
// ============================================================================

interface ValidationContext {
    errors: string[];
    warnings: string[];
    info: string[];
    stats: {
        defCount: number;
        anyOfCount: number;
        totalAnyOfVariants: number;
        maxDepth: number;
        propertyCount: number;
        optionalFieldCount: number;
        enumCount: number;
    };
    currentDepth: number;
    seenRefs: Set<string>;
    defs: Record<string, JsonSchemaValue>;
}

const SCHEMA_GENERATION_PROMPT = `Generate a JSON Schema for structured LLM output based on the user's description.

Requirements:
- Output ONLY valid JSON, no markdown, no explanation
- Use this exact wrapper format: {"name": "SchemaName", "strict": true, "value": {...}}
- The "value" must be a valid JSON Schema with "type": "object"
- Add "additionalProperties": false to ALL object types (required for Anthropic)
- All object properties should be in a "required" array unless explicitly optional
- Use simple types: string, number, integer, boolean, array, object
- For arrays, always specify "items" with a schema
- Keep it minimal - only what the user asked for

User's description:`;

export async function generateSchemaFromDescription(description: string): Promise<{
    success: boolean;
    schema?: string;
    error?: string;
}> {
    const { generateRaw } = SillyTavern.getContext();

    if (!description.trim()) {
        return { success: false, error: 'Please describe what you want in the schema' };
    }

    try {
        const response = await generateRaw({
            prompt: `${SCHEMA_GENERATION_PROMPT}\n\n${description}`,
            systemPrompt: 'You are a JSON Schema expert. Output only valid JSON, nothing else.',
        });

        // Clean up response - strip markdown code blocks if present
        let cleaned = response.trim();
        if (cleaned.startsWith('```')) {
            cleaned = cleaned.replace(/^```(?:json)?\s*/, '').replace(/\s*```$/, '');
        }

        // Validate what we got
        const validation = validateSchema(cleaned);

        if (!validation.valid) {
            return {
                success: false,
                error: `Generated schema is invalid: ${validation.error}`,
                schema: cleaned, // Return it anyway so user can fix
            };
        }

        // Auto-fix if needed
        if (validation.warnings?.length) {
            const fixed = autoFixSchema(validation.schema!);
            return {
                success: true,
                schema: JSON.stringify(fixed, null, 2),
            };
        }

        return {
            success: true,
            schema: JSON.stringify(validation.schema, null, 2),
        };
    } catch (e) {
        return {
            success: false,
            error: `Generation failed: ${(e as Error).message}`,
        };
    }
}

// ============================================================================
// MAIN VALIDATION FUNCTION
// ============================================================================

/**
 * Validates a JSON schema for Anthropic/OpenRouter structured output compatibility.
 *
 * Checks:
 * - JSON syntax validity
 * - Required ST wrapper structure (name, value)
 * - Anthropic-specific limits (anyOf variants, nesting depth, etc.)
 * - Required additionalProperties: false on all objects
 * - Unsupported JSON Schema features
 * - Regex pattern compatibility
 * - Optional field count (spawns anyOf with null)
 */
export function validateSchema(input: string): SchemaValidationResult {
    // Empty input = disable structured output
    if (!input.trim()) {
        return { valid: true, schema: undefined };
    }

    // Parse JSON
    let parsed: unknown;
    try {
        parsed = JSON.parse(input);
    } catch (e) {
        const error = e instanceof Error ? e.message : 'Invalid JSON';
        // Try to give helpful position info
        const match = error.match(/position (\d+)/);
        const position = match ? ` (character ${match[1]})` : '';
        return { valid: false, error: `JSON syntax error${position}: ${error}` };
    }

    // Must be an object
    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
        return { valid: false, error: 'Schema must be a JSON object, not ' + (Array.isArray(parsed) ? 'array' : typeof parsed) };
    }

    const obj = parsed as Record<string, unknown>;

    // ========== ST WRAPPER VALIDATION ==========

    // Required: name (string, non-empty, valid identifier)
    if (typeof obj.name !== 'string') {
        return { valid: false, error: 'Missing required \'name\' property (string)' };
    }
    if (!obj.name.trim()) {
        return { valid: false, error: '\'name\' cannot be empty' };
    }
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(obj.name)) {
        return { valid: false, error: `'name' must be a valid identifier (got '${obj.name}'). Use letters, numbers, underscores; start with letter or underscore.` };
    }

    // Required: value (object with type)
    if (typeof obj.value !== 'object' || obj.value === null || Array.isArray(obj.value)) {
        return { valid: false, error: 'Missing or invalid \'value\' property (must be object)' };
    }

    const value = obj.value as JsonSchemaValue;

    if (typeof value.type !== 'string' && !value.anyOf && !value.allOf && !value.$ref) {
        return { valid: false, error: '\'value\' must have a \'type\', \'anyOf\', \'allOf\', or \'$ref\'' };
    }

    // Optional: strict (boolean)
    if (obj.strict !== undefined && typeof obj.strict !== 'boolean') {
        return { valid: false, error: '\'strict\' must be a boolean if provided' };
    }

    // ========== DEEP SCHEMA VALIDATION ==========

    const ctx: ValidationContext = {
        errors: [],
        warnings: [],
        info: [],
        stats: {
            defCount: 0,
            anyOfCount: 0,
            totalAnyOfVariants: 0,
            maxDepth: 0,
            propertyCount: 0,
            optionalFieldCount: 0,
            enumCount: 0,
        },
        currentDepth: 0,
        seenRefs: new Set(),
        defs: {},
    };

    // Extract $defs/definitions first
    if (value.$defs && typeof value.$defs === 'object') {
        ctx.defs = value.$defs as Record<string, JsonSchemaValue>;
        ctx.stats.defCount = Object.keys(ctx.defs).length;
    } else if (value.definitions && typeof value.definitions === 'object') {
        ctx.defs = value.definitions as Record<string, JsonSchemaValue>;
        ctx.stats.defCount = Object.keys(ctx.defs).length;
    }

    if (ctx.stats.defCount > ANTHROPIC_LIMITS.MAX_DEFS) {
        ctx.errors.push(`Too many definitions: ${ctx.stats.defCount} (limit: ${ANTHROPIC_LIMITS.MAX_DEFS})`);
    }

    // Validate the schema tree
    validateSchemaNode(value, 'value', ctx);

    // Check optional field explosion
    if (ctx.stats.optionalFieldCount > 0) {
        const implicitAnyOfs = ctx.stats.optionalFieldCount;
        const totalAnyOfs = ctx.stats.totalAnyOfVariants + implicitAnyOfs * 2; // Each optional spawns anyOf[type, null]

        if (implicitAnyOfs > 10) {
            ctx.warnings.push(
                `${implicitAnyOfs} optional fields detected. Each spawns an implicit anyOf with null. ` +
        'Consider making fields required or reducing optionals.',
            );
        }

        if (totalAnyOfs > 50) {
            ctx.warnings.push(
                `High anyOf count (~${totalAnyOfs} including implicit nullables). ` +
        'May cause slow schema compilation or errors.',
            );
        }
    }

    // ========== BUILD RESULT ==========

    if (ctx.errors.length > 0) {
        return {
            valid: false,
            error: ctx.errors.join('\n'),
            warnings: ctx.warnings.length > 0 ? ctx.warnings : undefined,
        };
    }

    const schema: StructuredOutputSchema = {
        name: obj.name,
        strict: obj.strict as boolean | undefined ?? true, // Default to strict
        value: value,
    };

    // Add stats as info
    ctx.info.push(
        `Schema stats: ${ctx.stats.propertyCount} properties, ` +
    `${ctx.stats.defCount} definitions, ` +
    `${ctx.stats.anyOfCount} anyOf blocks, ` +
    `${ctx.stats.optionalFieldCount} optional fields, ` +
    `max depth ${ctx.stats.maxDepth}`,
    );

    return {
        valid: true,
        schema,
        warnings: ctx.warnings.length > 0 ? ctx.warnings : undefined,
        info: ctx.info.length > 0 ? ctx.info : undefined,
    };
}

// ============================================================================
// RECURSIVE NODE VALIDATION
// ============================================================================

function validateSchemaNode(
    node: JsonSchemaValue,
    path: string,
    ctx: ValidationContext,
): void {
    ctx.currentDepth++;
    ctx.stats.maxDepth = Math.max(ctx.stats.maxDepth, ctx.currentDepth);

    // Check nesting depth
    if (ctx.currentDepth > ANTHROPIC_LIMITS.MAX_NESTING_DEPTH) {
        ctx.errors.push(`${path}: Exceeds maximum nesting depth of ${ANTHROPIC_LIMITS.MAX_NESTING_DEPTH}`);
        ctx.currentDepth--;
        return;
    }

    // Check for completely unsupported features
    for (const feature of UNSUPPORTED_FEATURES) {
        if (node[feature] !== undefined) {
            ctx.errors.push(`${path}: '${feature}' is not supported`);
        }
    }

    // Check for ignored constraints (warn, don't error)
    for (const key of IGNORED_CONSTRAINTS.numeric) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.string) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.array) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.object) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }

    // Handle $ref
    if (node.$ref && typeof node.$ref === 'string') {
        validateRef(node.$ref, path, ctx);
        ctx.currentDepth--;
        return; // $ref replaces the node
    }

    // Handle type-specific validation
    const types = Array.isArray(node.type) ? node.type : [node.type];

    for (const type of types) {
        switch (type) {
            case 'object':
                validateObjectNode(node, path, ctx);
                break;
            case 'array':
                validateArrayNode(node, path, ctx);
                break;
            case 'string':
                validateStringNode(node, path, ctx);
                break;
            case 'number':
            case 'integer':
                validateNumericNode(node, path, ctx);
                break;
            case 'boolean':
            case 'null':
                // No special validation needed
                break;
            default:
                if (type && !node.anyOf && !node.allOf) {
                    ctx.warnings.push(`${path}: Unknown type '${type}'`);
                }
        }
    }

    // Handle anyOf
    if (node.anyOf && Array.isArray(node.anyOf)) {
        validateAnyOf(node.anyOf, path, ctx);
    }

    // Handle allOf
    if (node.allOf && Array.isArray(node.allOf)) {
        validateAllOf(node.allOf, path, ctx);
    }

    // Handle enum
    if (node.enum && Array.isArray(node.enum)) {
        validateEnum(node.enum, path, ctx);
    }

    // Handle const
    if (node.const !== undefined) {
        validateConst(node.const, path, ctx);
    }

    ctx.currentDepth--;
}

// ============================================================================
// TYPE-SPECIFIC VALIDATORS
// ============================================================================

function validateObjectNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // CRITICAL: additionalProperties must be false
    if (node.additionalProperties !== false) {
        ctx.warnings.push(`${path}: Missing 'additionalProperties: false' (REQUIRED for Anthropic)`);
    }

    // Validate properties
    if (node.properties && typeof node.properties === 'object') {
        const props = node.properties as Record<string, JsonSchemaValue>;
        const propCount = Object.keys(props).length;
        ctx.stats.propertyCount += propCount;

        if (propCount > ANTHROPIC_LIMITS.MAX_PROPERTIES_PER_OBJECT) {
            ctx.warnings.push(
                `${path}: ${propCount} properties (may be slow, consider splitting)`,
            );
        }

        // Track optional fields
        const required = (node.required as string[]) || [];
        for (const [key, prop] of Object.entries(props)) {
            if (!required.includes(key)) {
                ctx.stats.optionalFieldCount++;
            }

            if (prop && typeof prop === 'object') {
                validateSchemaNode(prop, `${path}.${key}`, ctx);
            }
        }
    }
}

function validateArrayNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // minItems only supports 0 or 1
    if (node.minItems !== undefined) {
        const allowed = ANTHROPIC_LIMITS.SUPPORTED_MINMAX_ITEMS as readonly number[];
        if (!allowed.includes(node.minItems as number)) {
            ctx.warnings.push(
                `${path}: 'minItems: ${node.minItems}' not supported (only 0 or 1 allowed)`,
            );
        }
    }

    // Validate items schema
    if (node.items) {
        if (typeof node.items === 'object' && !Array.isArray(node.items)) {
            validateSchemaNode(node.items as JsonSchemaValue, `${path}.items`, ctx);
        } else if (Array.isArray(node.items)) {
            // Tuple validation (array of schemas)
            node.items.forEach((item, i) => {
                if (item && typeof item === 'object') {
                    validateSchemaNode(item as JsonSchemaValue, `${path}.items[${i}]`, ctx);
                }
            });
        }
    }

    // prefixItems (JSON Schema draft 2020-12)
    if (node.prefixItems && Array.isArray(node.prefixItems)) {
        node.prefixItems.forEach((item, i) => {
            if (item && typeof item === 'object') {
                validateSchemaNode(item as JsonSchemaValue, `${path}.prefixItems[${i}]`, ctx);
            }
        });
    }
}

function validateStringNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // Check format
    if (node.format && typeof node.format === 'string') {
        const supported = ANTHROPIC_LIMITS.SUPPORTED_STRING_FORMATS as readonly string[];
        if (!supported.includes(node.format)) {
            ctx.warnings.push(
                `${path}: format '${node.format}' may not be supported. ` +
        `Supported: ${supported.join(', ')}`,
            );
        }
    }

    // Check pattern (regex)
    if (node.pattern && typeof node.pattern === 'string') {
        validateRegexPattern(node.pattern, path, ctx);
    }
}

function validateNumericNode(_node: JsonSchemaValue, _path: string, _ctx: ValidationContext): void {
    // All numeric constraints are ignored, already warned above
    // Nothing additional to check
}

function validateRef(ref: string, path: string, ctx: ValidationContext): void {
    // External refs not supported
    if (ref.startsWith('http://') || ref.startsWith('https://')) {
        ctx.errors.push(`${path}: External $ref not supported ('${ref}')`);
        return;
    }

    // Check for circular refs
    if (ctx.seenRefs.has(ref)) {
        // Not necessarily an error, but worth noting
        ctx.info.push(`${path}: Circular reference to '${ref}'`);
        return;
    }

    ctx.seenRefs.add(ref);

    // Validate the referenced definition exists
    const refPath = ref.replace(/^#\/(\$defs|definitions)\//, '');
    if (!ctx.defs[refPath]) {
        ctx.errors.push(`${path}: Reference '${ref}' not found in definitions`);
    }
}

function validateAnyOf(variants: unknown[], path: string, ctx: ValidationContext): void {
    ctx.stats.anyOfCount++;
    ctx.stats.totalAnyOfVariants += variants.length;

    if (variants.length > ANTHROPIC_LIMITS.MAX_ANYOF_VARIANTS) {
        ctx.errors.push(
            `${path}: anyOf has ${variants.length} variants (max: ${ANTHROPIC_LIMITS.MAX_ANYOF_VARIANTS})`,
        );
    }

    if (variants.length === 0) {
        ctx.errors.push(`${path}: anyOf cannot be empty`);
        return;
    }

    variants.forEach((variant, i) => {
        if (variant && typeof variant === 'object') {
            validateSchemaNode(variant as JsonSchemaValue, `${path}.anyOf[${i}]`, ctx);
        }
    });
}

function validateAllOf(variants: unknown[], path: string, ctx: ValidationContext): void {
    if (variants.length === 0) {
        ctx.errors.push(`${path}: allOf cannot be empty`);
        return;
    }

    variants.forEach((variant, i) => {
        if (variant && typeof variant === 'object') {
            const v = variant as Record<string, unknown>;

            // allOf with $ref not supported
            if (v.$ref) {
                ctx.errors.push(`${path}.allOf[${i}]: allOf with $ref not supported`);
            }

            validateSchemaNode(v as JsonSchemaValue, `${path}.allOf[${i}]`, ctx);
        }
    });
}

function validateEnum(values: unknown[], path: string, ctx: ValidationContext): void {
    ctx.stats.enumCount++;

    if (values.length === 0) {
        ctx.errors.push(`${path}: enum cannot be empty`);
        return;
    }

    if (values.length > ANTHROPIC_LIMITS.MAX_ENUM_VALUES) {
        ctx.warnings.push(
            `${path}: enum has ${values.length} values (may be slow)`,
        );
    }

    // Check for complex types (not allowed)
    for (let i = 0; i < values.length; i++) {
        const val = values[i];
        const t = typeof val;

        if (t !== 'string' && t !== 'number' && t !== 'boolean' && val !== null) {
            ctx.errors.push(
                `${path}.enum[${i}]: Complex type not allowed in enum (got ${t}). ` +
        'Only string, number, boolean, null permitted.',
            );
            break; // One error is enough
        }
    }

    // Check for duplicates
    const seen = new Set();
    for (const val of values) {
        const key = JSON.stringify(val);
        if (seen.has(key)) {
            ctx.warnings.push(`${path}: Duplicate value in enum: ${key}`);
            break;
        }
        seen.add(key);
    }
}

function validateConst(value: unknown, path: string, ctx: ValidationContext): void {
    const t = typeof value;
    if (t !== 'string' && t !== 'number' && t !== 'boolean' && value !== null) {
        ctx.errors.push(
            `${path}: const must be string, number, boolean, or null (got ${t})`,
        );
    }
}

function validateRegexPattern(pattern: string, path: string, ctx: ValidationContext): void {
    // Check for unsupported regex features
    for (const { pattern: check, name } of UNSUPPORTED_REGEX_FEATURES) {
        if (check.test(pattern)) {
            ctx.errors.push(`${path}: Regex pattern uses unsupported feature: ${name}`);
        }
    }

    // Try to compile the regex to catch syntax errors
    try {
        new RegExp(pattern);
    } catch (e) {
        const msg = e instanceof Error ? e.message : 'Invalid regex';
        ctx.errors.push(`${path}: Invalid regex pattern: ${msg}`);
    }

    // Warn about complex quantifiers
    const complexQuantifier = /\{(\d+),(\d+)\}/g;
    let match;
    while ((match = complexQuantifier.exec(pattern)) !== null) {
        const min = parseInt(match[1], 10);
        const max = parseInt(match[2], 10);
        if (max - min > 100) {
            ctx.warnings.push(
                `${path}: Large quantifier range {${min},${max}} may cause issues`,
            );
        }
    }
}

// ============================================================================
// AUTO-FIX FUNCTIONS
// ============================================================================

/**
 * Auto-fixes a schema by:
 * 1. Adding additionalProperties: false to all objects
 * 2. Removing unsupported constraints (with description updates)
 * 3. Setting strict: true if not set
 */
export function autoFixSchema(schema: StructuredOutputSchema): StructuredOutputSchema {
    const fixed = structuredClone(schema);

    // Ensure strict mode
    if (fixed.strict === undefined) {
        fixed.strict = true;
    }

    // Fix the value recursively
    fixSchemaNode(fixed.value);

    return fixed;
}

function fixSchemaNode(node: JsonSchemaValue): void {
    // Fix objects
    if (node.type === 'object') {
        node.additionalProperties = false;

        if (node.properties && typeof node.properties === 'object') {
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    fixSchemaNode(prop as JsonSchemaValue);
                }
            }
        }
    }

    // Fix arrays
    if (node.type === 'array' && node.items && typeof node.items === 'object') {
        if (!Array.isArray(node.items)) {
            fixSchemaNode(node.items as JsonSchemaValue);
        } else {
            node.items.forEach(item => {
                if (item && typeof item === 'object') {
                    fixSchemaNode(item as JsonSchemaValue);
                }
            });
        }
    }

    // Fix anyOf
    if (node.anyOf && Array.isArray(node.anyOf)) {
        node.anyOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                fixSchemaNode(variant as JsonSchemaValue);
            }
        });
    }

    // Fix allOf
    if (node.allOf && Array.isArray(node.allOf)) {
        node.allOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                fixSchemaNode(variant as JsonSchemaValue);
            }
        });
    }

    // Move unsupported constraints to description
    const constraints: string[] = [];

    for (const key of IGNORED_CONSTRAINTS.numeric) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    for (const key of IGNORED_CONSTRAINTS.string) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    for (const key of IGNORED_CONSTRAINTS.array) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    // Fix minItems if invalid
    if (node.minItems !== undefined && node.minItems !== null) {
        const minItems = node.minItems as number;
        if (minItems !== 0 && minItems !== 1) {
            constraints.push(`minItems: ${minItems}`);
            node.minItems = minItems > 0 ? 1 : 0;
        }
    }

    // Append constraints to description
    if (constraints.length > 0) {
        const constraintNote = `[Constraints: ${constraints.join(', ')}]`;
        if (node.description) {
            node.description = `${node.description} ${constraintNote}`;
        } else {
            node.description = constraintNote;
        }
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Formats a schema object as a pretty-printed JSON string.
 */
export function formatSchema(schema: StructuredOutputSchema | null): string {
    if (!schema) return '';
    return JSON.stringify(schema, null, 2);
}

/**
 * Attempts to parse a structured output response.
 * Returns the parsed object or null if parsing fails.
 * Optionally validates against a schema and returns partial results with warnings.
 */
export function parseStructuredResponse(
    response: string,
    schema?: StructuredOutputSchema,
): { data: unknown; warnings: string[] } | null {
    let parsed: unknown;

    try {
        parsed = JSON.parse(response);
    } catch {
        // Try to extract JSON from markdown code blocks
        const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlockMatch) {
            try {
                parsed = JSON.parse(codeBlockMatch[1].trim());
            } catch {
                return null;
            }
        } else {
            return null;
        }
    }

    const warnings: string[] = [];

    // If schema provided, validate required fields
    if (schema && schema.value.required && Array.isArray(schema.value.required)) {
        const missing = schema.value.required.filter(
            field => !(field in (parsed as Record<string, unknown>)),
        );

        if (missing.length > 0) {
            warnings.push(`Missing required fields: ${missing.join(', ')}`);
        }
    }

    return { data: parsed, warnings };
}

/**
 * Counts optional fields in a schema (fields not in 'required' array).
 * Each optional field spawns an implicit anyOf with null.
 */
export function countOptionalFields(schema: JsonSchemaValue): number {
    let count = 0;

    function walk(node: JsonSchemaValue): void {
        if (node.type === 'object' && node.properties) {
            const required = (node.required as string[]) || [];
            const props = node.properties as Record<string, JsonSchemaValue>;

            for (const [key, prop] of Object.entries(props)) {
                if (!required.includes(key)) {
                    count++;
                }
                if (prop && typeof prop === 'object') {
                    walk(prop);
                }
            }
        }

        if (node.type === 'array' && node.items && typeof node.items === 'object') {
            if (!Array.isArray(node.items)) {
                walk(node.items as JsonSchemaValue);
            }
        }

        if (node.anyOf && Array.isArray(node.anyOf)) {
            node.anyOf.forEach(v => {
                if (v && typeof v === 'object') walk(v as JsonSchemaValue);
            });
        }

        if (node.allOf && Array.isArray(node.allOf)) {
            node.allOf.forEach(v => {
                if (v && typeof v === 'object') walk(v as JsonSchemaValue);
            });
        }
    }

    walk(schema);
    return count;
}

/**
 * Estimates schema complexity for UI feedback.
 */
export function estimateSchemaComplexity(schema: StructuredOutputSchema): {
    level: 'simple' | 'moderate' | 'complex' | 'extreme';
    score: number;
    factors: string[];
} {
    const factors: string[] = [];
    let score = 0;

    const result = validateSchema(JSON.stringify(schema));
    if (!result.valid) {
        return { level: 'extreme', score: 100, factors: ['Invalid schema'] };
    }

    // Count various complexity factors
    const value = schema.value;

    function countNodes(node: JsonSchemaValue): number {
        let count = 1;
        if (node.properties) {
            count += Object.keys(node.properties).length;
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    count += countNodes(prop as JsonSchemaValue);
                }
            }
        }
        if (node.items && typeof node.items === 'object' && !Array.isArray(node.items)) {
            count += countNodes(node.items as JsonSchemaValue);
        }
        if (node.anyOf && Array.isArray(node.anyOf)) count += node.anyOf.length * 2;
        if (node.allOf && Array.isArray(node.allOf)) count += node.allOf.length * 2;
        return count;
    }

    const nodeCount = countNodes(value);
    const optionalCount = countOptionalFields(value);
    const defCount = Object.keys(value.$defs || value.definitions || {}).length;

    if (nodeCount > 50) {
        score += 30;
        factors.push(`${nodeCount} schema nodes`);
    } else if (nodeCount > 20) {
        score += 15;
        factors.push(`${nodeCount} schema nodes`);
    }

    if (optionalCount > 10) {
        score += 25;
        factors.push(`${optionalCount} optional fields (implicit anyOf)`);
    } else if (optionalCount > 5) {
        score += 10;
        factors.push(`${optionalCount} optional fields`);
    }

    if (defCount > 10) {
        score += 20;
        factors.push(`${defCount} definitions`);
    } else if (defCount > 5) {
        score += 10;
        factors.push(`${defCount} definitions`);
    }

    // Determine level
    let level: 'simple' | 'moderate' | 'complex' | 'extreme';
    if (score >= 60) {
        level = 'extreme';
    } else if (score >= 35) {
        level = 'complex';
    } else if (score >= 15) {
        level = 'moderate';
    } else {
        level = 'simple';
    }

    if (factors.length === 0) {
        factors.push('Simple schema');
    }

    return { level, score, factors };
}
```

## FILE: src/debug.ts
```ts
// src/debug.ts
//
// Debug logging and diagnostics for the extension.

import { MODULE_NAME, MAX_DEBUG_LOG_ENTRIES } from './constants';
import { getSettings } from './settings';
import type { DebugLogEntry, DebugLogType } from './types';

// ============================================================================
// LOG STORAGE
// ============================================================================

const logEntries: DebugLogEntry[] = [];

// ============================================================================
// LOGGING
// ============================================================================

/**
 * Check if debug mode is enabled
 */
export function isDebugMode(): boolean {
    try {
        return getSettings().debugMode;
    } catch {
        // Settings might not be initialized yet
        return false;
    }
}

/**
 * Log a debug entry
 */
export function debugLog(type: DebugLogType, label: string, data: unknown): void {
    const entry: DebugLogEntry = {
        timestamp: new Date(),
        type,
        label,
        data,
    };

    // Always store (for later viewing even if debug mode was off)
    logEntries.unshift(entry);
    if (logEntries.length > MAX_DEBUG_LOG_ENTRIES) {
        logEntries.pop();
    }

    // Errors always log to console regardless of debug mode
    if (type === 'error') {
        console.error(`[${MODULE_NAME}:ERROR]`, label, data);
        return;
    }

    // Other types only log if debug mode is on
    if (isDebugMode()) {
        const prefix = `[${MODULE_NAME}:${type.toUpperCase()}]`;
        switch (type) {
            case 'request':
            case 'response':
                console.debug(prefix, label, data);
                break;
            case 'state':
            case 'info':
            default:
                console.log(prefix, label, data);
        }
    }
}

/**
 * Log an error - always outputs to console and stores in debug log.
 * Use this for errors that should never be silently swallowed.
 */
export function logError(label: string, data: unknown): void {
    debugLog('error', label, data);
}

// ============================================================================
// LOG ACCESS
// ============================================================================

/**
 * Get all debug logs
 */
export function getDebugLogs(): DebugLogEntry[] {
    return [...logEntries];
}

/**
 * Get logs filtered by type
 */
export function getDebugLogsByType(type: DebugLogType): DebugLogEntry[] {
    return logEntries.filter(e => e.type === type);
}

/**
 * Clear all debug logs
 */
export function clearDebugLogs(): void {
    logEntries.length = 0;
}

// ============================================================================
// FORMATTING
// ============================================================================

/**
 * Format a log entry for display
 */
export function formatLogEntry(entry: DebugLogEntry): string {
    const time = entry.timestamp.toLocaleTimeString();
    const icon = {
        request: '📤',
        response: '📥',
        error: '❌',
        info: 'ℹ️',
        state: '🔄',
    }[entry.type];

    return `${icon} [${time}] ${entry.label}`;
}

/**
 * Format log data for display
 */
export function formatLogData(data: unknown): string {
    try {
        if (data === null) return 'null';
        if (data === undefined) return 'undefined';
        if (typeof data === 'string') return data;
        return JSON.stringify(data, null, 2);
    } catch {
        return String(data);
    }
}

// ============================================================================
// DIAGNOSTICS
// ============================================================================

/**
 * Collect debug info for current state
 */
export function collectDebugInfo(): Record<string, unknown> {
    const context = SillyTavern.getContext();

    let settings;
    try {
        settings = getSettings();
    } catch {
        settings = { error: 'Failed to load settings' };
    }

    return {
        extension: {
            settings: {
                useCurrentSettings: settings.useCurrentSettings,
                debugMode: settings.debugMode,
                generationConfig: settings.generationConfig,
                systemPromptLength: settings.systemPrompt?.length || 0,
                promptPresetCount: settings.promptPresets?.length || 0,
                schemaPresetCount: settings.schemaPresets?.length || 0,
            },
        },
        sillytavern: {
            mainApi: context.mainApi,
            onlineStatus: context.onlineStatus,
            chatCompletionSource: context.chatCompletionSettings?.chat_completion_source,
            currentModel: context.chatCompletionSettings?.openrouter_model ||
                    context.chatCompletionSettings?.model_openai_select,
            maxContext: context.maxContext,
            characterCount: context.characters?.length ?? 0,
            hasActiveChat: !!context.chat?.length,
        },
        logs: {
            total: logEntries.length,
            errors: logEntries.filter(e => e.type === 'error').length,
            recent: logEntries.slice(0, 10).map(e => ({
                type: e.type,
                label: e.label,
                time: e.timestamp.toISOString(),
            })),
        },
    };
}

/**
 * Export debug info as JSON string
 */
export function exportDebugInfo(): string {
    return JSON.stringify(collectDebugInfo(), null, 2);
}
```

## FILE: src/pipeline.ts
```ts
// src/pipeline.ts
//
// Pipeline state machine for managing the character analysis workflow.
// Handles stage progression, state transitions, result management, and iteration.

import type {
    StageName,
    StageStatus,
    StageResult,
    StageConfig,
    PipelineState,
    Character,
    PopulatedField,
    StructuredOutputSchema,
    IterationSnapshot,
    IterationVerdict,
    ParsedRewrite,
    ParsedRewriteField,
} from './types';
import { STAGES, CHARACTER_FIELDS, MAX_ITERATION_HISTORY } from './constants';
import { createStageConfigFromDefaults, resolvePrompt, resolveSchema, processPromptTemplate, promptHasPlaceholders } from './presets';
import { getSettings } from './settings';
import { debugLog, logError } from './debug';

// ============================================================================
// PIPELINE STATE FACTORY
// ============================================================================

/**
 * Create a fresh pipeline state
 */
export function createPipelineState(): PipelineState {
    return {
        character: null,
        characterIndex: null,

        results: {
            score: null,
            rewrite: null,
            analyze: null,
        },

        configs: {
            score: createStageConfigFromDefaults('score'),
            rewrite: createStageConfigFromDefaults('rewrite'),
            analyze: createStageConfigFromDefaults('analyze'),
        },

        selectedStages: ['score', 'rewrite'],  // Default pipeline
        currentStage: null,
        stageStatus: {
            score: 'pending',
            rewrite: 'pending',
            analyze: 'pending',
        },

        // Iteration system
        iterationCount: 0,
        iterationHistory: [],
        isRefining: false,

        exportData: null,
    };
}

/**
 * Reset pipeline state while optionally keeping character selection
 */
export function resetPipeline(state: PipelineState, keepCharacter: boolean = false): PipelineState {
    const fresh = createPipelineState();

    if (keepCharacter && state.character) {
        fresh.character = state.character;
        fresh.characterIndex = state.characterIndex;
    }

    debugLog('state', 'Pipeline reset', { keepCharacter, hasCharacter: !!fresh.character });
    return fresh;
}

// ============================================================================
// CHARACTER MANAGEMENT
// ============================================================================

/**
 * Set the selected character and reset results
 */
export function setCharacter(state: PipelineState, character: Character | null, index: number | null): PipelineState {
    // If same character, don't reset
    if (state.characterIndex === index && index !== null) {
        return state;
    }

    const newState: PipelineState = {
        ...state,
        character,
        characterIndex: index,
        // Reset results when character changes
        results: {
            score: null,
            rewrite: null,
            analyze: null,
        },
        stageStatus: {
            score: 'pending',
            rewrite: 'pending',
            analyze: 'pending',
        },
        currentStage: null,
        // Reset iteration state
        iterationCount: 0,
        iterationHistory: [],
        isRefining: false,
        exportData: null,
    };

    debugLog('state', 'Character set', {
        name: character?.name,
        index,
        fieldsPopulated: character ? getPopulatedFields(character).length : 0,
    });

    return newState;
}

/**
 * Get populated fields from a character
 */
export function getPopulatedFields(char: Character): PopulatedField[] {
    return CHARACTER_FIELDS
        .filter(field => {
            const val = char[field.key];
            return val && typeof val === 'string' && val.trim().length > 0;
        })
        .map(field => {
            const value = (char[field.key] as string).trim();
            return {
                key: field.key,
                label: field.label,
                value,
                charCount: value.length,
                scoreable: field.scoreable,
            };
        });
}

/**
 * Build character summary for prompts
 */
export function buildCharacterSummary(char: Character): string {
    const fields = getPopulatedFields(char);

    const sections = fields.map(f => `### ${f.label}\n${f.value}`);

    return `# CHARACTER: ${char.name}\n\n${sections.join('\n\n')}`;
}

// ============================================================================
// STAGE SELECTION
// ============================================================================

/**
 * Toggle a stage in the selected stages list
 */
export function toggleStage(state: PipelineState, stage: StageName): PipelineState {
    const selected = new Set(state.selectedStages);

    if (selected.has(stage)) {
        selected.delete(stage);
    } else {
        selected.add(stage);
    }

    // Maintain order based on STAGES constant
    const orderedSelected = STAGES.filter(s => selected.has(s));

    debugLog('state', 'Stage toggled', { stage, selected: orderedSelected });

    return {
        ...state,
        selectedStages: orderedSelected,
    };
}

/**
 * Set all selected stages at once
 */
export function setSelectedStages(state: PipelineState, stages: StageName[]): PipelineState {
    // Maintain order based on STAGES constant
    const orderedSelected = STAGES.filter(s => stages.includes(s));

    return {
        ...state,
        selectedStages: orderedSelected,
    };
}

/**
 * Select all stages
 */
export function selectAllStages(state: PipelineState): PipelineState {
    return {
        ...state,
        selectedStages: [...STAGES],
    };
}

/**
 * Check if a stage can be run (has required dependencies)
 */
export function canRunStage(state: PipelineState, stage: StageName): { canRun: boolean; reason?: string } {
    if (!state.character) {
        return { canRun: false, reason: 'No character selected' };
    }

    // Check stage-specific dependencies
    switch (stage) {
        case 'score':
            // Score can always run if we have a character
            return { canRun: true };

        case 'rewrite':
            // Rewrite can run standalone OR with score results
            // If score is in selected stages and not complete, warn but allow
            if (state.selectedStages.includes('score') && !state.results.score?.locked) {
                return {
                    canRun: true,
                    reason: 'Score stage not complete - rewrite will run without score feedback',
                };
            }
            return { canRun: true };

        case 'analyze':
            // Analyze needs rewrite results to compare
            if (!state.results.rewrite) {
                return { canRun: false, reason: 'Analyze requires rewrite results to compare' };
            }
            return { canRun: true };

        default:
            return { canRun: false, reason: 'Unknown stage' };
    }
}

/**
 * Check if refinement can be run
 */
export function canRefine(state: PipelineState): { canRun: boolean; reason?: string } {
    if (!state.character) {
        return { canRun: false, reason: 'No character selected' };
    }

    if (!state.results.rewrite) {
        return { canRun: false, reason: 'No rewrite to refine' };
    }

    if (!state.results.analyze) {
        return { canRun: false, reason: 'Run analyze first to identify issues' };
    }

    return { canRun: true };
}

// ============================================================================
// STAGE CONFIG MANAGEMENT
// ============================================================================

/**
 * Update a stage's config
 */
export function updateStageConfig(
    state: PipelineState,
    stage: StageName,
    updates: Partial<StageConfig>,
): PipelineState {
    return {
        ...state,
        configs: {
            ...state.configs,
            [stage]: {
                ...state.configs[stage],
                ...updates,
            },
        },
    };
}

/**
 * Reset a stage's config to defaults
 */
export function resetStageConfig(state: PipelineState, stage: StageName): PipelineState {
    return {
        ...state,
        configs: {
            ...state.configs,
            [stage]: createStageConfigFromDefaults(stage),
        },
    };
}

// ============================================================================
// STAGE EXECUTION
// ============================================================================

/**
 * Mark a stage as running
 */
export function startStage(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage started', { stage });

    return {
        ...state,
        currentStage: stage,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'running' as StageStatus,
        },
    };
}

/**
 * Complete a stage with results
 */
export function completeStage(
    state: PipelineState,
    stage: StageName,
    result: Omit<StageResult, 'timestamp' | 'locked'>,
): PipelineState {
    const stageResult: StageResult = {
        ...result,
        timestamp: Date.now(),
        locked: false,
    };

    debugLog('state', 'Stage completed', {
        stage,
        responseLength: result.response.length,
        isStructured: result.isStructured,
    });

    // If this is analyze completing, we're now in refinement mode
    const isRefining = stage === 'analyze' && state.results.rewrite !== null;

    return {
        ...state,
        currentStage: null,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'complete' as StageStatus,
        },
        results: {
            ...state.results,
            [stage]: stageResult,
        },
        isRefining,
    };
}

/**
 * Mark a stage as failed (resets to pending)
 */
export function failStage(state: PipelineState, stage: StageName, _error: string): PipelineState {
    debugLog('state', 'Stage failed', { stage, error: _error });

    return {
        ...state,
        currentStage: null,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'pending' as StageStatus,
        },
    };
}

/**
 * Skip a stage
 */
export function skipStage(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage skipped', { stage });

    return {
        ...state,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'skipped' as StageStatus,
        },
    };
}

/**
 * Lock a stage result (user accepted it)
 */
export function lockStageResult(state: PipelineState, stage: StageName): PipelineState {
    const result = state.results[stage];
    if (!result) return state;

    debugLog('state', 'Stage locked', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: {
                ...result,
                locked: true,
            },
        },
    };
}

/**
 * Unlock a stage result (user wants to regenerate)
 */
export function unlockStageResult(state: PipelineState, stage: StageName): PipelineState {
    const result = state.results[stage];
    if (!result) return state;

    debugLog('state', 'Stage unlocked', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: {
                ...result,
                locked: false,
            },
        },
    };
}

/**
 * Clear a stage result (for regeneration)
 */
export function clearStageResult(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage result cleared', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: null,
        },
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'pending' as StageStatus,
        },
    };
}

// ============================================================================
// ITERATION SYSTEM
// ============================================================================

/**
 * Extract verdict from analysis response
 */
export function extractVerdict(analysisResponse: string): IterationVerdict {
    const upper = analysisResponse.toUpperCase();

    // Check for explicit verdict markers
    if (upper.includes('VERDICT') || upper.includes('"VERDICT"')) {
        if (upper.includes('ACCEPT') && !upper.includes('NEEDS')) {
            return 'accept';
        }
        if (upper.includes('REGRESSION')) {
            return 'regression';
        }
        if (upper.includes('NEEDS_REFINEMENT') || upper.includes('NEEDS REFINEMENT')) {
            return 'needs_refinement';
        }
    }

    // Fallback heuristics
    if (upper.includes('READY TO USE') || upper.includes('NO MORE ITERATIONS')) {
        return 'accept';
    }
    if (upper.includes('WORSE THAN') || upper.includes('STEP BACKWARD') || upper.includes('LOST MORE')) {
        return 'regression';
    }

    // Default to needs refinement if we have any issues mentioned
    if (upper.includes('ISSUE') || upper.includes('PROBLEM') || upper.includes('SHOULD FIX')) {
        return 'needs_refinement';
    }

    return 'needs_refinement';
}

/**
 * Create a snapshot of the current iteration before refining
 */
export function createIterationSnapshot(state: PipelineState): IterationSnapshot | null {
    if (!state.results.rewrite || !state.results.analyze) {
        return null;
    }

    const verdict = extractVerdict(state.results.analyze.response);

    return {
        iteration: state.iterationCount,
        rewriteResponse: state.results.rewrite.response,
        rewritePreview: state.results.rewrite.response.substring(0, 200),
        analysisResponse: state.results.analyze.response,
        analysisPreview: state.results.analyze.response.substring(0, 200),
        verdict,
        timestamp: Date.now(),
    };
}

/**
 * Start a refinement iteration
 * - Snapshots current state
 * - Clears analyze result
 * - Increments iteration count
 */
export function startRefinement(state: PipelineState): PipelineState {
    const snapshot = createIterationSnapshot(state);

    if (!snapshot) {
        logError('Cannot start refinement - missing rewrite or analyze', null);
        return state;
    }

    // Add snapshot to history, trim if needed
    const newHistory = [...state.iterationHistory, snapshot];
    if (newHistory.length > MAX_ITERATION_HISTORY) {
        newHistory.shift();
    }

    debugLog('state', 'Starting refinement iteration', {
        iteration: state.iterationCount + 1,
        previousVerdict: snapshot.verdict,
    });

    return {
        ...state,
        iterationHistory: newHistory,
        iterationCount: state.iterationCount + 1,
        // Clear analyze so user must re-analyze after refinement
        results: {
            ...state.results,
            analyze: null,
        },
        stageStatus: {
            ...state.stageStatus,
            analyze: 'pending',
        },
        isRefining: true,
    };
}

/**
 * Complete a refinement (new rewrite generated)
 * The refinement result replaces the current rewrite
 */
export function completeRefinement(
    state: PipelineState,
    refinedRewrite: Omit<StageResult, 'timestamp' | 'locked'>,
): PipelineState {
    const stageResult: StageResult = {
        ...refinedRewrite,
        timestamp: Date.now(),
        locked: false,
    };

    debugLog('state', 'Refinement completed', {
        iteration: state.iterationCount,
        responseLength: refinedRewrite.response.length,
    });

    return {
        ...state,
        currentStage: null,
        results: {
            ...state.results,
            rewrite: stageResult,
            // analyze stays null - user must run it
        },
        stageStatus: {
            ...state.stageStatus,
            rewrite: 'complete',
            analyze: 'pending',
        },
    };
}

/**
 * Revert to a previous iteration
 */
export function revertToIteration(state: PipelineState, iterationIndex: number): PipelineState {
    if (iterationIndex < 0 || iterationIndex >= state.iterationHistory.length) {
        logError('Invalid iteration index', { iterationIndex, historyLength: state.iterationHistory.length });
        return state;
    }

    const snapshot = state.iterationHistory[iterationIndex];

    debugLog('state', 'Reverting to iteration', { iteration: snapshot.iteration });

    // Restore the rewrite from that iteration
    const restoredRewrite: StageResult = {
        response: snapshot.rewriteResponse,
        isStructured: false,
        promptUsed: '[Restored from iteration history]',
        schemaUsed: null,
        timestamp: Date.now(),
        locked: false,
    };

    // Trim history to that point
    const trimmedHistory = state.iterationHistory.slice(0, iterationIndex);

    return {
        ...state,
        results: {
            ...state.results,
            rewrite: restoredRewrite,
            analyze: null,
        },
        stageStatus: {
            ...state.stageStatus,
            rewrite: 'complete',
            analyze: 'pending',
        },
        iterationCount: snapshot.iteration,
        iterationHistory: trimmedHistory,
        isRefining: true,
    };
}

/**
 * Accept current rewrite as final (exit refinement loop)
 */
export function acceptRewrite(state: PipelineState): PipelineState {
    if (!state.results.rewrite) {
        return state;
    }

    debugLog('state', 'Rewrite accepted as final', { iteration: state.iterationCount });

    return {
        ...state,
        results: {
            ...state.results,
            rewrite: {
                ...state.results.rewrite,
                locked: true,
            },
        },
        isRefining: false,
    };
}

// ============================================================================
// REWRITE PARSING
// ============================================================================

/**
 * Parse a rewrite response into field key/value pairs.
 * Supports multiple formats with fallback chain:
 * 1. JSON object with field keys
 * 2. Markdown headers (### Field Name)
 * 3. Heuristic field detection
 * 4. Raw content as single field
 */
export function parseRewriteResponse(response: string): ParsedRewrite {
    // Try JSON first
    const jsonResult = tryParseAsJson(response);
    if (jsonResult) {
        return jsonResult;
    }

    // Try markdown headers
    const markdownResult = tryParseAsMarkdown(response);
    if (markdownResult) {
        return markdownResult;
    }

    // Try heuristic detection
    const heuristicResult = tryParseWithHeuristics(response);
    if (heuristicResult) {
        return heuristicResult;
    }

    // Fallback: return raw content
    return {
        fields: [{
            key: 'content',
            label: 'Content',
            value: response.trim(),
        }],
        raw: response,
        parseMethod: 'raw',
    };
}

function tryParseAsJson(response: string): ParsedRewrite | null {
    try {
        // Try direct parse
        let parsed: Record<string, unknown>;
        try {
            parsed = JSON.parse(response);
        } catch {
            // Try extracting from code block
            const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (!codeBlockMatch) return null;
            parsed = JSON.parse(codeBlockMatch[1].trim());
        }

        if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
            return null;
        }

        const fields: ParsedRewriteField[] = [];

        for (const [key, value] of Object.entries(parsed)) {
            if (typeof value === 'string' && value.trim()) {
                const fieldDef = CHARACTER_FIELDS.find(f =>
                    f.key === key || f.label.toLowerCase() === key.toLowerCase(),
                );

                fields.push({
                    key: fieldDef?.key || key,
                    label: fieldDef?.label || formatFieldLabel(key),
                    value: value.trim(),
                });
            }
        }

        if (fields.length === 0) return null;

        return {
            fields,
            raw: response,
            parseMethod: 'json',
        };
    } catch {
        return null;
    }
}

function tryParseAsMarkdown(response: string): ParsedRewrite | null {
    // Match ### Header or ## Header patterns
    const headerPattern = /^#{2,3}\s+(.+?)$/gm;
    const matches = [...response.matchAll(headerPattern)];

    if (matches.length === 0) return null;

    const fields: ParsedRewriteField[] = [];

    for (let i = 0; i < matches.length; i++) {
        const match = matches[i];
        const headerText = match[1].trim();
        const startIndex = match.index! + match[0].length;
        const endIndex = matches[i + 1]?.index ?? response.length;
        const content = response.slice(startIndex, endIndex).trim();

        if (!content) continue;

        // Try to match header to known field
        const fieldDef = CHARACTER_FIELDS.find(f =>
            f.label.toLowerCase() === headerText.toLowerCase() ||
            f.key === headerText.toLowerCase().replace(/\s+/g, '_'),
        );

        // Skip non-character fields like "Summary" or "Notes"
        const skipHeaders = ['summary', 'notes', 'changes', 'revised', 'original'];
        if (!fieldDef && skipHeaders.some(s => headerText.toLowerCase().includes(s))) {
            continue;
        }

        fields.push({
            key: fieldDef?.key || headerText.toLowerCase().replace(/\s+/g, '_'),
            label: fieldDef?.label || headerText,
            value: content,
        });
    }

    if (fields.length === 0) return null;

    return {
        fields,
        raw: response,
        parseMethod: 'markdown',
    };
}

function tryParseWithHeuristics(response: string): ParsedRewrite | null {
    const fields: ParsedRewriteField[] = [];

    // Look for patterns like "Description:" or "**Description:**"
    for (const fieldDef of CHARACTER_FIELDS) {
        const patterns = [
            new RegExp(`\\*\\*${fieldDef.label}:\\*\\*\\s*([\\s\\S]*?)(?=\\*\\*[A-Z]|$)`, 'i'),
            new RegExp(`${fieldDef.label}:\\s*([\\s\\S]*?)(?=\\n[A-Z][a-z]+:|$)`, 'i'),
            new RegExp(`\\[${fieldDef.label}\\]\\s*([\\s\\S]*?)(?=\\[[A-Z]|$)`, 'i'),
        ];

        for (const pattern of patterns) {
            const match = response.match(pattern);
            if (match && match[1].trim()) {
                fields.push({
                    key: fieldDef.key,
                    label: fieldDef.label,
                    value: match[1].trim(),
                });
                break;
            }
        }
    }

    if (fields.length === 0) return null;

    return {
        fields,
        raw: response,
        parseMethod: 'heuristic',
    };
}

function formatFieldLabel(key: string): string {
    return key
        .replace(/_/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/\b\w/g, c => c.toUpperCase());
}

// ============================================================================
// APPLY REWRITE TO CHARACTER
// ============================================================================

/**
 * Apply parsed rewrite fields to a character.
 * Returns the updated character data or null on failure.
 */
export async function applyRewriteToCharacter(
    state: PipelineState,
    parsedFields: ParsedRewriteField[],
): Promise<{ success: boolean; error?: string; updatedFields: string[] }> {
    if (!state.character || state.characterIndex === null) {
        return { success: false, error: 'No character selected', updatedFields: [] };
    }

    const { characters, unshallowCharacter, getRequestHeaders } = SillyTavern.getContext();

    try {
        // Ensure character data is fully loaded
        await unshallowCharacter(state.characterIndex);

        // Get fresh character reference after unshallow
        const charList = characters as Character[];
        const character = charList[state.characterIndex];

        if (!character) {
            return { success: false, error: 'Character not found after unshallow', updatedFields: [] };
        }

        // Build update object
        const updates: Partial<Character> = {};
        const updatedFields: string[] = [];

        for (const field of parsedFields) {
            // Only update known character fields
            const fieldDef = CHARACTER_FIELDS.find(f => f.key === field.key);
            if (fieldDef && field.value.trim()) {
                (updates as Record<string, string>)[field.key] = field.value.trim();
                updatedFields.push(field.label);
            }
        }

        if (updatedFields.length === 0) {
            return { success: false, error: 'No valid fields to update', updatedFields: [] };
        }

        // Apply updates to character object
        Object.assign(character, updates);

        // Save to server
        const saveResponse = await fetch('/api/characters/edit', {
            method: 'POST',
            headers: getRequestHeaders(),
            body: JSON.stringify({
                avatar_url: character.avatar,
                ...character,
            }),
        });

        if (!saveResponse.ok) {
            const errorText = await saveResponse.text();
            logError('Failed to save character', { status: saveResponse.status, error: errorText });
            return { success: false, error: `Save failed: ${saveResponse.status}`, updatedFields: [] };
        }

        debugLog('info', 'Character updated successfully', {
            name: character.name,
            updatedFields,
        });

        return { success: true, updatedFields };
    } catch (e) {
        logError('Error applying rewrite to character', e);
        return { success: false, error: (e as Error).message, updatedFields: [] };
    }
}

// ============================================================================
// PIPELINE NAVIGATION
// ============================================================================

/**
 * Get the next stage in the selected pipeline
 */
export function getNextStage(state: PipelineState, currentStage: StageName): StageName | null {
    const currentIndex = state.selectedStages.indexOf(currentStage);
    if (currentIndex === -1 || currentIndex >= state.selectedStages.length - 1) {
        return null;
    }
    return state.selectedStages[currentIndex + 1];
}

/**
 * Get the previous stage in the selected pipeline
 */
export function getPreviousStage(state: PipelineState, currentStage: StageName): StageName | null {
    const currentIndex = state.selectedStages.indexOf(currentStage);
    if (currentIndex <= 0) {
        return null;
    }
    return state.selectedStages[currentIndex - 1];
}

/**
 * Get the first incomplete stage in the pipeline
 */
export function getFirstIncompleteStage(state: PipelineState): StageName | null {
    for (const stage of state.selectedStages) {
        const status = state.stageStatus[stage];
        if (status === 'pending' || status === 'running') {
            return stage;
        }
    }
    return null;
}

/**
 * Check if all selected stages are complete
 */
export function isPipelineComplete(state: PipelineState): boolean {
    return state.selectedStages.every(stage => {
        const status = state.stageStatus[stage];
        return status === 'complete' || status === 'skipped';
    });
}

/**
 * Check if pipeline is ready for export
 */
export function canExport(state: PipelineState): boolean {
    // Need at least rewrite results to export
    return !!state.results.rewrite;
}

// ============================================================================
// PROMPT BUILDING
// ============================================================================

/**
 * Build the complete prompt for a stage, including template substitution.
 * If no placeholders are detected, prepends character data automatically.
 */
export function buildStagePrompt(state: PipelineState, stage: StageName): string | null {
    if (!state.character) {
        return null;
    }

    const config = state.configs[stage];
    const basePrompt = resolvePrompt(config);

    if (!basePrompt.trim()) {
        return null;
    }

    // Build character summary
    const characterSummary = buildCharacterSummary(state.character);

    // Build template context with all available data
    const { name1 } = SillyTavern.getContext();

    const context = {
        originalCharacter: characterSummary,
        scoreResults: state.results.score?.response || '',
        rewriteResults: state.results.rewrite?.response || '',
        currentRewrite: state.results.rewrite?.response || '',
        currentAnalysis: state.results.analyze?.response || '',
        iterationNumber: String(state.iterationCount + 1),
        charName: state.character.name,
        userName: name1 || 'User',
    };

    // Check which placeholders are used in the prompt
    const foundPlaceholders = promptHasPlaceholders(basePrompt);
    const hasAnyPlaceholder = foundPlaceholders.length > 0;

    // Process template placeholders in the prompt
    const processedPrompt = processPromptTemplate(basePrompt, context);

    // If prompt has placeholders, trust that user knows what they're doing
    if (hasAnyPlaceholder) {
        // But still check if critical data is missing
        const usesCharacterPlaceholder = foundPlaceholders.includes('ORIGINAL_CHARACTER');

        // If they use character placeholder, just return processed prompt
        if (usesCharacterPlaceholder) {
            return processedPrompt;
        }

        // If they use other placeholders but not character, prepend character data
        return buildStructuredPrompt(stage, state, characterSummary, processedPrompt);
    }

    // No placeholders detected - prepend all relevant data automatically
    debugLog('info', 'No placeholders in prompt, auto-prepending character data', { stage });
    return buildStructuredPrompt(stage, state, characterSummary, processedPrompt);
}

/**
 * Build the refinement prompt
 */
export function buildRefinementPrompt(state: PipelineState): string | null {
    if (!state.character || !state.results.rewrite || !state.results.analyze) {
        return null;
    }

    const settings = getSettings();
    const basePrompt = settings.refinementPrompt;

    const characterSummary = buildCharacterSummary(state.character);
    const { name1 } = SillyTavern.getContext();

    const context = {
        originalCharacter: characterSummary,
        scoreResults: state.results.score?.response || '',
        rewriteResults: state.results.rewrite.response,
        currentRewrite: state.results.rewrite.response,
        currentAnalysis: state.results.analyze.response,
        iterationNumber: String(state.iterationCount + 1),
        charName: state.character.name,
        userName: name1 || 'User',
    };

    return processPromptTemplate(basePrompt, context);
}

/**
 * Build a structured prompt with all relevant data prepended
 */
function buildStructuredPrompt(
    stage: StageName,
    state: PipelineState,
    characterSummary: string,
    instructions: string,
): string {
    const parts: string[] = [];

    // Always include character
    const stageAction = stage === 'score' ? 'Analyze' : stage === 'rewrite' ? 'Rewrite' : 'Compare';
    parts.push(`# Character to ${stageAction}`, '', characterSummary);

    // Stage-specific data
    switch (stage) {
        case 'score':
            // Score only needs character - already added above
            break;

        case 'rewrite':
            // Include score results if available
            if (state.results.score?.response) {
                parts.push('', '---', '', '# Score Feedback', '', 'Use this feedback to guide your rewrite:', '', state.results.score.response);
            }
            break;

        case 'analyze':
            // Include rewrite results
            if (state.results.rewrite?.response) {
                parts.push('', '---', '', '# Rewritten Version', '', 'Compare this against the original:', '', state.results.rewrite.response);
            }

            // Include score results if available
            if (state.results.score?.response) {
                parts.push('', '---', '', '# Original Score Feedback', '', 'Reference for what was identified as needing improvement:', '', state.results.score.response);
            }
            break;
    }

    // Add the instructions/prompt
    parts.push('', '---', '', '# Instructions', '', instructions);

    return parts.join('\n');
}

/**
 * Get the schema for a stage (if structured output is enabled)
 */
export function getStageSchema(state: PipelineState, stage: StageName): StructuredOutputSchema | null {
    const config = state.configs[stage];
    return resolveSchema(config);
}

// ============================================================================
// EXPORT
// ============================================================================

/**
 * Generate export data from rewrite results
 */
export function generateExportData(state: PipelineState): string | null {
    if (!state.results.rewrite || !state.character) {
        return null;
    }

    const rewriteResponse = state.results.rewrite.response;

    const exportLines = [
        `# ${state.character.name} (Rewritten)`,
        '',
        `Generated: ${new Date().toLocaleString()}`,
        `Iterations: ${state.iterationCount}`,
        '',
        '---',
        '',
        rewriteResponse,
    ];

    // If we have analyze results, include them as notes
    if (state.results.analyze) {
        exportLines.push(
            '',
            '---',
            '',
            '## Final Analysis',
            '',
            state.results.analyze.response,
        );
    }

    // If we have score results, include summary
    if (state.results.score) {
        exportLines.push(
            '',
            '---',
            '',
            '## Original Score',
            '',
            state.results.score.response,
        );
    }

    // Include iteration history summary if we have any
    if (state.iterationHistory.length > 0) {
        exportLines.push(
            '',
            '---',
            '',
            '## Iteration History',
            '',
        );

        for (const snap of state.iterationHistory) {
            exportLines.push(
                `### Iteration ${snap.iteration + 1} - ${snap.verdict.toUpperCase()}`,
                `${new Date(snap.timestamp).toLocaleString()}`,
                '',
            );
        }
    }

    return exportLines.join('\n');
}

/**
 * Set export data in state
 */
export function setExportData(state: PipelineState): PipelineState {
    const exportData = generateExportData(state);

    return {
        ...state,
        exportData,
    };
}

// ============================================================================
// STATE QUERIES
// ============================================================================

/**
 * Get a summary of pipeline state for debugging/display
 */
export function getPipelineSummary(state: PipelineState): {
    hasCharacter: boolean;
    characterName: string | null;
    selectedStages: StageName[];
    stageStatuses: Record<StageName, StageStatus>;
    completedStages: StageName[];
    lockedStages: StageName[];
    currentStage: StageName | null;
    canExport: boolean;
    isComplete: boolean;
    iterationCount: number;
    isRefining: boolean;
    lastVerdict: IterationVerdict | null;
} {
    const completedStages = STAGES.filter(s => state.stageStatus[s] === 'complete');
    const lockedStages = STAGES.filter(s => state.results[s]?.locked);

    const lastSnapshot = state.iterationHistory.length > 0
        ? state.iterationHistory[state.iterationHistory.length - 1]
        : null;

    return {
        hasCharacter: !!state.character,
        characterName: state.character?.name || null,
        selectedStages: state.selectedStages,
        stageStatuses: { ...state.stageStatus },
        completedStages,
        lockedStages,
        currentStage: state.currentStage,
        canExport: canExport(state),
        isComplete: isPipelineComplete(state),
        iterationCount: state.iterationCount,
        isRefining: state.isRefining,
        lastVerdict: lastSnapshot?.verdict || null,
    };
}

/**
 * Check if a specific stage has results (complete or not)
 */
export function hasStageResult(state: PipelineState, stage: StageName): boolean {
    return !!state.results[stage];
}

/**
 * Check if a specific stage result is locked
 */
export function isStageResultLocked(state: PipelineState, stage: StageName): boolean {
    return !!state.results[stage]?.locked;
}

/**
 * Get stage result if available
 */
export function getStageResult(state: PipelineState, stage: StageName): StageResult | null {
    return state.results[stage];
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Validate pipeline state before running
 */
export interface PipelineValidation {
    valid: boolean;
    errors: string[];
    warnings: string[];
}

export function validatePipeline(state: PipelineState): PipelineValidation {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Must have character
    if (!state.character) {
        errors.push('No character selected');
    }

    // Must have at least one stage selected
    if (state.selectedStages.length === 0) {
        errors.push('No stages selected');
    }

    // Check each selected stage
    for (const stage of state.selectedStages) {
        const config = state.configs[stage];
        const prompt = resolvePrompt(config);

        if (!prompt.trim()) {
            errors.push(`${stage}: No prompt configured`);
        }

        // Warn about missing dependencies (but don't error - we auto-include now)
        if (stage === 'rewrite' && !state.results.score && state.selectedStages.includes('score')) {
            warnings.push('Rewrite will run without score feedback (score not complete)');
        }

        if (stage === 'analyze' && !state.results.rewrite) {
            errors.push('Analyze requires rewrite results');
        }
    }

    // Check API readiness
    const { onlineStatus } = SillyTavern.getContext();
    if (onlineStatus !== 'Valid' && onlineStatus !== 'Connected') {
        errors.push('API is not connected');
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

/**
 * Validate refinement before running
 */
export function validateRefinement(state: PipelineState): PipelineValidation {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!state.character) {
        errors.push('No character selected');
    }

    if (!state.results.rewrite) {
        errors.push('No rewrite to refine');
    }

    if (!state.results.analyze) {
        errors.push('Run analyze first to identify issues');
    }

    // Check API readiness
    const { onlineStatus } = SillyTavern.getContext();
    if (onlineStatus !== 'Valid' && onlineStatus !== 'Connected') {
        errors.push('API is not connected');
    }

    // Warn if last verdict was accept
    const lastSnapshot = state.iterationHistory.length > 0
        ? state.iterationHistory[state.iterationHistory.length - 1]
        : null;

    if (lastSnapshot?.verdict === 'accept') {
        warnings.push('Last analysis suggested accepting the rewrite');
    }

    if (state.iterationCount >= 5) {
        warnings.push(`Already at iteration ${state.iterationCount + 1} - consider accepting or starting fresh`);
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

// ============================================================================
// SERIALIZATION (for potential future persistence)
// ============================================================================

/**
 * Serialize pipeline state to JSON-safe object
 */
export function serializePipelineState(state: PipelineState): Record<string, unknown> {
    return {
        characterIndex: state.characterIndex,
        results: state.results,
        configs: state.configs,
        selectedStages: state.selectedStages,
        stageStatus: state.stageStatus,
        iterationCount: state.iterationCount,
        iterationHistory: state.iterationHistory,
        isRefining: state.isRefining,
        exportData: state.exportData,
        // Don't serialize character - will be re-fetched by index
    };
}

/**
 * Deserialize pipeline state (would need character list to restore character)
 */
export function deserializePipelineState(
    data: Record<string, unknown>,
    characters: Character[],
): PipelineState | null {
    try {
        const characterIndex = data.characterIndex as number | null;
        const character = characterIndex !== null ? characters[characterIndex] : null;

        return {
            character,
            characterIndex,
            results: data.results as PipelineState['results'],
            configs: data.configs as PipelineState['configs'],
            selectedStages: data.selectedStages as StageName[],
            currentStage: null,  // Always reset to null on restore
            stageStatus: data.stageStatus as Record<StageName, StageStatus>,
            iterationCount: (data.iterationCount as number) || 0,
            iterationHistory: (data.iterationHistory as IterationSnapshot[]) || [],
            isRefining: (data.isRefining as boolean) || false,
            exportData: data.exportData as string | null,
        };
    } catch (e) {
        logError('Failed to deserialize pipeline state', e);
        return null;
    }
}
```

## FILE: src/presets.ts
```ts
// src/presets.ts
//
// This module provides higher-level preset operations and utilities.
// Basic CRUD is in settings.ts; this handles resolution, validation, and UI helpers.

import type {
    StageName,
    StageConfig,
    PromptPreset,
    SchemaPreset,
    StructuredOutputSchema,
} from './types';
import {
    getSettings,
    getPromptPreset,
    getSchemaPreset,
    getPromptPresets,
    getSchemaPresets,
} from './settings';
import { validateSchema, formatSchema } from './schema';
import { TEMPLATE_PLACEHOLDERS } from './constants';
import { debugLog } from './debug';

// ============================================================================
// STAGE CONFIG RESOLUTION
// ============================================================================

/**
 * Get the effective stage config, resolving presets to actual values.
 * Returns a StageConfig with resolved prompt and schema.
 */
export function getStageConfig(stage: StageName): StageConfig {
    const settings = getSettings();
    const defaults = settings.stageDefaults[stage];

    return {
        promptPresetId: defaults.promptPresetId,
        customPrompt: defaults.customPrompt,
        schemaPresetId: defaults.schemaPresetId,
        customSchema: defaults.customSchema,
        useStructuredOutput: defaults.useStructuredOutput,
    };
}

/**
 * Resolve a stage config to get the actual prompt text.
 * If a preset is selected, returns the preset's prompt.
 * Otherwise returns the custom prompt.
 */
export function resolvePrompt(config: StageConfig): string {
    if (config.promptPresetId) {
        const preset = getPromptPreset(config.promptPresetId);
        if (preset) {
            return preset.prompt;
        }
        debugLog('error', 'Prompt preset not found', { id: config.promptPresetId });
    }

    return config.customPrompt;
}

/**
 * Resolve a stage config to get the actual schema.
 * Returns null if structured output is disabled or no schema is configured.
 */
export function resolveSchema(config: StageConfig): StructuredOutputSchema | null {
    if (!config.useStructuredOutput) {
        return null;
    }

    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) {
            return preset.schema;
        }
        debugLog('error', 'Schema preset not found', { id: config.schemaPresetId });
    }

    // Try to parse custom schema
    if (config.customSchema) {
        const result = validateSchema(config.customSchema);
        if (result.valid && result.schema) {
            return result.schema;
        }
        debugLog('error', 'Custom schema invalid', { error: result.error });
    }

    return null;
}

/**
 * Create a fresh StageConfig from defaults
 */
export function createStageConfigFromDefaults(stage: StageName): StageConfig {
    const settings = getSettings();
    const defaults = settings.stageDefaults[stage];

    return {
        promptPresetId: defaults.promptPresetId,
        customPrompt: defaults.customPrompt,
        schemaPresetId: defaults.schemaPresetId,
        customSchema: defaults.customSchema,
        useStructuredOutput: defaults.useStructuredOutput,
    };
}

// ============================================================================
// PROMPT TEMPLATE PROCESSING
// ============================================================================

export interface TemplateContext {
    originalCharacter?: string;
    scoreResults?: string;
    rewriteResults?: string;
    currentRewrite?: string;
    currentAnalysis?: string;
    iterationNumber?: string;
    charName?: string;
    userName?: string;
}

/**
 * Process a prompt template, replacing placeholders with actual values.
 *
 * Order of operations:
 * 1. Run ST's substituteParams for standard macros ({{time}}, {{date}}, etc.)
 * 2. Replace our custom placeholders ({{original_character}}, {{score_results}}, etc.)
 * 3. Replace {{char}} and {{user}} with our specific character/user names
 *    (This overrides ST's substitution which uses the active chat character)
 * 4. Handle conditional blocks {{#if score_results}}...{{/if}}
 */
export function processPromptTemplate(prompt: string, context: TemplateContext): string {
    const { lodash } = SillyTavern.libs;

    // First, run ST's macro substitution for standard macros
    const { substituteParams } = SillyTavern.getContext();
    let processed = substituteParams(prompt);

    // Handle conditional blocks first
    processed = processConditionalBlocks(processed, context);

    // Now replace our custom placeholders using lodash.escapeRegExp
    if (context.originalCharacter !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.ORIGINAL_CHARACTER), 'gi'),
            context.originalCharacter,
        );
    }

    if (context.scoreResults !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.SCORE_RESULTS), 'gi'),
            context.scoreResults,
        );
    }

    if (context.rewriteResults !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.REWRITE_RESULTS), 'gi'),
            context.rewriteResults,
        );
    }

    if (context.currentRewrite !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.CURRENT_REWRITE), 'gi'),
            context.currentRewrite,
        );
    }

    if (context.currentAnalysis !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.CURRENT_ANALYSIS), 'gi'),
            context.currentAnalysis,
        );
    }

    if (context.iterationNumber !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.ITERATION_NUMBER), 'gi'),
            context.iterationNumber,
        );
    }

    // Replace {{char_name}} with our specific character
    if (context.charName !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.CHARACTER_NAME), 'gi'),
            context.charName,
        );
    }

    // Replace {{user_name}} with our specific user
    if (context.userName !== undefined) {
        processed = processed.replace(
            new RegExp(lodash.escapeRegExp(TEMPLATE_PLACEHOLDERS.USER_NAME), 'gi'),
            context.userName,
        );
    }

    // IMPORTANT: Also replace {{char}} and {{user}} with our specific names
    if (context.charName !== undefined) {
        processed = processed.replace(/\{\{char\}\}/gi, context.charName);
    }

    if (context.userName !== undefined) {
        processed = processed.replace(/\{\{user\}\}/gi, context.userName);
    }

    return processed;
}

/**
 * Process conditional blocks like {{#if score_results}}...{{/if}}
 */
function processConditionalBlocks(prompt: string, context: TemplateContext): string {
    // Match {{#if variable}}...{{/if}} blocks
    const conditionalRegex = /\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/gi;

    return prompt.replace(conditionalRegex, (_match, variable, content) => {
        const varName = variable.toLowerCase();

        // Check if the variable has a truthy value
        let hasValue = false;

        switch (varName) {
            case 'score_results':
                hasValue = !!context.scoreResults?.trim();
                break;
            case 'rewrite_results':
                hasValue = !!context.rewriteResults?.trim();
                break;
            case 'current_rewrite':
                hasValue = !!context.currentRewrite?.trim();
                break;
            case 'current_analysis':
                hasValue = !!context.currentAnalysis?.trim();
                break;
            case 'original_character':
                hasValue = !!context.originalCharacter?.trim();
                break;
            case 'iteration_number':
                hasValue = !!context.iterationNumber && context.iterationNumber !== '0';
                break;
            default:
                hasValue = false;
        }

        return hasValue ? content : '';
    });
}

/**
 * Check if a prompt contains any template placeholders
 */
export function promptHasPlaceholders(prompt: string): string[] {
    const found: string[] = [];

    for (const [key, placeholder] of Object.entries(TEMPLATE_PLACEHOLDERS)) {
        if (prompt.toLowerCase().includes(placeholder.toLowerCase())) {
            found.push(key);
        }
    }

    return found;
}

/**
 * Get placeholders that are used but won't have values for a given stage
 */
export function getUnfilledPlaceholders(prompt: string, stage: StageName, hasScore: boolean, hasRewrite: boolean): string[] {
    const used = promptHasPlaceholders(prompt);
    const unfilled: string[] = [];

    for (const placeholder of used) {
        switch (placeholder) {
            case 'SCORE_RESULTS':
                if (!hasScore && stage !== 'score') {
                    unfilled.push('{{score_results}} - no score results available');
                }
                break;
            case 'REWRITE_RESULTS':
            case 'CURRENT_REWRITE':
                if (!hasRewrite && stage !== 'rewrite') {
                    unfilled.push('{{rewrite_results}} - no rewrite results available');
                }
                break;
            case 'CURRENT_ANALYSIS':
                // Only available during refinement
                unfilled.push('{{current_analysis}} - only available during refinement');
                break;
            // ORIGINAL_CHARACTER is always available if we have a character
            // CHAR_NAME and USER_NAME are always available
            // ITERATION_NUMBER is always available
        }
    }

    return unfilled;
}

// ============================================================================
// PRESET UI HELPERS
// ============================================================================

export interface PresetOption {
    id: string;
    name: string;
    isBuiltin: boolean;
    isSelected: boolean;
}

/**
 * Get prompt presets formatted for a dropdown, with selection state
 */
export function getPromptPresetOptions(stage: StageName, selectedId: string | null): PresetOption[] {
    const presets = getPromptPresets(stage);

    return presets.map(p => ({
        id: p.id,
        name: p.isBuiltin ? `${p.name} (builtin)` : p.name,
        isBuiltin: p.isBuiltin,
        isSelected: p.id === selectedId,
    }));
}

/**
 * Get schema presets formatted for a dropdown, with selection state
 */
export function getSchemaPresetOptions(stage: StageName, selectedId: string | null): PresetOption[] {
    const presets = getSchemaPresets(stage);

    return presets.map(p => ({
        id: p.id,
        name: p.isBuiltin ? `${p.name} (builtin)` : p.name,
        isBuiltin: p.isBuiltin,
        isSelected: p.id === selectedId,
    }));
}

/**
 * Get the display name for a preset (handles null/missing)
 */
export function getPresetDisplayName(type: 'prompt' | 'schema', id: string | null): string {
    if (!id) {
        return 'Custom';
    }

    const preset = type === 'prompt' ? getPromptPreset(id) : getSchemaPreset(id);
    if (!preset) {
        return 'Unknown';
    }

    return preset.name;
}

// ============================================================================
// SCHEMA HELPERS
// ============================================================================

/**
 * Get the schema JSON string for editing, either from preset or custom
 */
export function getSchemaForEditing(config: StageConfig): string {
    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) {
            return formatSchema(preset.schema);
        }
    }

    return config.customSchema;
}

/**
 * Validate a schema string and return user-friendly result
 */
export interface SchemaValidationUIResult {
    isValid: boolean;
    isEmpty: boolean;
    errorMessage: string | null;
    warnings: string[];
    info: string[];
}

export function validateSchemaForUI(schemaJson: string): SchemaValidationUIResult {
    if (!schemaJson.trim()) {
        return {
            isValid: true,
            isEmpty: true,
            errorMessage: null,
            warnings: [],
            info: ['Empty schema = structured output disabled'],
        };
    }

    const result = validateSchema(schemaJson);

    return {
        isValid: result.valid,
        isEmpty: false,
        errorMessage: result.error || null,
        warnings: result.warnings || [],
        info: result.info || [],
    };
}

// ============================================================================
// PRESET VALIDATION
// ============================================================================

/**
 * Validate a prompt preset before saving
 */
export interface PresetValidationResult {
    valid: boolean;
    errors: string[];
    warnings: string[];
}

export function validatePromptPreset(preset: Partial<PromptPreset>): PresetValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!preset.name?.trim()) {
        errors.push('Name is required');
    } else if (preset.name.length > 100) {
        errors.push('Name must be 100 characters or less');
    }

    if (!preset.prompt?.trim()) {
        errors.push('Prompt is required');
    } else if (preset.prompt.length > 50000) {
        errors.push('Prompt is too long (max 50,000 characters)');
    }

    // Check for common issues - but don't error if no placeholders
    if (preset.prompt) {
        const hasDoubleBraces = preset.prompt.includes('{{');
        const foundPlaceholders = promptHasPlaceholders(preset.prompt);

        if (hasDoubleBraces && foundPlaceholders.length === 0) {
            // Has {{ but no recognized placeholders - might be intentional (custom macros)
            debugLog('info', 'Prompt has {{ but no recognized placeholders', {
                promptPreview: preset.prompt.substring(0, 100),
            });
        }
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

/**
 * Validate a schema preset before saving
 */
export function validateSchemaPreset(preset: Partial<SchemaPreset>): PresetValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!preset.name?.trim()) {
        errors.push('Name is required');
    } else if (preset.name.length > 100) {
        errors.push('Name must be 100 characters or less');
    }

    if (!preset.schema) {
        errors.push('Schema is required');
    } else {
        const schemaJson = typeof preset.schema === 'string'
            ? preset.schema
            : JSON.stringify(preset.schema);

        const result = validateSchema(schemaJson);
        if (!result.valid) {
            errors.push(result.error || 'Invalid schema');
        }
        if (result.warnings) {
            warnings.push(...result.warnings);
        }
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Check if a preset name is unique (for validation)
 */
export function isPresetNameUnique(type: 'prompt' | 'schema', name: string, excludeId?: string): boolean {
    const presets = type === 'prompt' ? getPromptPresets() : getSchemaPresets();

    return !presets.some(p =>
        p.name.toLowerCase() === name.toLowerCase() && p.id !== excludeId,
    );
}

/**
 * Generate a unique preset name by appending a number if needed
 */
export function generateUniquePresetName(type: 'prompt' | 'schema', baseName: string): string {
    let name = baseName;
    let counter = 1;

    while (!isPresetNameUnique(type, name)) {
        name = `${baseName} (${counter})`;
        counter++;
    }

    return name;
}
```

## FILE: src/persistence.ts
```ts
// src/persistence.ts
//
// Persistence layer for iteration history using localforage.
// Stores iteration history per-character so users can resume work across sessions.

import { MODULE_NAME } from './constants';
import { debugLog, logError } from './debug';
import type { Character, IterationSnapshot } from './types';

// ============================================================================
// KEY GENERATION
// ============================================================================

/**
 * Generate a unique key for a character.
 * Uses avatar + name since avatar alone isn't unique.
 */
export function getCharacterKey(character: Character): string {
    // Sanitize for storage key - remove special chars
    const sanitizedName = character.name.replace(/[^a-zA-Z0-9_-]/g, '_');
    const sanitizedAvatar = character.avatar.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `${MODULE_NAME}_history_${sanitizedAvatar}_${sanitizedName}`;
}

// ============================================================================
// ITERATION HISTORY PERSISTENCE
// ============================================================================

/**
 * Save iteration history for a character
 */
export async function saveIterationHistory(
    character: Character,
    history: IterationSnapshot[],
): Promise<boolean> {
    const { localforage } = SillyTavern.libs;
    const key = getCharacterKey(character);

    try {
        await localforage.setItem(key, {
            characterName: character.name,
            characterAvatar: character.avatar,
            history,
            savedAt: Date.now(),
        });

        debugLog('info', 'Iteration history saved', {
            key,
            characterName: character.name,
            historyLength: history.length,
        });

        return true;
    } catch (e) {
        logError('Failed to save iteration history', { key, error: e });
        return false;
    }
}

/**
 * Load iteration history for a character
 */
export async function loadIterationHistory(
    character: Character,
): Promise<IterationSnapshot[] | null> {
    const { localforage } = SillyTavern.libs;
    const key = getCharacterKey(character);

    try {
        const data = await localforage.getItem(key) as {
            characterName: string;
            characterAvatar: string;
            history: IterationSnapshot[];
            savedAt: number;
        } | null;

        if (!data) {
            debugLog('info', 'No iteration history found', { key });
            return null;
        }

        // Verify it's for the same character (in case of key collision)
        if (data.characterName !== character.name || data.characterAvatar !== character.avatar) {
            debugLog('info', 'Iteration history key collision, ignoring', {
                key,
                storedName: data.characterName,
                currentName: character.name,
            });
            return null;
        }

        debugLog('info', 'Iteration history loaded', {
            key,
            characterName: character.name,
            historyLength: data.history.length,
            savedAt: new Date(data.savedAt).toISOString(),
        });

        return data.history;
    } catch (e) {
        logError('Failed to load iteration history', { key, error: e });
        return null;
    }
}

/**
 * Clear iteration history for a character
 */
export async function clearIterationHistory(character: Character): Promise<boolean> {
    const { localforage } = SillyTavern.libs;
    const key = getCharacterKey(character);

    try {
        await localforage.removeItem(key);

        debugLog('info', 'Iteration history cleared', {
            key,
            characterName: character.name,
        });

        return true;
    } catch (e) {
        logError('Failed to clear iteration history', { key, error: e });
        return false;
    }
}

/**
 * Get all stored iteration history keys (for debugging/cleanup)
 */
export async function getAllHistoryKeys(): Promise<string[]> {
    const { localforage } = SillyTavern.libs;

    try {
        const allKeys = await localforage.keys();
        return allKeys.filter((key: string) => key.startsWith(`${MODULE_NAME}_history_`));
    } catch (e) {
        logError('Failed to get history keys', { error: e });
        return [];
    }
}

/**
 * Clear all iteration history (for debugging/cleanup)
 */
export async function clearAllIterationHistory(): Promise<number> {
    const keys = await getAllHistoryKeys();
    const { localforage } = SillyTavern.libs;

    let cleared = 0;
    for (const key of keys) {
        try {
            await localforage.removeItem(key);
            cleared++;
        } catch (e) {
            logError('Failed to clear history key', { key, error: e });
        }
    }

    debugLog('info', 'All iteration history cleared', { cleared, total: keys.length });
    return cleared;
}
```

## FILE: src/ui/formatter.ts
```ts
// src/ui/formatter.ts
//
// Response formatting for display

import type { StructuredOutputSchema, JsonSchemaValue } from '../types';

// ============================================================================
// MAIN ENTRY POINTS
// ============================================================================

/**
 * Format a plain text/markdown response
 */
export function formatResponse(response: string, moduleName: string): string {
    const { showdown, DOMPurify } = SillyTavern.libs;
    const text = typeof response === 'string' ? response : String(response ?? '');

    const converter = new showdown.Converter({
        tables: true,
        strikethrough: true,
        simpleLineBreaks: false,
        headerLevelStart: 1,
        ghCodeBlocks: true,
        tasklists: true,
        openLinksInNewWindow: true,
        emoji: true,
        parseImgDimensions: true,
        simplifiedAutoLink: true,
    });

    const html = converter.makeHtml(text);
    const wrapped = `<div class="${moduleName}_markdown_content">${html}</div>`;

    return DOMPurify.sanitize(wrapped);
}

/**
 * Format a structured JSON response
 */
export function formatStructuredResponse(
    response: string,
    schema: StructuredOutputSchema | null,
    moduleName: string,
): string {
    const { DOMPurify } = SillyTavern.libs;
    const text = typeof response === 'string' ? response : String(response ?? '');

    const parsed = parseStructuredResponse(text);

    if (!parsed || typeof parsed !== 'object') {
        return formatResponse(text, moduleName);
    }

    const schemaValue = schema?.value ?? inferSchema(parsed);
    const html = renderStructuredRoot(parsed as Record<string, unknown>, schemaValue, moduleName);

    return DOMPurify.sanitize(html);
}

/**
 * Parse a structured response (handles JSON and code blocks)
 */
export function parseStructuredResponse(response: string): unknown | null {
    try {
        return JSON.parse(response);
    } catch {
        // Try to extract JSON from markdown code blocks
        const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlockMatch) {
            try {
                return JSON.parse(codeBlockMatch[1].trim());
            } catch {
                return null;
            }
        }
        return null;
    }
}

// ============================================================================
// SCHEMA INFERENCE
// ============================================================================

function inferSchema(data: unknown): JsonSchemaValue {
    if (data === null) return { type: 'null' };
    if (Array.isArray(data)) {
        return {
            type: 'array',
            items: data.length > 0 ? inferSchema(data[0]) : { type: 'string' },
        };
    }
    if (typeof data === 'object') {
        const properties: Record<string, JsonSchemaValue> = {};
        for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
            properties[key] = inferSchema(value);
        }
        return { type: 'object', properties };
    }
    return { type: typeof data as 'string' | 'number' | 'boolean' };
}

// ============================================================================
// STRUCTURED RENDERING
// ============================================================================

const MAX_DEPTH = 8;

function renderStructuredRoot(
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
): string {
    const heroKey = findHeroKey(data);
    const heroValue = heroKey ? data[heroKey] : null;

    const sections: string[] = [];

    // Hero score at top
    if (heroKey && typeof heroValue === 'number') {
        sections.push(renderHero(heroKey, heroValue, moduleName));
    }

    // Render all fields
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    for (const key of keys) {
        if (key === heroKey) continue;
        const value = data[key];
        if (value === undefined) continue;

        const propSchema = properties[key] || { type: inferType(value) };
        sections.push(renderField(key, value, propSchema as JsonSchemaValue, moduleName, 0));
    }

    return `<div class="${moduleName}_structured_content">${sections.join('')}</div>`;
}

function renderHero(key: string, value: number, moduleName: string): string {
    const label = formatLabel(key);
    const color = getScoreColor(value > 10 ? value / 10 : value);
    const display = Number.isInteger(value) ? value : value.toFixed(1);
    const max = value > 10 ? 100 : 10;

    return `
    <div class="${moduleName}_hero">
      <div class="${moduleName}_hero_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_hero_value" style="color: ${color}">
        ${display}<span class="${moduleName}_hero_max">/${max}</span>
      </div>
    </div>
  `;
}

function renderField(
    key: string,
    value: unknown,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    if (depth > MAX_DEPTH) {
        return renderJson(value, moduleName);
    }

    const label = formatLabel(key);
    const type = schema.type || inferType(value);

    if (type === 'array' && Array.isArray(value)) {
        return renderArrayField(label, value, schema, moduleName, depth);
    }

    if (type === 'object' && typeof value === 'object' && value !== null) {
        return renderObjectField(label, value as Record<string, unknown>, schema, moduleName, depth);
    }

    const rendered = renderValue(value, schema, moduleName, key);

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_field_value">${rendered}</div>
    </div>
  `;
}

function renderArrayField(
    label: string,
    items: unknown[],
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    if (items.length === 0) {
        return `
      <div class="${moduleName}_field">
        <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
        <div class="${moduleName}_field_value ${moduleName}_empty">(none)</div>
      </div>
    `;
    }

    const itemSchema = (schema.items || { type: inferType(items[0]) }) as JsonSchemaValue;

    // Simple values as list
    if (items.every(isSimpleValue)) {
        const listItems = items.map(item => `<li>${renderSimpleValue(item, moduleName)}</li>`).join('');
        return `
      <div class="${moduleName}_field">
        <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
        <ol class="${moduleName}_list">${listItems}</ol>
      </div>
    `;
    }

    // Complex values as cards
    const cards = items.map((item, index) => {
        if (typeof item === 'object' && item !== null) {
            return renderCard(item as Record<string, unknown>, itemSchema, moduleName, depth + 1, index);
        }
        return `<div class="${moduleName}_card">${renderValue(item, itemSchema, moduleName)}</div>`;
    }).join('');

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_cards">${cards}</div>
    </div>
  `;
}

function renderCard(
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
    _index: number,
): string {
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    // Find title, score, and body fields
    const titleKey = keys.find(k => typeof data[k] === 'string' && (data[k] as string).length < 100);
    const scoreKey = keys.find(k => typeof data[k] === 'number' && ((data[k] as number) >= 0 && (data[k] as number) <= 100));
    const bodyKey = keys.find(k => typeof data[k] === 'string' && (data[k] as string).length >= 50 && k !== titleKey);

    let header = '';
    if (titleKey || scoreKey) {
        const titlePart = titleKey
            ? `<span class="${moduleName}_card_title">${escapeHtml(String(data[titleKey]))}</span>`
            : '';
        const scorePart = scoreKey
            ? renderScore(data[scoreKey] as number, moduleName)
            : '';
        header = `<div class="${moduleName}_card_header">${titlePart}${scorePart}</div>`;
    }

    let body = '';
    if (bodyKey) {
        body = `<div class="${moduleName}_card_body">${renderLongText(String(data[bodyKey]), moduleName)}</div>`;
    }

    const remainingKeys = keys.filter(k => k !== titleKey && k !== scoreKey && k !== bodyKey);
    const remaining = remainingKeys.map(k => {
        const v = data[k];
        if (v === undefined) return '';
        const propSchema = properties[k] || { type: inferType(v) };
        return renderField(k, v, propSchema as JsonSchemaValue, moduleName, depth + 1);
    }).filter(Boolean).join('');

    const extra = remaining ? `<div class="${moduleName}_card_extra">${remaining}</div>` : '';

    return `<div class="${moduleName}_card">${header}${body}${extra}</div>`;
}

function renderObjectField(
    label: string,
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    const fields = keys.map(k => {
        const v = data[k];
        if (v === undefined) return '';
        const propSchema = properties[k] || { type: inferType(v) };
        return renderField(k, v, propSchema as JsonSchemaValue, moduleName, depth + 1);
    }).filter(Boolean).join('');

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_nested">${fields}</div>
    </div>
  `;
}

function renderValue(
    value: unknown,
    schema: JsonSchemaValue,
    moduleName: string,
    fieldName?: string,
): string {
    if (value === null || value === undefined) {
        return `<span class="${moduleName}_null">—</span>`;
    }

    const type = schema.type || inferType(value);

    switch (type) {
        case 'string':
            return renderString(value as string, schema, moduleName);
        case 'number':
        case 'integer':
            return renderNumber(value as number, schema, moduleName, fieldName);
        case 'boolean':
            return renderBoolean(value as boolean, moduleName);
        default:
            return `<span>${escapeHtml(String(value))}</span>`;
    }
}

function renderString(data: string, schema: JsonSchemaValue, moduleName: string): string {
    if (!data.trim()) {
        return `<span class="${moduleName}_empty">(empty)</span>`;
    }

    const format = schema.format as string | undefined;

    if (format === 'uri' || format === 'url' || isUrl(data)) {
        const display = data.length > 50 ? data.substring(0, 47) + '...' : data;
        return `<a href="${escapeHtml(data)}" target="_blank" rel="noopener" class="${moduleName}_link">${escapeHtml(display)}</a>`;
    }

    if (format === 'email' || isEmail(data)) {
        return `<a href="mailto:${escapeHtml(data)}" class="${moduleName}_link">${escapeHtml(data)}</a>`;
    }

    if (data.length > 100 || data.includes('\n')) {
        return renderLongText(data, moduleName);
    }

    return `<span>${escapeHtml(data)}</span>`;
}

function renderLongText(data: string, moduleName: string): string {
    const formatted = formatResponse(data, moduleName);
    return `<div class="${moduleName}_text">${formatted}</div>`;
}

function renderNumber(
    data: number,
    schema: JsonSchemaValue,
    moduleName: string,
    fieldName?: string,
): string {
    const label = String(schema.title || schema.description || fieldName || '').toLowerCase();

    if (looksLikeScore(label, data)) {
        return renderScore(data, moduleName);
    }

    const formatted = data.toLocaleString(undefined, { maximumFractionDigits: 2 });
    return `<span class="${moduleName}_num">${formatted}</span>`;
}

function renderScore(data: number, moduleName: string): string {
    const normalized = data > 10 ? data / 10 : data;
    const color = getScoreColor(normalized);
    const display = Number.isInteger(data) ? data : data.toFixed(1);
    const max = data > 10 ? 100 : 10;

    return `<span class="${moduleName}_score" style="color: ${color}">${display}<span class="${moduleName}_score_max">/${max}</span></span>`;
}

function renderBoolean(data: boolean, moduleName: string): string {
    const icon = data ? 'fa-check-circle' : 'fa-times-circle';
    const cls = data ? `${moduleName}_yes` : `${moduleName}_no`;
    return `<span class="${cls}"><i class="fa-solid ${icon}"></i> ${data ? 'Yes' : 'No'}</span>`;
}

function renderSimpleValue(data: unknown, moduleName: string): string {
    if (typeof data === 'boolean') {
        return renderBoolean(data, moduleName);
    }
    if (typeof data === 'number') {
        return `<span class="${moduleName}_num">${data.toLocaleString()}</span>`;
    }
    return escapeHtml(String(data));
}

function renderJson(data: unknown, moduleName: string): string {
    const { hljs } = SillyTavern.libs;
    const json = JSON.stringify(data, null, 2);
    const highlighted = hljs.highlight(json, { language: 'json' }).value;
    return `<pre class="${moduleName}_json"><code class="hljs">${highlighted}</code></pre>`;
}

// ============================================================================
// HELPERS
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}

function inferType(value: unknown): string {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    return typeof value;
}

function isSimpleValue(value: unknown): boolean {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null;
}

function formatLabel(key: string): string {
    return key
        .replace(/_/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/\b\w/g, c => c.toUpperCase());
}

function findHeroKey(data: Record<string, unknown>): string | null {
    const heroPatterns = ['overallscore', 'totalscore', 'overall', 'total', 'score', 'rating'];

    for (const pattern of heroPatterns) {
        for (const key of Object.keys(data)) {
            if (key.toLowerCase().replace(/_/g, '') === pattern && typeof data[key] === 'number') {
                return key;
            }
        }
    }

    return null;
}

function looksLikeScore(label: string, value: number): boolean {
    const scoreWords = ['score', 'rating', 'rank', 'grade', 'level', 'confidence', 'quality'];
    if (scoreWords.some(word => label.includes(word))) return true;
    if (value >= 0 && value <= 10 && Number.isFinite(value)) return true;
    if (value >= 0 && value <= 100 && Number.isInteger(value)) return true;
    return false;
}

function getScoreColor(score: number): string {
    if (score >= 8) return 'var(--success, #2ecc71)';
    if (score >= 5) return 'var(--warning, #f39c12)';
    return 'var(--failure, #e74c3c)';
}

function isUrl(str: string): boolean {
    return /^https?:\/\//i.test(str);
}

function isEmail(str: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str);
}
```

## FILE: src/ui/panel.ts
```ts
// src/ui/panel.ts
//
// Extension panel - minimal, just the launch button and settings access.

import { MODULE_NAME, EXTENSION_PATH } from '../constants';
import { getSettings, setDebugMode } from '../settings';
import { debugLog, logError } from '../debug';
import { openMainPopup } from './popup';

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize the extension panel in ST's extensions settings
 */
export async function initPanel(): Promise<void> {
    const { renderExtensionTemplateAsync } = SillyTavern.getContext();

    const container = document.getElementById('extensions_settings');
    if (!container) {
        logError('Extensions container not found', null);
        return;
    }

    try {
        const html = await renderExtensionTemplateAsync(EXTENSION_PATH, 'templates/panel', {}, true);

        const wrapper = document.createElement('div');
        wrapper.id = `${MODULE_NAME}_wrapper`;
        wrapper.innerHTML = html;
        container.appendChild(wrapper);

        initEventListeners();

        debugLog('info', 'Panel initialized', null);
    } catch (error) {
        logError('Failed to load panel template', error);
    }
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function initEventListeners(): void {
    // Open button
    const openBtn = document.getElementById(`${MODULE_NAME}_open_btn`);
    openBtn?.addEventListener('click', () => {
        openMainPopup();
    });

    // Debug toggle
    const debugToggle = document.getElementById(`${MODULE_NAME}_debug_toggle`) as HTMLInputElement;
    if (debugToggle) {
        debugToggle.checked = getSettings().debugMode;
        debugToggle.addEventListener('change', () => {
            setDebugMode(debugToggle.checked);
            toastr.info(`Debug mode ${debugToggle.checked ? 'enabled' : 'disabled'}`);
        });
    }
}

// ============================================================================
// REFRESH
// ============================================================================

/**
 * Refresh panel state (called when settings change externally)
 */
export function refreshPanel(): void {
    const debugToggle = document.getElementById(`${MODULE_NAME}_debug_toggle`) as HTMLInputElement;
    if (debugToggle) {
        debugToggle.checked = getSettings().debugMode;
    }
}
```

## FILE: src/ui/popup.ts
```ts
// src/ui/popup.ts
//
// Main popup controller - orchestrates all components and manages state.

import { MODULE_NAME, STAGES, STAGE_LABELS, STAGE_ICONS } from '../constants';
import { debugLog } from '../debug';
import {
    createPipelineState,
    resetPipeline,
    setCharacter,
    toggleStage,
    updateStageConfig as pipelineUpdateStageConfig,
    startStage,
    completeStage,
    failStage,
    lockStageResult,
    unlockStageResult,
    clearStageResult,
    getNextStage,
    canRunStage,
    canRefine,
    validatePipeline,
    validateRefinement,
    setExportData,
    buildStagePrompt,
    getStageSchema,
    startRefinement,
    completeRefinement,
    acceptRewrite,
    revertToIteration,
    parseRewriteResponse,
    applyRewriteToCharacter,
} from '../pipeline';
import { getPromptPreset, getSchemaPreset } from '../settings';
import { runStageGeneration, runRefinementGeneration, getStageTokenCount, getRefinementTokenCount, getApiInfo, isApiReady } from '../generator';
import { renderCharacterSelect, updateCharacterSelectState, renderDropdownItems, updateFieldTokenCounts } from './components/character-select';
import { getPopulatedFields } from '../character';
import { renderPipelineNav, updatePipelineNavState } from './components/pipeline-nav';
import {
    renderStageConfig,
    updateStageConfigState,
    handleSavePromptPreset,
    handleSaveSchemaPreset,
    handleValidateSchema,
    handleFixSchema,
    handleFormatSchema,
    handleGenerateSchema,
} from './components/stage-config';
import { renderResultsPanel, updateResultsPanelState, renderRefinementLoading } from './components/results-panel';
import { renderIterationHistory, updateIterationHistoryState, renderIterationViewContent } from './components/iteration-history';
import { openSettingsModal } from './settings-modal';
import { saveIterationHistory, loadIterationHistory } from '../persistence';
import type { PipelineState, StageName, Character, IterationSnapshot } from '../types';

// ============================================================================
// STATE
// ============================================================================

let popupState: {
    pipeline: PipelineState;
    isGenerating: boolean;
    isRefining: boolean;
    abortController: AbortController | null;
    activeStageView: StageName;
    historyLoaded: boolean;
    // Store debounced functions for cleanup
    debouncedFunctions: Array<{ cancel: () => void }>;
} | null = null;

let popupElement: HTMLElement | null = null;

// ============================================================================
// EVENT MANAGEMENT
// ============================================================================

const eventCleanup: Array<() => void> = [];

function subscribeEvents(): void {
    const { eventSource, eventTypes } = SillyTavern.getContext();

    const handlers = {
        onStatusChange: () => {
            debugLog('info', 'API status changed', { isReady: isApiReady() });
            updateApiStatus();
        },

        onMainApiChange: () => {
            debugLog('info', 'Main API changed', null);
            updateApiStatus();
            updateTokenEstimate();
        },

        onCharEdited: (data: { detail?: { character: Character; id: string }; character?: Character; id?: number }) => {
            // Handle both payload formats - CHARACTER_EDITED uses { detail: { character, id: string } }
            const character = data.detail?.character ?? data.character;
            const id = data.detail?.id !== undefined ? parseInt(data.detail.id, 10) : data.id;

            debugLog('info', 'Character edited externally', { id, name: character?.name });
            refreshSelectedCharacter(id as number);
        },

        onCharDeleted: (data: { id: number; character: Character }) => {
            // CHARACTER_DELETED uses flat { id: number, character }
            debugLog('info', 'Character deleted', { id: data.id });
            handleCharacterDeleted(data.id);
        },

        onPresetChanged: () => {
            debugLog('info', 'OAI preset changed', null);
            if (popupState) {
                updateTokenEstimate();
            }
        },

        onSourceChanged: () => {
            debugLog('info', 'Chat completion source changed', null);
            updateApiStatus();
            updateTokenEstimate();
        },

        onModelChanged: () => {
            debugLog('info', 'Chat completion model changed', null);
            updateApiStatus();
            updateTokenEstimate();
        },
    };

    eventSource.on(eventTypes.ONLINE_STATUS_CHANGED, handlers.onStatusChange);
    eventSource.on(eventTypes.MAIN_API_CHANGED, handlers.onMainApiChange);
    eventSource.on(eventTypes.CHARACTER_EDITED, handlers.onCharEdited);
    eventSource.on(eventTypes.CHARACTER_DELETED, handlers.onCharDeleted);
    eventSource.on(eventTypes.OAI_PRESET_CHANGED_AFTER, handlers.onPresetChanged);
    eventSource.on(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, handlers.onSourceChanged);
    eventSource.on(eventTypes.CHATCOMPLETION_MODEL_CHANGED, handlers.onModelChanged);

    eventCleanup.push(
        () => eventSource.removeListener(eventTypes.ONLINE_STATUS_CHANGED, handlers.onStatusChange),
        () => eventSource.removeListener(eventTypes.MAIN_API_CHANGED, handlers.onMainApiChange),
        () => eventSource.removeListener(eventTypes.CHARACTER_EDITED, handlers.onCharEdited),
        () => eventSource.removeListener(eventTypes.CHARACTER_DELETED, handlers.onCharDeleted),
        () => eventSource.removeListener(eventTypes.OAI_PRESET_CHANGED_AFTER, handlers.onPresetChanged),
        () => eventSource.removeListener(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, handlers.onSourceChanged),
        () => eventSource.removeListener(eventTypes.CHATCOMPLETION_MODEL_CHANGED, handlers.onModelChanged),
    );

    debugLog('info', 'Event listeners subscribed', { count: eventCleanup.length });
}

function unsubscribeEvents(): void {
    eventCleanup.forEach(fn => fn());
    eventCleanup.length = 0;
    debugLog('info', 'Event listeners unsubscribed', null);
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

function updateApiStatus(): void {
    if (!popupElement) return;

    const apiInfo = getApiInfo();
    const statusEl = popupElement.querySelector(`.${MODULE_NAME}_api_status`);

    if (statusEl) {
        statusEl.className = `${MODULE_NAME}_api_status ${apiInfo.isReady ? 'connected' : 'disconnected'}`;
        const textSpan = statusEl.querySelector('span');
        if (textSpan) {
            textSpan.textContent = apiInfo.source;
        }
    }

    updatePipelineNav();
}

function refreshSelectedCharacter(editedId?: number): void {
    if (!popupState || popupState.pipeline.characterIndex === null) return;

    // Get fresh characters from context - don't use cached
    const { characters } = SillyTavern.getContext();
    const charList = characters as Character[];
    const index = popupState.pipeline.characterIndex;

    // If a specific character was edited and it's not ours, ignore
    if (editedId !== undefined && editedId !== index) {
        return;
    }

    if (index >= 0 && index < charList.length) {
        const updatedChar = charList[index];

        if (updatedChar.name === popupState.pipeline.character?.name) {
            popupState.pipeline = {
                ...popupState.pipeline,
                character: updatedChar,
            };
            updateCharacterSelect();
            updateTokenEstimate();
            debugLog('info', 'Character refreshed', { name: updatedChar.name });
        } else {
            handleCharacterInvalidated();
        }
    } else {
        handleCharacterInvalidated();
    }
}

function handleCharacterDeleted(deletedId: number): void {
    if (!popupState) return;

    const currentIndex = popupState.pipeline.characterIndex;

    if (currentIndex === null) return;

    if (currentIndex === deletedId) {
        handleCharacterInvalidated();
        toastr.warning('Selected character was deleted');
    } else if (currentIndex > deletedId) {
        // Get fresh characters from context
        const { characters } = SillyTavern.getContext();
        const charList = characters as Character[];

        const newIndex = currentIndex - 1;

        if (newIndex >= 0 && newIndex < charList.length) {
            popupState.pipeline = {
                ...popupState.pipeline,
                characterIndex: newIndex,
                character: charList[newIndex],
            };
            debugLog('info', 'Character index adjusted after deletion', { oldIndex: currentIndex, newIndex });
        } else {
            handleCharacterInvalidated();
        }
    }
}

function handleCharacterInvalidated(): void {
    if (!popupState) return;

    debugLog('info', 'Character invalidated, clearing selection', null);

    popupState.pipeline = setCharacter(popupState.pipeline, null, null);
    popupState.historyLoaded = false;
    updateAllComponents();
    toastr.info('Character selection cleared');
}

// ============================================================================
// GLOBAL LISTENERS
// ============================================================================

let documentClickHandler: ((e: MouseEvent) => void) | null = null;
let keyboardHandler: ((e: KeyboardEvent) => void) | null = null;

function initGlobalListeners(): void {
    keyboardHandler = (e: KeyboardEvent) => {
        if (!popupState) return;

        // Ctrl+Enter to run current stage
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            if (!popupState.isGenerating && !popupState.isRefining) {
                runSingleStage(popupState.activeStageView);
            }
        }

        // Escape to cancel generation
        if (e.key === 'Escape' && (popupState.isGenerating || popupState.isRefining) && popupState.abortController) {
            popupState.abortController.abort();
        }
    };

    document.addEventListener('keydown', keyboardHandler);
}

function removeGlobalListeners(): void {
    if (keyboardHandler) {
        document.removeEventListener('keydown', keyboardHandler);
        keyboardHandler = null;
    }
    if (documentClickHandler) {
        document.removeEventListener('click', documentClickHandler);
        documentClickHandler = null;
    }

    // Cancel any pending debounced operations
    if (popupState?.debouncedFunctions) {
        popupState.debouncedFunctions.forEach(fn => fn.cancel());
        popupState.debouncedFunctions = [];
    }
}

// ============================================================================
// MAIN ENTRY
// ============================================================================

export async function openMainPopup(): Promise<void> {
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    popupState = {
        pipeline: createPipelineState(),
        isGenerating: false,
        isRefining: false,
        abortController: null,
        activeStageView: 'score',
        historyLoaded: false,
        debouncedFunctions: [],
    };

    const content = buildPopupContent();

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: false,
        cancelButton: false,
    });

    popup.show().then(() => {
        if (popupState?.abortController) {
            popupState.abortController.abort();
        }
        popupState = null;
        popupElement = null;
        unsubscribeEvents();
        removeGlobalListeners();
        debugLog('info', 'Popup closed', null);
    });

    await new Promise<void>(resolve => setTimeout(resolve, 0));

    popupElement = document.getElementById(`${MODULE_NAME}_popup`);

    subscribeEvents();
    initGlobalListeners();

    // Get fresh characters from context
    const { characters } = SillyTavern.getContext();
    const charList = characters as Character[];

    initComponents(charList);
    updateAllComponents();

    debugLog('info', 'Popup opened', { characterCount: charList.length });
}

// ============================================================================
// POPUP HTML
// ============================================================================

function buildPopupContent(): string {
    const apiInfo = getApiInfo();

    return `
    <div class="${MODULE_NAME}_popup" id="${MODULE_NAME}_popup">
      <!-- Header -->
      <div class="${MODULE_NAME}_popup_header">
        <div class="${MODULE_NAME}_popup_title">
          <i class="fa-solid fa-wand-magic-sparkles"></i>
          <span>Character Tools</span>
        </div>
        <div class="${MODULE_NAME}_popup_header_right">
          <div class="${MODULE_NAME}_api_status ${apiInfo.isReady ? 'connected' : 'disconnected'}">
            <i class="fa-solid fa-circle"></i>
            <span>${apiInfo.source}</span>
          </div>
          <button id="${MODULE_NAME}_settings_btn" class="${MODULE_NAME}_icon_btn" title="Settings">
            <i class="fa-solid fa-gear"></i>
          </button>
          <button id="${MODULE_NAME}_close_btn" class="${MODULE_NAME}_icon_btn" title="Close">
            <i class="fa-solid fa-xmark"></i>
          </button>
        </div>
      </div>

      <!-- Character Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_character_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-user"></i>
          <span>Character</span>
        </div>
        <div id="${MODULE_NAME}_character_select_container"></div>
      </div>

      <!-- Pipeline Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_pipeline_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-diagram-project"></i>
          <span>Pipeline</span>
        </div>
        <div id="${MODULE_NAME}_pipeline_nav_container"></div>
      </div>

      <!-- Stage Config Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_stage_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid ${STAGE_ICONS.score}" id="${MODULE_NAME}_stage_icon"></i>
          <span id="${MODULE_NAME}_stage_title">Score</span>
        </div>
        <div id="${MODULE_NAME}_stage_config_container"></div>
      </div>

      <!-- Results Section -->
      <div class="${MODULE_NAME}_section ${MODULE_NAME}_section_grow" id="${MODULE_NAME}_results_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-file-lines"></i>
          <span>Results</span>
          <span id="${MODULE_NAME}_iteration_indicator" class="${MODULE_NAME}_iteration_indicator hidden"></span>
        </div>
        <div id="${MODULE_NAME}_results_container"></div>
        <div id="${MODULE_NAME}_iteration_history_container"></div>
      </div>
    </div>
  `;
}

// ============================================================================
// COMPONENT INITIALIZATION
// ============================================================================

function initComponents(characters: Character[]): void {
    if (!popupState || !popupElement) return;

    // Character select
    const charContainer = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (charContainer) {
        charContainer.innerHTML = renderCharacterSelect(characters, popupState.pipeline.characterIndex);
        initCharacterSelectListeners();
    }

    // Pipeline nav
    const pipelineContainer = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (pipelineContainer) {
        pipelineContainer.innerHTML = renderPipelineNav(
            popupState.pipeline.selectedStages,
            popupState.pipeline.stageStatus,
            popupState.activeStageView,
            !!popupState.pipeline.character,
        );
        initPipelineNavListeners();
    }

    // Stage config
    const stageContainer = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (stageContainer) {
        stageContainer.innerHTML = renderStageConfig(
            popupState.activeStageView,
            popupState.pipeline.configs[popupState.activeStageView],
            null,
        );
        initStageConfigListeners();
    }

    // Results panel
    const resultsContainer = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (resultsContainer) {
        resultsContainer.innerHTML = renderResultsPanel(
            popupState.activeStageView,
            popupState.pipeline.results[popupState.activeStageView],
            popupState.pipeline.stageStatus[popupState.activeStageView],
            popupState.isGenerating,
        );
        initResultsPanelListeners();
    }

    // Iteration history
    const historyContainer = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (historyContainer) {
        historyContainer.innerHTML = renderIterationHistory(
            popupState.pipeline.iterationHistory,
            popupState.pipeline.iterationCount,
            popupState.historyLoaded,
        );
        initIterationHistoryListeners();
    }

    // Header buttons
    popupElement.querySelector(`#${MODULE_NAME}_settings_btn`)?.addEventListener('click', () => {
        openSettingsModal(() => {
            // After settings close, check if any deleted presets were in use
            if (popupState) {
                checkForDeletedPresetReferences();
            }
            updateAllComponents();
        });
    });

    popupElement.querySelector(`#${MODULE_NAME}_close_btn`)?.addEventListener('click', () => {
        const dialog = popupElement?.closest('.popup');
        if (dialog) {
            const cancelBtn = dialog.querySelector('.popup-button-cancel, .popup-button-ok') as HTMLElement;
            cancelBtn?.click();
        }
    });
}

/**
 * Check if current pipeline configs reference deleted presets and clear them
 */
function checkForDeletedPresetReferences(): void {
    if (!popupState) return;

    for (const stage of STAGES) {
        const config = popupState.pipeline.configs[stage];

        // Check prompt preset
        if (config.promptPresetId && !getPromptPreset(config.promptPresetId)) {
            debugLog('info', 'Clearing deleted prompt preset reference', { stage, presetId: config.promptPresetId });
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, stage, {
                promptPresetId: null,
            });
        }

        // Check schema preset
        if (config.schemaPresetId && !getSchemaPreset(config.schemaPresetId)) {
            debugLog('info', 'Clearing deleted schema preset reference', { stage, presetId: config.schemaPresetId });
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, stage, {
                schemaPresetId: null,
            });
        }
    }
}

// ============================================================================
// CHARACTER SELECT LISTENERS
// ============================================================================

function initCharacterSelectListeners(): void {
    if (!popupElement || !popupState) return;

    const { Fuse, lodash } = SillyTavern.libs;

    const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (!container) return;

    const searchInput = container.querySelector(`#${MODULE_NAME}_char_search`) as HTMLInputElement;
    const dropdown = container.querySelector(`#${MODULE_NAME}_char_dropdown`) as HTMLElement;

    if (!searchInput || !dropdown) return;

    let selectedIndex = -1;
    let currentResults: Array<{ char: Character; index: number }> = [];

    const handleSearch = () => {
        // Get fresh characters from context
        const { characters } = SillyTavern.getContext();
        const currentChars = characters as Character[];

        const currentCharData = currentChars
            .map((char, index) => ({ char, index }))
            .filter(({ char }) => char?.name);

        const fuse = new Fuse(currentCharData, {
            keys: ['char.name', 'char.description'],
            threshold: 0.4,
            includeScore: true,
            minMatchCharLength: 1,
        });

        const query = searchInput.value.trim();

        if (!query) {
            dropdown.classList.add('hidden');
            currentResults = [];
            return;
        }

        const results = fuse.search(query, { limit: 10 });
        currentResults = results.map((r: { item: { char: Character; index: number } }) => r.item);

        if (currentResults.length === 0) {
            dropdown.innerHTML = `<div class="${MODULE_NAME}_dropdown_empty">No characters found</div>`;
            dropdown.classList.remove('hidden');
            return;
        }

        selectedIndex = -1;
        renderDropdownItems(currentResults, dropdown, -1);
        dropdown.classList.remove('hidden');
    };

    const debouncedSearch = lodash.debounce(handleSearch, 150);
    popupState.debouncedFunctions.push(debouncedSearch);
    searchInput.addEventListener('input', debouncedSearch);

    searchInput.addEventListener('keydown', (e) => {
        if (currentResults.length === 0) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
            renderDropdownItems(currentResults, dropdown, selectedIndex);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, 0);
            renderDropdownItems(currentResults, dropdown, selectedIndex);
        } else if (e.key === 'Enter' && selectedIndex >= 0) {
            e.preventDefault();
            selectCharacter(currentResults[selectedIndex].char, currentResults[selectedIndex].index);
            dropdown.classList.add('hidden');
            searchInput.value = '';
        } else if (e.key === 'Escape') {
            dropdown.classList.add('hidden');
            searchInput.value = '';
        }
    });

    documentClickHandler = (e: MouseEvent) => {
        if (!searchInput.contains(e.target as Node) && !dropdown.contains(e.target as Node)) {
            dropdown.classList.add('hidden');
        }
    };
    document.addEventListener('click', documentClickHandler);

    dropdown.addEventListener('click', (e) => {
        const item = (e.target as HTMLElement).closest(`.${MODULE_NAME}_dropdown_item`);
        if (item) {
            const index = parseInt(item.getAttribute('data-index') || '-1', 10);
            const charItem = currentResults.find(c => c.index === index);
            if (charItem) {
                selectCharacter(charItem.char, charItem.index);
                dropdown.classList.add('hidden');
                searchInput.value = '';
            }
        }
    });

    container.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;

        if (target.closest(`#${MODULE_NAME}_char_clear`)) {
            if (!popupState) return;
            popupState.pipeline = setCharacter(popupState.pipeline, null, null);
            popupState.historyLoaded = false;
            updateAllComponents();
            return;
        }

        const toggle = target.closest(`.${MODULE_NAME}_field_toggle`);
        if (toggle) {
            const fieldKey = toggle.getAttribute('data-field');
            const content = container.querySelector(`#${MODULE_NAME}_field_content_${fieldKey}`);
            const icon = toggle.querySelector('i');

            if (content && icon) {
                content.classList.toggle('hidden');
                icon.classList.toggle('fa-chevron-right');
                icon.classList.toggle('fa-chevron-down');
            }
        }
    });
}

async function selectCharacter(char: Character, index: number): Promise<void> {
    if (!popupState) return;

    popupState.pipeline = setCharacter(popupState.pipeline, char, index);
    popupState.historyLoaded = false;
    updateAllComponents();

    // Load iteration history for this character
    const history = await loadIterationHistory(char);
    if (popupState && popupState.pipeline.character === char) {
        if (history && history.length > 0) {
            popupState.pipeline = {
                ...popupState.pipeline,
                iterationHistory: history,
                iterationCount: history.length,
            };
            debugLog('info', 'Loaded iteration history', { count: history.length });
        }
        popupState.historyLoaded = true;
        updateIterationHistory();
    }

    // Update token counts
    setTimeout(async () => {
        if (!popupElement || !popupState?.pipeline.character) return;

        const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
        if (container) {
            const fields = getPopulatedFields(popupState.pipeline.character);
            await updateFieldTokenCounts(container as HTMLElement, fields);
        }
    }, 50);

    debugLog('info', 'Character selected', { name: char.name, index });
}

// ============================================================================
// PIPELINE NAV LISTENERS
// ============================================================================

function initPipelineNavListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (!container) return;

    container.addEventListener('change', (e) => {
        const checkbox = e.target as HTMLInputElement;
        if (checkbox.classList.contains(`${MODULE_NAME}_stage_checkbox`)) {
            const stage = checkbox.getAttribute('data-stage') as StageName;
            if (stage && popupState) {
                popupState.pipeline = toggleStage(popupState.pipeline, stage);
                updatePipelineNav();
            }
        }
    });

    container.addEventListener('click', async (e) => {
        const btn = (e.target as HTMLElement).closest(`.${MODULE_NAME}_stage_btn`);
        if (btn && popupState) {
            const stage = btn.getAttribute('data-stage') as StageName;
            if (stage) {
                popupState.activeStageView = stage;
                updateStageSection();
                updateResultsPanel();
                updateTokenEstimate();
                updatePipelineNav();
            }
        }

        const runBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_run_selected_btn`);
        if (runBtn) {
            runSelectedStages();
        }

        const runAllBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_run_all_btn`);
        if (runAllBtn) {
            runAllStages();
        }

        const resetBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_reset_pipeline_btn`);
        if (resetBtn && popupState) {
            // Confirm before reset
            const { Popup, POPUP_RESULT } = SillyTavern.getContext();
            const confirmed = await Popup.show.confirm(
                'Reset Pipeline?',
                'This will clear all results and iteration history. Continue?',
            );

            if (confirmed !== POPUP_RESULT.AFFIRMATIVE) return;

            popupState.pipeline = resetPipeline(popupState.pipeline, true);
            popupState.historyLoaded = true; // No history to load after reset
            updateAllComponents();
        }
    });
}

// ============================================================================
// STAGE CONFIG LISTENERS
// ============================================================================

function initStageConfigListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (!container) return;

    container.addEventListener('change', (e) => {
        const select = e.target as HTMLSelectElement;

        if (select.id === `${MODULE_NAME}_prompt_preset_select` && popupState) {
            const value = select.value || null;
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                promptPresetId: value,
            });
            updateStageConfigUI();
            updateTokenEstimate();
        }

        if (select.id === `${MODULE_NAME}_schema_preset_select` && popupState) {
            const value = select.value || null;
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                schemaPresetId: value,
            });
            updateStageConfigUI();
        }
    });

    const { lodash } = SillyTavern.libs;

    const debouncedInputHandler = lodash.debounce((e: Event) => {
        const textarea = e.target as HTMLTextAreaElement;

        if (textarea.id === `${MODULE_NAME}_custom_prompt` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                customPrompt: textarea.value,
                promptPresetId: null,
            });
            updateTokenEstimate();
            updateStageConfigUI();
        }

        if (textarea.id === `${MODULE_NAME}_custom_schema` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                customSchema: textarea.value,
                schemaPresetId: null,
            });
            updateStageConfigUI();
        }
    }, 300);

    popupState.debouncedFunctions.push(debouncedInputHandler);
    container.addEventListener('input', debouncedInputHandler);

    container.addEventListener('change', (e) => {
        const checkbox = e.target as HTMLInputElement;
        if (checkbox.id === `${MODULE_NAME}_use_structured` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                useStructuredOutput: checkbox.checked,
            });
            updateStageConfigUI();
        }
    });

    container.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;

        const runBtn = target.closest(`#${MODULE_NAME}_run_stage_btn`);
        if (runBtn && popupState) {
            runSingleStage(popupState.activeStageView);
            return;
        }

        const savePromptBtn = target.closest(`#${MODULE_NAME}_save_prompt_preset_btn`);
        if (savePromptBtn && popupState) {
            const promptTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
            if (promptTextarea) {
                const result = await handleSavePromptPreset(popupState.activeStageView, promptTextarea.value);
                if (result.success && result.presetId) {
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        promptPresetId: result.presetId,
                        customPrompt: '',
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const saveSchemaBtn = target.closest(`#${MODULE_NAME}_save_schema_preset_btn`);
        if (saveSchemaBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const result = await handleSaveSchemaPreset(popupState.activeStageView, schemaTextarea.value);
                if (result.success && result.presetId) {
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        schemaPresetId: result.presetId,
                        customSchema: '',
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const generateBtn = target.closest(`#${MODULE_NAME}_generate_schema_btn`);
        if (generateBtn && popupState) {
            const generated = await handleGenerateSchema();
            if (generated) {
                const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
                if (schemaTextarea) {
                    schemaTextarea.value = generated;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: generated,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const validateBtn = target.closest(`#${MODULE_NAME}_validate_schema_btn`);
        if (validateBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                await handleValidateSchema(schemaTextarea.value);
            }
            return;
        }

        const fixBtn = target.closest(`#${MODULE_NAME}_fix_schema_btn`);
        if (fixBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const fixed = handleFixSchema(schemaTextarea.value);
                if (fixed) {
                    schemaTextarea.value = fixed;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: fixed,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const formatBtn = target.closest(`#${MODULE_NAME}_format_schema_btn`);
        if (formatBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const formatted = handleFormatSchema(schemaTextarea.value);
                if (formatted) {
                    schemaTextarea.value = formatted;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: formatted,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }
    });
}

// ============================================================================
// RESULTS PANEL LISTENERS
// ============================================================================

function initResultsPanelListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (!container) return;

    container.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;

        // Regenerate
        if (target.closest(`#${MODULE_NAME}_regenerate_btn`) && popupState) {
            popupState.pipeline = clearStageResult(popupState.pipeline, popupState.activeStageView);
            runSingleStage(popupState.activeStageView);
        }

        // Lock/Unlock
        if (target.closest(`#${MODULE_NAME}_lock_btn`) && popupState) {
            popupState.pipeline = lockStageResult(popupState.pipeline, popupState.activeStageView);
            updateResultsPanel();
        }

        if (target.closest(`#${MODULE_NAME}_unlock_btn`) && popupState) {
            popupState.pipeline = unlockStageResult(popupState.pipeline, popupState.activeStageView);
            updateResultsPanel();
        }

        // Continue to next stage
        if (target.closest(`#${MODULE_NAME}_continue_btn`) && popupState) {
            const nextStage = getNextStage(popupState.pipeline, popupState.activeStageView);
            if (nextStage) {
                popupState.activeStageView = nextStage;
                updateStageSection();
                updateResultsPanel();
                updateTokenEstimate();
            }
        }

        // Apply to Character
        if (target.closest(`#${MODULE_NAME}_apply_btn`) && popupState) {
            await handleApplyToCharacter();
        }

        // Refine
        if (target.closest(`#${MODULE_NAME}_refine_btn`) && popupState) {
            runRefinement();
        }

        // Accept rewrite
        if (target.closest(`#${MODULE_NAME}_accept_btn`) && popupState) {
            popupState.pipeline = acceptRewrite(popupState.pipeline);
            toastr.success('Rewrite accepted as final');
            updateAllComponents();
        }

        // Copy
        if (target.closest(`#${MODULE_NAME}_copy_btn`) && popupState) {
            const result = popupState.pipeline.results[popupState.activeStageView];
            if (result) {
                navigator.clipboard.writeText(result.response);
                toastr.success('Copied to clipboard');
            }
        }

        // Export
        if (target.closest(`#${MODULE_NAME}_export_btn`) && popupState) {
            popupState.pipeline = setExportData(popupState.pipeline);
            if (popupState.pipeline.exportData) {
                navigator.clipboard.writeText(popupState.pipeline.exportData);
                toastr.success('Export copied to clipboard');
            }
        }

        // Cancel generation
        if (target.closest(`#${MODULE_NAME}_cancel_btn`) && popupState?.abortController) {
            popupState.abortController.abort();
        }
    });
}

// ============================================================================
// APPLY TO CHARACTER
// ============================================================================

async function handleApplyToCharacter(): Promise<void> {
    if (!popupState || !popupState.pipeline.results.rewrite || !popupState.pipeline.character) {
        toastr.warning('No rewrite to apply');
        return;
    }

    const { Popup, POPUP_TYPE, POPUP_RESULT } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const rewriteResponse = popupState.pipeline.results.rewrite.response;
    const parsed = parseRewriteResponse(rewriteResponse);

    // Build preview content
    let previewHtml = `<div class="${MODULE_NAME}_apply_preview">`;
    previewHtml += `<p><strong>Parse method:</strong> ${parsed.parseMethod}</p>`;

    if (parsed.fields.length === 0) {
        previewHtml += `<p class="${MODULE_NAME}_apply_warning">
            <i class="fa-solid fa-triangle-exclamation"></i>
            No recognized character fields found in the rewrite output.
            The raw content will be copied to clipboard instead.
        </p>`;
        previewHtml += `<details><summary>Raw content preview</summary><pre>${DOMPurify.sanitize(parsed.raw.substring(0, 500))}...</pre></details>`;
    } else {
        previewHtml += `<p><strong>Fields to update (${parsed.fields.length}):</strong></p>`;
        previewHtml += '<ul>';
        for (const field of parsed.fields) {
            const preview = field.value.substring(0, 100);
            previewHtml += `<li><strong>${DOMPurify.sanitize(field.label)}:</strong> ${DOMPurify.sanitize(preview)}${field.value.length > 100 ? '...' : ''}</li>`;
        }
        previewHtml += '</ul>';
    }
    previewHtml += '</div>';

    // Show confirmation
    const confirmContent = `
        <h3>Apply Rewrite to Character?</h3>
        <p>This will update <strong>${DOMPurify.sanitize(popupState.pipeline.character.name)}</strong> with the rewritten content.</p>
        ${previewHtml}
    `;

    const popup = new Popup(confirmContent, POPUP_TYPE.CONFIRM, '', {
        wide: true,
        okButton: parsed.fields.length > 0 ? 'Apply Changes' : 'Copy Raw Content',
        cancelButton: 'Cancel',
    });

    const result = await popup.show();

    if (result !== POPUP_RESULT.AFFIRMATIVE) {
        return;
    }

    // If no fields parsed, just copy raw content
    if (parsed.fields.length === 0) {
        navigator.clipboard.writeText(parsed.raw);
        toastr.info('Raw content copied to clipboard');
        return;
    }

    // Apply the changes
    const applyResult = await applyRewriteToCharacter(popupState.pipeline, parsed.fields);

    if (applyResult.success) {
        toastr.success(`Updated ${applyResult.updatedFields.length} fields: ${applyResult.updatedFields.join(', ')}`);

        // Emit custom event for other extensions
        const { eventSource } = SillyTavern.getContext();
        await eventSource.emit('character_tools_rewrite_applied', {
            characterName: popupState.pipeline.character.name,
            characterIndex: popupState.pipeline.characterIndex,
            updatedFields: applyResult.updatedFields,
            iterationCount: popupState.pipeline.iterationCount,
        });

        // Refresh character data
        refreshSelectedCharacter();
    } else {
        toastr.error(applyResult.error || 'Failed to apply changes');
    }
}

// ============================================================================
// ITERATION HISTORY LISTENERS
// ============================================================================

function initIterationHistoryListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (!container) return;

    container.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;

        // Revert button
        const revertBtn = target.closest(`.${MODULE_NAME}_iteration_revert_btn`);
        if (revertBtn && popupState) {
            const index = parseInt(revertBtn.getAttribute('data-index') || '-1', 10);
            if (index >= 0) {
                await handleRevertToIteration(index);
            }
        }

        // View button
        const viewBtn = target.closest(`.${MODULE_NAME}_iteration_view_btn`);
        if (viewBtn && popupState) {
            const index = parseInt(viewBtn.getAttribute('data-index') || '-1', 10);
            if (index >= 0 && index < popupState.pipeline.iterationHistory.length) {
                showIterationView(popupState.pipeline.iterationHistory[index]);
            }
        }
    });
}

async function handleRevertToIteration(index: number): Promise<void> {
    if (!popupState) return;

    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    const confirmed = await Popup.show.confirm(
        'Revert to Previous Iteration?',
        `This will restore the rewrite from iteration #${index + 1} and discard later changes.`,
    );

    if (confirmed !== POPUP_RESULT.AFFIRMATIVE) return;

    popupState.pipeline = revertToIteration(popupState.pipeline, index);
    toastr.info(`Reverted to iteration #${index + 1}`);

    // Save updated history
    if (popupState.pipeline.character) {
        await saveIterationHistory(popupState.pipeline.character, popupState.pipeline.iterationHistory);
    }

    updateAllComponents();
}

async function showIterationView(snap: IterationSnapshot): Promise<void> {
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const content = renderIterationViewContent(snap);

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: 'Close',
        cancelButton: false,
    });

    await popup.show();
}

// ============================================================================
// GENERATION
// ============================================================================

async function runSingleStage(stage: StageName): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const canRun = canRunStage(popupState.pipeline, stage);
    if (!canRun.canRun) {
        toastr.warning(canRun.reason || 'Cannot run this stage');
        return;
    }

    if (canRun.reason) {
        toastr.info(canRun.reason);
    }

    popupState.isGenerating = true;
    popupState.abortController = new AbortController();
    popupState.pipeline = startStage(popupState.pipeline, stage);
    updateAllComponents();

    const promptUsed = buildStagePrompt(popupState.pipeline, stage) || '';
    const schemaUsed = getStageSchema(popupState.pipeline, stage);

    try {
        const result = await runStageGeneration(
            popupState.pipeline,
            stage,
            popupState.abortController.signal,
        );

        if (result.success) {
            popupState.pipeline = completeStage(popupState.pipeline, stage, {
                response: result.response,
                isStructured: result.isStructured,
                promptUsed,
                schemaUsed,
            });
            toastr.success(`${STAGE_LABELS[stage]} complete`);
        } else {
            popupState.pipeline = failStage(popupState.pipeline, stage, result.error);
            if (result.error !== 'Generation cancelled') {
                toastr.error(result.error);
            }
        }
    } catch (e) {
        popupState.pipeline = failStage(popupState.pipeline, stage, (e as Error).message);
        toastr.error((e as Error).message);
    } finally {
        popupState.isGenerating = false;
        popupState.abortController = null;
        updateAllComponents();
    }
}

async function runSelectedStages(): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const validation = validatePipeline(popupState.pipeline);
    if (!validation.valid) {
        toastr.error(validation.errors.join('\n'));
        return;
    }

    if (validation.warnings.length > 0) {
        toastr.warning(validation.warnings.join('\n'));
    }

    for (const stage of popupState.pipeline.selectedStages) {
        const status = popupState.pipeline.stageStatus[stage];
        if (status === 'complete' || status === 'skipped') {
            continue;
        }

        popupState.activeStageView = stage;
        updateStageSection();

        await runSingleStage(stage);

        if (!popupState) break;

        const newStatus = popupState.pipeline.stageStatus[stage];
        if (newStatus !== 'complete') {
            break;
        }
    }
}

async function runAllStages(): Promise<void> {
    if (!popupState) return;

    popupState.pipeline.selectedStages = [...STAGES];
    updatePipelineNav();

    await runSelectedStages();
}

async function runRefinement(): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const canRefineResult = canRefine(popupState.pipeline);
    if (!canRefineResult.canRun) {
        toastr.warning(canRefineResult.reason || 'Cannot refine');
        return;
    }

    const validation = validateRefinement(popupState.pipeline);
    if (!validation.valid) {
        toastr.error(validation.errors.join('\n'));
        return;
    }

    if (validation.warnings.length > 0) {
        toastr.warning(validation.warnings.join('\n'));
    }

    // Snapshot current state before starting refinement
    const preRefinementState = {
        iterationCount: popupState.pipeline.iterationCount,
        iterationHistory: [...popupState.pipeline.iterationHistory],
    };

    // Start refinement - this snapshots current state
    popupState.pipeline = startRefinement(popupState.pipeline);
    popupState.isRefining = true;
    popupState.abortController = new AbortController();

    // Show refinement loading state
    const resultsContainer = popupElement?.querySelector(`#${MODULE_NAME}_results_container`);
    if (resultsContainer) {
        resultsContainer.innerHTML = renderRefinementLoading(popupState.pipeline.iterationCount);
    }

    updateIterationIndicator();
    updateIterationHistory();

    try {
        const result = await runRefinementGeneration(
            popupState.pipeline,
            popupState.abortController.signal,
        );

        if (result.success) {
            popupState.pipeline = completeRefinement(popupState.pipeline, {
                response: result.response,
                isStructured: false,
                promptUsed: '[Refinement prompt]',
                schemaUsed: null,
            });

            toastr.success(`Refinement #${popupState.pipeline.iterationCount} complete`);

            // Save iteration history
            if (popupState.pipeline.character) {
                await saveIterationHistory(popupState.pipeline.character, popupState.pipeline.iterationHistory);
            }

            // Switch to analyze view so user can review
            popupState.activeStageView = 'analyze';
        } else {
            // Restore pre-refinement state on failure
            popupState.pipeline = {
                ...popupState.pipeline,
                iterationCount: preRefinementState.iterationCount,
                iterationHistory: preRefinementState.iterationHistory,
            };

            if (result.error !== 'Generation cancelled') {
                toastr.error(result.error);
            }
        }
    } catch (e) {
        // Restore pre-refinement state on error
        popupState.pipeline = {
            ...popupState.pipeline,
            iterationCount: preRefinementState.iterationCount,
            iterationHistory: preRefinementState.iterationHistory,
        };

        toastr.error((e as Error).message);
    } finally {
        popupState.isRefining = false;
        popupState.abortController = null;
        updateAllComponents();
    }
}

// ============================================================================
// UPDATE FUNCTIONS
// ============================================================================

function updateAllComponents(): void {
    updateCharacterSelect();
    updatePipelineNav();
    updateStageSection();
    updateResultsPanel();
    updateTokenEstimate();
    updateIterationIndicator();
    updateIterationHistory();
}

function updateCharacterSelect(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (container) {
        updateCharacterSelectState(
            container as HTMLElement,
            popupState.pipeline.character,
            popupState.pipeline.characterIndex,
        );
    }
}

function updatePipelineNav(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (container) {
        updatePipelineNavState(
            container as HTMLElement,
            popupState.pipeline.selectedStages,
            popupState.pipeline.stageStatus,
            popupState.activeStageView,
            !!popupState.pipeline.character && isApiReady(),
            popupState.isGenerating || popupState.isRefining,
        );
    }
}

function updateStageSection(): void {
    if (!popupElement || !popupState) return;

    const icon = popupElement.querySelector(`#${MODULE_NAME}_stage_icon`);
    const title = popupElement.querySelector(`#${MODULE_NAME}_stage_title`);

    if (icon) {
        icon.className = `fa-solid ${STAGE_ICONS[popupState.activeStageView]}`;
    }
    if (title) {
        title.textContent = STAGE_LABELS[popupState.activeStageView];
    }

    updateStageConfigUI();
}

function updateStageConfigUI(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (container) {
        updateStageConfigState(
            container as HTMLElement,
            popupState.activeStageView,
            popupState.pipeline.configs[popupState.activeStageView],
            popupState.isGenerating || popupState.isRefining,
        );
    }
}

function updateResultsPanel(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (container) {
        updateResultsPanelState(
            container as HTMLElement,
            popupState.activeStageView,
            popupState.pipeline.results[popupState.activeStageView],
            popupState.pipeline.stageStatus[popupState.activeStageView],
            popupState.isGenerating,
            getNextStage(popupState.pipeline, popupState.activeStageView),
            popupState.pipeline,
        );
    }
}

function updateIterationIndicator(): void {
    if (!popupElement || !popupState) return;

    const indicator = popupElement.querySelector(`#${MODULE_NAME}_iteration_indicator`);
    if (!indicator) return;

    if (popupState.pipeline.iterationCount > 0 || popupState.pipeline.isRefining) {
        indicator.classList.remove('hidden');
        indicator.innerHTML = `
      <i class="fa-solid fa-arrows-rotate"></i>
      Iteration #${popupState.pipeline.iterationCount + 1}
    `;
    } else {
        indicator.classList.add('hidden');
    }
}

function updateIterationHistory(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (container) {
        updateIterationHistoryState(
            container as HTMLElement,
            popupState.pipeline.iterationHistory,
            popupState.pipeline.iterationCount,
            popupState.historyLoaded,
        );
    }
}

async function updateTokenEstimate(): Promise<void> {
    if (!popupElement || !popupState) return;

    const tokenEl = popupElement.querySelector(`#${MODULE_NAME}_token_estimate`);
    if (!tokenEl) return;

    if (!popupState.pipeline.character) {
        tokenEl.innerHTML = '<i class="fa-solid fa-microchip"></i> Select a character';
        tokenEl.className = `${MODULE_NAME}_token_estimate`;
        return;
    }

    tokenEl.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
    tokenEl.className = `${MODULE_NAME}_token_estimate`;

    // Use refinement token count if we're in refinement mode
    let counts;
    if (popupState.pipeline.isRefining && popupState.pipeline.results.rewrite && popupState.pipeline.results.analyze) {
        counts = await getRefinementTokenCount(popupState.pipeline);
    } else {
        counts = await getStageTokenCount(popupState.pipeline, popupState.activeStageView);
    }

    if (!popupState || !popupElement) return;

    if (!counts) {
        tokenEl.innerHTML = '<i class="fa-solid fa-microchip"></i> --';
        tokenEl.className = `${MODULE_NAME}_token_estimate`;
        return;
    }

    let colorClass = '';
    if (counts.percentage > 100) colorClass = 'danger';
    else if (counts.percentage > 80) colorClass = 'warning';

    tokenEl.innerHTML = `<i class="fa-solid fa-microchip"></i> ${counts.promptTokens.toLocaleString()}t (${counts.percentage}%)`;
    tokenEl.className = `${MODULE_NAME}_token_estimate ${colorClass}`;
}
```

## FILE: src/ui/settings-modal.ts
```ts
// src/ui/settings-modal.ts
//
// Settings modal popup

import { MODULE_NAME, DEFAULT_SYSTEM_PROMPT, DEFAULT_REFINEMENT_PROMPT } from '../constants';
import {
    getSettings,
    updateSetting,
    updateGenerationConfig,
    updateSystemPrompt,
    resetSystemPrompt,
    updateRefinementPrompt,
    resetRefinementPrompt,
    setDebugMode,
    getPromptPresets,
    getSchemaPresets,
    deletePromptPreset,
    deleteSchemaPreset,
    exportCustomPresets,
    importPresets,
} from '../settings';
import { debugLog, getDebugLogs, clearDebugLogs, formatLogEntry, formatLogData, exportDebugInfo } from '../debug';
import type { GenerationConfig } from '../types';

// ============================================================================
// MAIN ENTRY
// ============================================================================

/**
 * Open the settings modal
 */
export async function openSettingsModal(onClose?: () => void): Promise<void> {
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const content = buildSettingsContent();

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: 'Save & Close',
        cancelButton: false,
    });

    popup.show().then(() => {
        onClose?.();
        debugLog('info', 'Settings modal closed', null);
    });

    // Wait for DOM
    await new Promise<void>(resolve => setTimeout(resolve, 0));

    initSettingsListeners();
    refreshModelSelects();

    debugLog('info', 'Settings modal opened', null);
}

// ============================================================================
// BUILD CONTENT
// ============================================================================

function buildSettingsContent(): string {
    const settings = getSettings();
    const config = settings.generationConfig;
    const { moment } = SillyTavern.libs;

    return `
    <div class="${MODULE_NAME}_settings_modal" id="${MODULE_NAME}_settings_modal">
      <div class="${MODULE_NAME}_settings_header">
        <i class="fa-solid fa-gear"></i>
        <span>Character Tools Settings</span>
      </div>

      <!-- Generation Settings -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-microchip"></i>
          <span>Generation</span>
        </div>

        <div class="${MODULE_NAME}_settings_row">
          <label class="${MODULE_NAME}_checkbox_label">
            <input
              type="checkbox"
              id="${MODULE_NAME}_use_current_settings"
              ${settings.useCurrentSettings ? 'checked' : ''}
            >
            <span>Use Current SillyTavern Settings</span>
          </label>
        </div>

        <div id="${MODULE_NAME}_custom_gen_config" class="${settings.useCurrentSettings ? 'hidden' : ''}">
          <div class="${MODULE_NAME}_settings_grid">
            <div class="${MODULE_NAME}_settings_field">
              <label>Source</label>
              <select id="${MODULE_NAME}_gen_source" class="text_pole"></select>
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Model</label>
              <select id="${MODULE_NAME}_gen_model" class="text_pole"></select>
            </div>
          </div>

          <div class="${MODULE_NAME}_settings_grid ${MODULE_NAME}_settings_grid_5">
            <div class="${MODULE_NAME}_settings_field">
              <label>Temp</label>
              <input type="number" id="${MODULE_NAME}_gen_temp" class="text_pole" value="${config.temperature}" min="0" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Max Tokens</label>
              <input type="number" id="${MODULE_NAME}_gen_tokens" class="text_pole" value="${config.maxTokens}" min="100" max="32000" step="100">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Freq Pen</label>
              <input type="number" id="${MODULE_NAME}_gen_freq" class="text_pole" value="${config.frequencyPenalty}" min="-2" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Pres Pen</label>
              <input type="number" id="${MODULE_NAME}_gen_pres" class="text_pole" value="${config.presencePenalty}" min="-2" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Top P</label>
              <input type="number" id="${MODULE_NAME}_gen_top_p" class="text_pole" value="${config.topP}" min="0" max="1" step="0.05">
            </div>
          </div>
        </div>
      </div>

      <!-- System Prompt -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-message"></i>
          <span>System Prompt</span>
        </div>

        <p class="${MODULE_NAME}_settings_hint">Base instructions applied to all stages</p>

        <textarea
          id="${MODULE_NAME}_system_prompt"
          class="text_pole ${MODULE_NAME}_system_prompt_textarea"
          rows="6"
        >${escapeHtml(settings.systemPrompt)}</textarea>

        <div class="${MODULE_NAME}_settings_row_spread">
          <span id="${MODULE_NAME}_system_prompt_chars">${settings.systemPrompt.length.toLocaleString()} chars</span>
          <button id="${MODULE_NAME}_reset_system_prompt" class="menu_button">
            <i class="fa-solid fa-rotate-left"></i>
            Reset
          </button>
        </div>
      </div>

      <!-- Refinement Prompt -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-arrows-rotate"></i>
          <span>Refinement Prompt</span>
        </div>

        <p class="${MODULE_NAME}_settings_hint">Template for iterative refinement. Placeholders: {{original_character}}, {{current_rewrite}}, {{current_analysis}}, {{score_results}}, {{iteration_number}}</p>

        <textarea
          id="${MODULE_NAME}_refinement_prompt"
          class="text_pole ${MODULE_NAME}_system_prompt_textarea"
          rows="8"
        >${escapeHtml(settings.refinementPrompt)}</textarea>

        <div class="${MODULE_NAME}_settings_row_spread">
          <span id="${MODULE_NAME}_refinement_prompt_chars">${settings.refinementPrompt.length.toLocaleString()} chars</span>
          <button id="${MODULE_NAME}_reset_refinement_prompt" class="menu_button">
            <i class="fa-solid fa-rotate-left"></i>
            Reset
          </button>
        </div>
      </div>

      <!-- Preset Management -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-bookmark"></i>
          <span>Presets</span>
        </div>

        <div class="${MODULE_NAME}_presets_grid">
          <div class="${MODULE_NAME}_preset_column">
            <h4>Prompt Presets</h4>
            <div id="${MODULE_NAME}_prompt_presets_list" class="${MODULE_NAME}_preset_list">
              ${renderPresetList('prompt')}
            </div>
          </div>
          <div class="${MODULE_NAME}_preset_column">
            <h4>Schema Presets</h4>
            <div id="${MODULE_NAME}_schema_presets_list" class="${MODULE_NAME}_preset_list">
              ${renderPresetList('schema')}
            </div>
          </div>
        </div>

        <div class="${MODULE_NAME}_settings_row_spread">
          <button id="${MODULE_NAME}_export_presets" class="menu_button">
            <i class="fa-solid fa-file-export"></i>
            Export Custom
          </button>
          <button id="${MODULE_NAME}_import_presets" class="menu_button">
            <i class="fa-solid fa-file-import"></i>
            Import
          </button>
        </div>
      </div>

      <!-- Keyboard Shortcuts -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-keyboard"></i>
          <span>Keyboard Shortcuts</span>
        </div>

        <div class="${MODULE_NAME}_shortcuts_list">
          <div class="${MODULE_NAME}_shortcut_item">
            <kbd>Ctrl</kbd> + <kbd>Enter</kbd>
            <span>Run current stage</span>
          </div>
          <div class="${MODULE_NAME}_shortcut_item">
            <kbd>Escape</kbd>
            <span>Cancel generation</span>
          </div>
        </div>
      </div>

      <!-- Debug -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-bug"></i>
          <span>Debug</span>
        </div>

        <div class="${MODULE_NAME}_settings_row">
          <label class="${MODULE_NAME}_checkbox_label">
            <input
              type="checkbox"
              id="${MODULE_NAME}_debug_mode"
              ${settings.debugMode ? 'checked' : ''}
            >
            <span>Enable Debug Logging</span>
          </label>
        </div>

        <div class="${MODULE_NAME}_debug_actions">
          <button id="${MODULE_NAME}_view_logs" class="menu_button">
            <i class="fa-solid fa-list"></i>
            View Logs
          </button>
          <button id="${MODULE_NAME}_clear_logs" class="menu_button">
            <i class="fa-solid fa-trash"></i>
            Clear
          </button>
          <button id="${MODULE_NAME}_copy_debug_info" class="menu_button">
            <i class="fa-solid fa-copy"></i>
            Copy Info
          </button>
        </div>

        <div id="${MODULE_NAME}_debug_log_viewer" class="${MODULE_NAME}_debug_log_viewer hidden">
          <div id="${MODULE_NAME}_debug_log_list" class="${MODULE_NAME}_debug_log_list"></div>
          <pre id="${MODULE_NAME}_debug_log_detail" class="${MODULE_NAME}_debug_log_detail">Select a log entry</pre>
        </div>
      </div>

      <!-- Footer -->
      <div class="${MODULE_NAME}_settings_footer">
        <span class="${MODULE_NAME}_settings_version">v1.0.0 • Last updated: ${moment().format('YYYY-MM-DD HH:mm:ss')}</span>
      </div>
    </div>
  `;
}

function renderPresetList(type: 'prompt' | 'schema'): string {
    const presets = type === 'prompt' ? getPromptPresets() : getSchemaPresets();

    if (presets.length === 0) {
        return `<div class="${MODULE_NAME}_preset_empty">No presets</div>`;
    }

    return presets.map(preset => `
    <div class="${MODULE_NAME}_preset_item ${preset.isBuiltin ? 'builtin' : ''}" data-id="${preset.id}">
      <span class="${MODULE_NAME}_preset_name">
        ${preset.isBuiltin ? '<i class="fa-solid fa-lock"></i>' : ''}
        ${escapeHtml(preset.name)}
      </span>
      ${!preset.isBuiltin ? `
        <button class="${MODULE_NAME}_preset_delete" data-type="${type}" data-id="${preset.id}" title="Delete">
          <i class="fa-solid fa-trash"></i>
        </button>
      ` : ''}
    </div>
  `).join('');
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function initSettingsListeners(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    // Use current settings toggle
    const useCurrentCheckbox = modal.querySelector(`#${MODULE_NAME}_use_current_settings`) as HTMLInputElement;
    const customConfig = modal.querySelector(`#${MODULE_NAME}_custom_gen_config`);

    useCurrentCheckbox?.addEventListener('change', () => {
        updateSetting('useCurrentSettings', useCurrentCheckbox.checked);
        customConfig?.classList.toggle('hidden', useCurrentCheckbox.checked);
    });

    // Generation config inputs
    const genSource = modal.querySelector(`#${MODULE_NAME}_gen_source`) as HTMLSelectElement;
    const genModel = modal.querySelector(`#${MODULE_NAME}_gen_model`) as HTMLSelectElement;
    const genTemp = modal.querySelector(`#${MODULE_NAME}_gen_temp`) as HTMLInputElement;
    const genTokens = modal.querySelector(`#${MODULE_NAME}_gen_tokens`) as HTMLInputElement;
    const genFreq = modal.querySelector(`#${MODULE_NAME}_gen_freq`) as HTMLInputElement;
    const genPres = modal.querySelector(`#${MODULE_NAME}_gen_pres`) as HTMLInputElement;
    const genTopP = modal.querySelector(`#${MODULE_NAME}_gen_top_p`) as HTMLInputElement;

    genSource?.addEventListener('change', () => {
        updateGenerationConfig({ source: genSource.value });
        populateModelSelect(genSource.value);
    });

    genModel?.addEventListener('change', () => {
        updateGenerationConfig({ model: genModel.value });
    });

    const handleNumberInput = (input: HTMLInputElement, key: keyof GenerationConfig, isInt = false) => {
        input?.addEventListener('change', () => {
            const val = isInt ? parseInt(input.value, 10) : parseFloat(input.value);
            if (!isNaN(val)) {
                updateGenerationConfig({ [key]: val });
            }
        });
    };

    handleNumberInput(genTemp, 'temperature');
    handleNumberInput(genTokens, 'maxTokens', true);
    handleNumberInput(genFreq, 'frequencyPenalty');
    handleNumberInput(genPres, 'presencePenalty');
    handleNumberInput(genTopP, 'topP');

    // System prompt
    const systemPromptTextarea = modal.querySelector(`#${MODULE_NAME}_system_prompt`) as HTMLTextAreaElement;
    const systemPromptChars = modal.querySelector(`#${MODULE_NAME}_system_prompt_chars`);
    const resetSystemPromptBtn = modal.querySelector(`#${MODULE_NAME}_reset_system_prompt`);

    systemPromptTextarea?.addEventListener('input', () => {
        updateSystemPrompt(systemPromptTextarea.value);
        if (systemPromptChars) {
            systemPromptChars.textContent = `${systemPromptTextarea.value.length.toLocaleString()} chars`;
        }
    });

    resetSystemPromptBtn?.addEventListener('click', () => {
        resetSystemPrompt();
        if (systemPromptTextarea) {
            systemPromptTextarea.value = DEFAULT_SYSTEM_PROMPT;
        }
        if (systemPromptChars) {
            systemPromptChars.textContent = `${DEFAULT_SYSTEM_PROMPT.length.toLocaleString()} chars`;
        }
        toastr.info('System prompt reset to default');
    });

    // Refinement prompt
    const refinementPromptTextarea = modal.querySelector(`#${MODULE_NAME}_refinement_prompt`) as HTMLTextAreaElement;
    const refinementPromptChars = modal.querySelector(`#${MODULE_NAME}_refinement_prompt_chars`);
    const resetRefinementPromptBtn = modal.querySelector(`#${MODULE_NAME}_reset_refinement_prompt`);

    refinementPromptTextarea?.addEventListener('input', () => {
        updateRefinementPrompt(refinementPromptTextarea.value);
        if (refinementPromptChars) {
            refinementPromptChars.textContent = `${refinementPromptTextarea.value.length.toLocaleString()} chars`;
        }
    });

    resetRefinementPromptBtn?.addEventListener('click', () => {
        resetRefinementPrompt();
        if (refinementPromptTextarea) {
            refinementPromptTextarea.value = DEFAULT_REFINEMENT_PROMPT;
        }
        if (refinementPromptChars) {
            refinementPromptChars.textContent = `${DEFAULT_REFINEMENT_PROMPT.length.toLocaleString()} chars`;
        }
        toastr.info('Refinement prompt reset to default');
    });

    // Preset management
    modal.addEventListener('click', (e) => {
        const deleteBtn = (e.target as HTMLElement).closest(`.${MODULE_NAME}_preset_delete`);
        if (deleteBtn) {
            const type = deleteBtn.getAttribute('data-type') as 'prompt' | 'schema';
            const id = deleteBtn.getAttribute('data-id');
            if (type && id) {
                handleDeletePreset(type, id);
            }
        }
    });

    const exportPresetsBtn = modal.querySelector(`#${MODULE_NAME}_export_presets`);
    const importPresetsBtn = modal.querySelector(`#${MODULE_NAME}_import_presets`);

    exportPresetsBtn?.addEventListener('click', () => {
        const json = exportCustomPresets();
        navigator.clipboard.writeText(json);
        toastr.success('Custom presets copied to clipboard');
    });

    importPresetsBtn?.addEventListener('click', async () => {
        try {
            const json = await navigator.clipboard.readText();
            const result = importPresets(json);

            if (result.errors.length > 0) {
                toastr.error(result.errors.join('\n'));
            } else {
                toastr.success(`Imported ${result.prompts} prompts, ${result.schemas} schemas`);
                refreshPresetLists();
            }
        } catch {
            toastr.error('Failed to read clipboard');
        }
    });

    // Debug
    const debugModeCheckbox = modal.querySelector(`#${MODULE_NAME}_debug_mode`) as HTMLInputElement;
    const viewLogsBtn = modal.querySelector(`#${MODULE_NAME}_view_logs`);
    const clearLogsBtn = modal.querySelector(`#${MODULE_NAME}_clear_logs`);
    const copyDebugBtn = modal.querySelector(`#${MODULE_NAME}_copy_debug_info`);
    const logViewer = modal.querySelector(`#${MODULE_NAME}_debug_log_viewer`);

    debugModeCheckbox?.addEventListener('change', () => {
        setDebugMode(debugModeCheckbox.checked);
        toastr.info(`Debug mode ${debugModeCheckbox.checked ? 'enabled' : 'disabled'}`);
    });

    viewLogsBtn?.addEventListener('click', () => {
        logViewer?.classList.toggle('hidden');
        if (!logViewer?.classList.contains('hidden')) {
            refreshDebugLogs();
        }
    });

    clearLogsBtn?.addEventListener('click', () => {
        clearDebugLogs();
        refreshDebugLogs();
        toastr.info('Debug logs cleared');
    });

    copyDebugBtn?.addEventListener('click', () => {
        navigator.clipboard.writeText(exportDebugInfo());
        toastr.success('Debug info copied to clipboard');
    });
}

function handleDeletePreset(type: 'prompt' | 'schema', id: string): void {
    const deletedId = type === 'prompt' ? deletePromptPreset(id) : deleteSchemaPreset(id);

    if (deletedId) {
        toastr.success('Preset deleted');
        refreshPresetLists();
    } else {
        toastr.error('Cannot delete builtin preset');
    }
}

function refreshPresetLists(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    const promptList = modal.querySelector(`#${MODULE_NAME}_prompt_presets_list`);
    const schemaList = modal.querySelector(`#${MODULE_NAME}_schema_presets_list`);

    if (promptList) {
        promptList.innerHTML = renderPresetList('prompt');
    }
    if (schemaList) {
        schemaList.innerHTML = renderPresetList('schema');
    }
}

function refreshDebugLogs(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    const logList = modal.querySelector(`#${MODULE_NAME}_debug_log_list`);
    const logDetail = modal.querySelector(`#${MODULE_NAME}_debug_log_detail`);

    if (!logList || !logDetail) return;

    const logs = getDebugLogs();

    logList.innerHTML = logs.length
        ? logs.map((entry, i) => `
        <div class="${MODULE_NAME}_debug_log_entry" data-index="${i}">
          ${formatLogEntry(entry)}
        </div>
      `).join('')
        : `<div class="${MODULE_NAME}_debug_log_empty">No logs</div>`;

    // Click handler for log entries
    logList.querySelectorAll(`.${MODULE_NAME}_debug_log_entry`).forEach(el => {
        el.addEventListener('click', () => {
            const index = parseInt((el as HTMLElement).dataset.index || '0', 10);
            const entry = logs[index];
            if (entry && logDetail) {
                logDetail.textContent = formatLogData(entry.data);
            }
        });
    });
}

// ============================================================================
// MODEL SELECTS
// ============================================================================

function refreshModelSelects(): void {
    const settings = getSettings();
    populateSourceSelect(settings.generationConfig.source);
    populateModelSelect(settings.generationConfig.source, settings.generationConfig.model);
}

function populateSourceSelect(currentSource: string): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    const sourceSelect = modal?.querySelector(`#${MODULE_NAME}_gen_source`) as HTMLSelectElement;
    if (!sourceSelect) return;

    sourceSelect.innerHTML = '';

    const stSourceSelect = document.getElementById('chat_completion_source') as HTMLSelectElement;

    if (stSourceSelect) {
        Array.from(stSourceSelect.options).forEach((opt: HTMLOptionElement) => {
            if (opt.value) {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.textContent || opt.value;
                sourceSelect.appendChild(option);
            }
        });
    }

    if (sourceSelect.options.length === 0) {
        ['openrouter', 'openai', 'claude', 'makersuite', 'mistralai', 'groq'].forEach(src => {
            const option = document.createElement('option');
            option.value = src;
            option.textContent = src;
            sourceSelect.appendChild(option);
        });
    }

    sourceSelect.value = currentSource;
}

function populateModelSelect(source: string, currentModel?: string): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    const modelSelect = modal?.querySelector(`#${MODULE_NAME}_gen_model`) as HTMLSelectElement;
    if (!modelSelect) return;

    modelSelect.innerHTML = '';

    const selectIdMap: Record<string, string> = {
        openrouter: 'model_openrouter_select',
        openai: 'model_openai_select',
        claude: 'model_claude_select',
        makersuite: 'model_google_select',
        google: 'model_google_select',
        mistralai: 'model_mistralai_select',
        cohere: 'model_cohere_select',
        perplexity: 'model_perplexity_select',
        groq: 'model_groq_select',
        ai21: 'model_ai21_select',
        deepseek: 'model_deepseek_select',
        custom: 'model_custom_select',
    };

    const stSelect = selectIdMap[source] ? document.getElementById(selectIdMap[source]) as HTMLSelectElement : null;

    if (stSelect?.options.length) {
        Array.from(stSelect.options).forEach((opt: HTMLOptionElement) => {
            if (opt.value) {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.textContent || opt.value;
                modelSelect.appendChild(option);
            }
        });
    } else {
        const option = document.createElement('option');
        option.value = currentModel || '';
        option.textContent = currentModel || `No models for ${source}`;
        modelSelect.appendChild(option);
    }

    if (currentModel && Array.from(modelSelect.options).some(o => o.value === currentModel)) {
        modelSelect.value = currentModel;
    } else if (modelSelect.options.length) {
        modelSelect.value = modelSelect.options[0].value;
        updateGenerationConfig({ model: modelSelect.options[0].value });
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/character-select.ts
```ts
// src/ui/components/character-select.ts
//
// Character search and preview component

import { MODULE_NAME } from '../../constants';
import { getPopulatedFields } from '../../pipeline';
import type { Character, PopulatedField } from '../../types';

// ============================================================================
// TOKEN CACHE
// ============================================================================

const tokenCache = new Map<string, number>();

function getTokenCacheKey(content: string): string {
    // Simple hash for cache key
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return `${hash}_${content.length}`;
}

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the character select component
 */
export function renderCharacterSelect(
    characters: Character[],
    selectedIndex: number | null,
): string {
    const selectedChar = selectedIndex !== null ? characters[selectedIndex] : null;

    return `
    <div class="${MODULE_NAME}_char_select">
      <!-- Search -->
      <div class="${MODULE_NAME}_search_wrapper ${selectedChar ? 'hidden' : ''}">
        <div class="${MODULE_NAME}_search_container">
          <i class="fa-solid fa-search ${MODULE_NAME}_search_icon"></i>
          <input
            type="text"
            id="${MODULE_NAME}_char_search"
            class="text_pole ${MODULE_NAME}_search_input"
            placeholder="Search characters..."
            autocomplete="off"
          >
        </div>
        <div id="${MODULE_NAME}_char_dropdown" class="${MODULE_NAME}_dropdown hidden"></div>
      </div>

      <!-- Selected Character Preview -->
      ${selectedChar ? renderCharacterPreview(selectedChar) : ''}
    </div>
  `;
}

/**
 * Render character preview with expandable fields
 */
function renderCharacterPreview(char: Character): string {
    const { getThumbnailUrl } = SillyTavern.getContext();
    const fields = getPopulatedFields(char);

    const avatar = getThumbnailUrl('avatar', char.avatar);

    return `
    <div class="${MODULE_NAME}_char_preview" id="${MODULE_NAME}_char_preview">
      <div class="${MODULE_NAME}_char_header">
        <img
          class="${MODULE_NAME}_char_avatar"
          src="${avatar}"
          alt=""
          onerror="this.src='/img/ai4.png'"
        >
        <div class="${MODULE_NAME}_char_info">
          <div class="${MODULE_NAME}_char_name">${escapeHtml(char.name)}</div>
          <div class="${MODULE_NAME}_char_meta">
            ${fields.length} fields • <span id="${MODULE_NAME}_total_tokens">counting...</span>
          </div>
        </div>
        <button id="${MODULE_NAME}_char_clear" class="${MODULE_NAME}_icon_btn" title="Clear selection">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="${MODULE_NAME}_char_fields">
        ${fields.map(f => renderFieldRow(f)).join('')}
      </div>
    </div>
  `;
}

/**
 * Render a single field row with expand/collapse
 */
function renderFieldRow(field: PopulatedField): string {
    return `
    <div class="${MODULE_NAME}_field_row">
      <div class="${MODULE_NAME}_field_header ${MODULE_NAME}_field_toggle" data-field="${field.key}">
        <i class="fa-solid fa-chevron-right"></i>
        <span class="${MODULE_NAME}_field_label">${field.label}</span>
        <span class="${MODULE_NAME}_field_tokens" data-field="${field.key}">...</span>
      </div>
      <div class="${MODULE_NAME}_field_content hidden" id="${MODULE_NAME}_field_content_${field.key}">
        <div class="${MODULE_NAME}_field_text">${escapeHtml(field.value)}</div>
      </div>
    </div>
  `;
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update character select state without full re-render
 */
export function updateCharacterSelectState(
    container: HTMLElement,
    character: Character | null,
    _characterIndex: number | null,
): void {
    const searchWrapper = container.querySelector(`.${MODULE_NAME}_search_wrapper`);
    const existingPreview = container.querySelector(`#${MODULE_NAME}_char_preview`);

    if (character) {
        searchWrapper?.classList.add('hidden');

        if (!existingPreview) {
            const previewHtml = renderCharacterPreview(character);
            const searchEl = container.querySelector(`.${MODULE_NAME}_search_wrapper`);
            if (searchEl) {
                searchEl.insertAdjacentHTML('afterend', previewHtml);
            }
        }
    } else {
        searchWrapper?.classList.remove('hidden');
        existingPreview?.remove();

        const searchInput = container.querySelector(`#${MODULE_NAME}_char_search`) as HTMLInputElement;
        if (searchInput) {
            searchInput.value = '';
        }
    }
}

/**
 * Update token counts for character fields and total.
 * Uses parallel execution and caching for performance.
 */
export async function updateFieldTokenCounts(container: HTMLElement, fields: PopulatedField[]): Promise<void> {
    const { getTokenCountAsync } = SillyTavern.getContext();

    // Build array of promises for parallel execution
    const tokenPromises = fields.map(async (field) => {
        const cacheKey = getTokenCacheKey(field.value);

        // Check cache first
        if (tokenCache.has(cacheKey)) {
            return { field, tokens: tokenCache.get(cacheKey)! };
        }

        try {
            const tokens = await getTokenCountAsync(field.value);
            tokenCache.set(cacheKey, tokens);
            return { field, tokens };
        } catch {
            return { field, tokens: null };
        }
    });

    // Execute all in parallel
    const results = await Promise.all(tokenPromises);

    // Update UI with results
    let totalTokens = 0;

    for (const { field, tokens } of results) {
        const tokenSpan = container.querySelector(`.${MODULE_NAME}_field_tokens[data-field="${field.key}"]`);
        if (tokenSpan) {
            if (tokens !== null) {
                totalTokens += tokens;
                tokenSpan.textContent = `${tokens.toLocaleString()}t`;
            } else {
                tokenSpan.textContent = '?';
            }
        }
    }

    // Update total
    const totalSpan = container.querySelector(`#${MODULE_NAME}_total_tokens`);
    if (totalSpan) {
        totalSpan.textContent = `${totalTokens.toLocaleString()} tokens`;
    }
}

/**
 * Render dropdown items - called from popup.ts
 */
export function renderDropdownItems(
    results: Array<{ char: Character; index: number }>,
    dropdown: HTMLElement,
    selectedIndex: number,
): void {
    const { getThumbnailUrl } = SillyTavern.getContext();

    if (results.length === 0) {
        dropdown.innerHTML = `<div class="${MODULE_NAME}_dropdown_empty">No characters found</div>`;
        return;
    }

    dropdown.innerHTML = results.map(({ char, index }, i) => {
        const avatar = getThumbnailUrl('avatar', char.avatar);
        const isSelected = i === selectedIndex;
        const descPreview = (char.description || 'No description').substring(0, 80);

        return `
      <div class="${MODULE_NAME}_dropdown_item ${isSelected ? 'selected' : ''}" data-index="${index}">
        <img class="${MODULE_NAME}_dropdown_avatar" src="${avatar}" alt="" onerror="this.src='/img/ai4.png'">
        <div class="${MODULE_NAME}_dropdown_info">
          <span class="${MODULE_NAME}_dropdown_name">${escapeHtml(char.name)}</span>
          <span class="${MODULE_NAME}_dropdown_desc">${escapeHtml(descPreview)}${descPreview.length >= 80 ? '...' : ''}</span>
        </div>
      </div>
    `;
    }).join('');

    // Scroll selected item into view
    if (selectedIndex >= 0) {
        const selectedItem = dropdown.querySelector(`.${MODULE_NAME}_dropdown_item.selected`);
        selectedItem?.scrollIntoView({ block: 'nearest' });
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/pipeline-nav.ts
```ts
// src/ui/components/pipeline-nav.ts
//
// Pipeline stage selection and navigation component

import { MODULE_NAME, STAGES, STAGE_LABELS, STAGE_ICONS } from '../../constants';
import type { StageName, StageStatus } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the pipeline navigation component
 */
export function renderPipelineNav(
    selectedStages: StageName[],
    stageStatus: Record<StageName, StageStatus>,
    activeStage: StageName,
    hasCharacter: boolean,
): string {
    return `
    <div class="${MODULE_NAME}_pipeline_nav">
      <!-- Stage Selection -->
      <div class="${MODULE_NAME}_stage_row">
        ${STAGES.map((stage, i) => renderStageNode(
        stage,
        selectedStages.includes(stage),
        stageStatus[stage],
        stage === activeStage,
        i < STAGES.length - 1,
    )).join('')}
      </div>

      <!-- Action Buttons -->
      <div class="${MODULE_NAME}_pipeline_actions">
        <button
          id="${MODULE_NAME}_run_selected_btn"
          class="menu_button"
          ${!hasCharacter ? 'disabled' : ''}
        >
          <i class="fa-solid fa-play"></i>
          <span>Run Selected</span>
        </button>
        <button
          id="${MODULE_NAME}_run_all_btn"
          class="menu_button"
          ${!hasCharacter ? 'disabled' : ''}
        >
          <i class="fa-solid fa-forward"></i>
          <span>Run All</span>
        </button>
        <button
          id="${MODULE_NAME}_reset_pipeline_btn"
          class="menu_button"
        >
          <i class="fa-solid fa-rotate-left"></i>
          <span>Reset</span>
        </button>
      </div>
    </div>
  `;
}

/**
 * Render a single stage node
 */
function renderStageNode(
    stage: StageName,
    isSelected: boolean,
    status: StageStatus,
    isActive: boolean,
    hasConnector: boolean,
): string {
    const statusIcon = getStatusIcon(status);

    return `
    <div class="${MODULE_NAME}_stage_node ${isActive ? 'active' : ''} ${MODULE_NAME}_stage_${status}">
      <input
        type="checkbox"
        class="${MODULE_NAME}_stage_checkbox"
        id="${MODULE_NAME}_stage_cb_${stage}"
        data-stage="${stage}"
        ${isSelected ? 'checked' : ''}
      >
      <button
        class="${MODULE_NAME}_stage_btn ${isActive ? 'active' : ''}"
        data-stage="${stage}"
        title="${STAGE_LABELS[stage]}"
      >
        <i class="fa-solid ${STAGE_ICONS[stage]}"></i>
        <span>${STAGE_LABELS[stage]}</span>
        ${statusIcon ? `<i class="fa-solid ${statusIcon} ${MODULE_NAME}_status_icon"></i>` : ''}
      </button>
      ${hasConnector ? `<div class="${MODULE_NAME}_stage_connector ${isSelected ? 'active' : ''}"></div>` : ''}
    </div>
  `;
}

function getStatusIcon(status: StageStatus): string | null {
    switch (status) {
        case 'complete': return 'fa-check';
        case 'running': return 'fa-spinner fa-spin';
        case 'skipped': return 'fa-forward';
        default: return null;
    }
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update pipeline nav state without full re-render
 */
export function updatePipelineNavState(
    container: HTMLElement,
    selectedStages: StageName[],
    stageStatus: Record<StageName, StageStatus>,
    activeStage: StageName,
    hasCharacter: boolean,
    isGenerating: boolean,
): void {
    // Update checkboxes and buttons
    for (const stage of STAGES) {
        const checkbox = container.querySelector(`#${MODULE_NAME}_stage_cb_${stage}`) as HTMLInputElement;
        const btn = container.querySelector(`.${MODULE_NAME}_stage_btn[data-stage="${stage}"]`);
        const node = container.querySelector(`.${MODULE_NAME}_stage_node:has([data-stage="${stage}"])`);

        if (checkbox) {
            checkbox.checked = selectedStages.includes(stage);
        }

        if (btn) {
            btn.classList.toggle('active', stage === activeStage);
        }

        if (node) {
            node.classList.toggle('active', stage === activeStage);

            // Update status classes
            for (const s of ['pending', 'running', 'complete', 'skipped']) {
                node.classList.toggle(`${MODULE_NAME}_stage_${s}`, stageStatus[stage] === s);
            }
        }

        // Update connector
        const connector = node?.querySelector(`.${MODULE_NAME}_stage_connector`);
        connector?.classList.toggle('active', selectedStages.includes(stage));
    }

    // Update action buttons
    const runSelectedBtn = container.querySelector(`#${MODULE_NAME}_run_selected_btn`) as HTMLButtonElement;
    const runAllBtn = container.querySelector(`#${MODULE_NAME}_run_all_btn`) as HTMLButtonElement;
    const resetBtn = container.querySelector(`#${MODULE_NAME}_reset_pipeline_btn`) as HTMLButtonElement;

    if (runSelectedBtn) runSelectedBtn.disabled = !hasCharacter || isGenerating;
    if (runAllBtn) runAllBtn.disabled = !hasCharacter || isGenerating;
    if (resetBtn) resetBtn.disabled = isGenerating;
}
```

## FILE: src/ui/components/stage-config.ts
```ts
// src/ui/components/stage-config.ts
//
// Stage configuration component - prompt/schema selection and editing

import { MODULE_NAME, STAGE_LABELS } from '../../constants';
import { getPromptPresets, getSchemaPresets, getPromptPreset, getSchemaPreset, savePromptPreset, saveSchemaPreset } from '../../settings';
import { validateSchema, autoFixSchema, generateSchemaFromDescription } from '../../schema';
import type { StageName, StageConfig, PromptPreset, SchemaPreset } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

export function renderStageConfig(
    stage: StageName,
    config: StageConfig,
    tokenEstimate: { tokens: number; percentage: number } | null,
): string {
    const promptPresets = getPromptPresets(stage);
    const schemaPresets = getSchemaPresets(stage);

    // Get current prompt content
    let promptContent = config.customPrompt;
    if (config.promptPresetId) {
        const preset = getPromptPreset(config.promptPresetId);
        if (preset) promptContent = preset.prompt;
    }

    // Get current schema content
    let schemaContent = config.customSchema;
    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) schemaContent = JSON.stringify(preset.schema, null, 2);
    }

    // Validate schema if present
    let schemaStatus = '';
    let schemaValidation: { valid: boolean; error?: string; warnings?: string[] } = { valid: true };
    if (config.useStructuredOutput && schemaContent.trim()) {
        schemaValidation = validateSchema(schemaContent);
        if (!schemaValidation.valid) {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status error"><i class="fa-solid fa-circle-xmark"></i> ${escapeHtml(schemaValidation.error || 'Invalid schema')}</div>`;
        } else if (schemaValidation.warnings?.length) {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status warning"><i class="fa-solid fa-triangle-exclamation"></i> ${schemaValidation.warnings.length} warning(s)</div>`;
        } else {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status success"><i class="fa-solid fa-circle-check"></i> Valid schema</div>`;
        }
    }

    // Token estimate display
    let tokenDisplay = '<i class="fa-solid fa-microchip"></i> Select a character';
    let tokenClass = '';
    if (tokenEstimate) {
        tokenDisplay = `<i class="fa-solid fa-microchip"></i> ~${tokenEstimate.tokens.toLocaleString()} tokens (${tokenEstimate.percentage}%)`;
        if (tokenEstimate.percentage > 80) tokenClass = 'danger';
        else if (tokenEstimate.percentage > 50) tokenClass = 'warning';
    }

    // Check if current content differs from selected preset (for save button state)
    const promptDiffersFromPreset = config.promptPresetId
        ? getPromptPreset(config.promptPresetId)?.prompt !== promptContent
        : promptContent.trim().length > 0;

    const schemaDiffersFromPreset = config.schemaPresetId
        ? JSON.stringify(getSchemaPreset(config.schemaPresetId)?.schema, null, 2) !== schemaContent
        : schemaContent.trim().length > 0;

    // Show fix button if schema has warnings or is invalid but parseable
    const showFixButton = config.useStructuredOutput && schemaContent.trim() &&
        (schemaValidation.warnings?.length || !schemaValidation.valid);

    return `
    <div class="${MODULE_NAME}_stage_config">
      <!-- Prompt Section -->
      <div class="${MODULE_NAME}_config_group">
        <div class="${MODULE_NAME}_config_header">
          <span class="${MODULE_NAME}_config_label">Prompt</span>
          <div class="${MODULE_NAME}_config_header_actions">
            <button
              id="${MODULE_NAME}_save_prompt_preset_btn"
              class="${MODULE_NAME}_icon_btn"
              title="Save as Preset"
              ${!promptDiffersFromPreset ? 'disabled' : ''}
            >
              <i class="fa-solid fa-floppy-disk"></i>
            </button>
            <select id="${MODULE_NAME}_prompt_preset_select" class="${MODULE_NAME}_preset_select">
              <option value="">Custom</option>
              ${renderPresetOptions(promptPresets, config.promptPresetId)}
            </select>
          </div>
        </div>
        <textarea
          id="${MODULE_NAME}_custom_prompt"
          class="${MODULE_NAME}_prompt_textarea text_pole"
          placeholder="Enter your prompt for the ${STAGE_LABELS[stage]} stage..."
        >${escapeHtml(promptContent)}</textarea>
        <div class="${MODULE_NAME}_config_footer">
          <span class="${MODULE_NAME}_char_count">${promptContent.length.toLocaleString()} chars</span>
        </div>
      </div>

      <!-- Structured Output Toggle -->
      <div class="${MODULE_NAME}_config_group">
        <label class="${MODULE_NAME}_checkbox_label">
          <input
            type="checkbox"
            id="${MODULE_NAME}_use_structured"
            ${config.useStructuredOutput ? 'checked' : ''}
          >
          <span>Use Structured Output (JSON Schema)</span>
        </label>
      </div>

      <!-- Schema Section -->
      <div class="${MODULE_NAME}_schema_section ${config.useStructuredOutput ? '' : 'hidden'}">
        <div class="${MODULE_NAME}_config_header">
          <span class="${MODULE_NAME}_config_label">JSON Schema</span>
          <div class="${MODULE_NAME}_config_header_actions">
            <button
              id="${MODULE_NAME}_save_schema_preset_btn"
              class="${MODULE_NAME}_icon_btn"
              title="Save as Preset"
              ${!schemaDiffersFromPreset || !schemaContent.trim() ? 'disabled' : ''}
            >
              <i class="fa-solid fa-floppy-disk"></i>
            </button>
            <select id="${MODULE_NAME}_schema_preset_select" class="${MODULE_NAME}_preset_select">
              <option value="">Custom</option>
              ${renderPresetOptions(schemaPresets, config.schemaPresetId)}
            </select>
          </div>
        </div>
        <textarea
          id="${MODULE_NAME}_custom_schema"
          class="${MODULE_NAME}_schema_textarea text_pole"
          placeholder='{"name": "MySchema", "value": {"type": "object", ...}}'
        >${escapeHtml(schemaContent)}</textarea>
        ${schemaStatus}

        <!-- Schema Actions -->
        <div class="${MODULE_NAME}_schema_actions">
          <button
            id="${MODULE_NAME}_generate_schema_btn"
            class="menu_button menu_button_icon"
            title="Generate schema from description"
          >
            <i class="fa-solid fa-wand-magic-sparkles"></i>
            <span>Generate</span>
          </button>
          <button
            id="${MODULE_NAME}_validate_schema_btn"
            class="menu_button menu_button_icon"
            title="Validate schema"
            ${!schemaContent.trim() ? 'disabled' : ''}
          >
            <i class="fa-solid fa-check-double"></i>
            <span>Validate</span>
          </button>
          <button
            id="${MODULE_NAME}_fix_schema_btn"
            class="menu_button menu_button_icon"
            title="Auto-fix schema (adds additionalProperties: false, etc.)"
            ${!showFixButton ? 'disabled' : ''}
          >
            <i class="fa-solid fa-wrench"></i>
            <span>Auto-Fix</span>
          </button>
          <button
            id="${MODULE_NAME}_format_schema_btn"
            class="menu_button menu_button_icon"
            title="Format/prettify JSON"
            ${!schemaContent.trim() ? 'disabled' : ''}
          >
            <i class="fa-solid fa-align-left"></i>
            <span>Format</span>
          </button>
        </div>
      </div>

      <!-- Actions -->
      <div class="${MODULE_NAME}_config_actions">
        <div id="${MODULE_NAME}_token_estimate" class="${MODULE_NAME}_token_estimate ${tokenClass}">
          ${tokenDisplay}
        </div>
      </div>
    </div>
  `;
}


// ============================================================================
// UPDATE STATE
// ============================================================================

/**
 * Handle schema generation from description
 */
export async function handleGenerateSchema(): Promise<string | null> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    const description = await Popup.show.input(
        'Generate Schema',
        'Describe the structure you want (e.g., <q>"scores for each field 1-10, list of suggestions, overall rating"</q>):\n',
        '',
    );

    if (description === null || description === POPUP_RESULT.CANCELLED || !description.trim()) {
        return null;
    }

    // Show loading overlay
    showSchemaGenerationLoading(true);

    try {
        toastr.info('Generating schema...');

        const result = await generateSchemaFromDescription(description);

        if (result.success) {
            toastr.success('Schema generated!');
            return result.schema!;
        } else {
            toastr.error(result.error || 'Generation failed');
            // Return the broken schema anyway so they can see/fix it
            return result.schema || null;
        }
    } finally {
        showSchemaGenerationLoading(false);
    }
}

/**
 * Show/hide loading overlay for schema generation
 */
function showSchemaGenerationLoading(show: boolean): void {
    const existingOverlay = document.querySelector(`.${MODULE_NAME}_loading_overlay`);

    if (show && !existingOverlay) {
        const overlay = document.createElement('div');
        overlay.className = `${MODULE_NAME}_loading_overlay`;
        overlay.innerHTML = `
            <div class="${MODULE_NAME}_loading_content">
                <i class="fa-solid fa-spinner fa-spin fa-2x"></i>
                <p>Generating schema...</p>
            </div>
        `;
        document.body.appendChild(overlay);
    } else if (!show && existingOverlay) {
        existingOverlay.remove();
    }
}

export function updateStageConfigState(
    container: HTMLElement,
    stage: StageName,
    config: StageConfig,
    isGenerating: boolean,
): void {
    const promptPresets = getPromptPresets(stage);
    const schemaPresets = getSchemaPresets(stage);

    // Update prompt preset select
    const promptSelect = container.querySelector(`#${MODULE_NAME}_prompt_preset_select`) as HTMLSelectElement;
    if (promptSelect) {
        promptSelect.innerHTML = `<option value="">Custom</option>${renderPresetOptions(promptPresets, config.promptPresetId)}`;
        promptSelect.value = config.promptPresetId || '';
        promptSelect.disabled = isGenerating;
    }

    // Update prompt textarea
    const promptTextarea = container.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
    if (promptTextarea) {
        let promptContent = config.customPrompt;
        if (config.promptPresetId) {
            const preset = getPromptPreset(config.promptPresetId);
            if (preset) promptContent = preset.prompt;
        }
        // Only update if different to preserve cursor position
        if (promptTextarea.value !== promptContent) {
            promptTextarea.value = promptContent;
        }
        promptTextarea.disabled = isGenerating;

        // Update char count
        const charCount = container.querySelector(`.${MODULE_NAME}_char_count`);
        if (charCount) {
            charCount.textContent = `${promptContent.length.toLocaleString()} chars`;
        }
    }

    // Update structured output toggle
    const structuredToggle = container.querySelector(`#${MODULE_NAME}_use_structured`) as HTMLInputElement;
    if (structuredToggle) {
        structuredToggle.checked = config.useStructuredOutput;
        structuredToggle.disabled = isGenerating;
    }

    // Update schema section visibility
    const schemaSection = container.querySelector(`.${MODULE_NAME}_schema_section`);
    if (schemaSection) {
        schemaSection.classList.toggle('hidden', !config.useStructuredOutput);
    }

    // Update schema preset select
    const schemaSelect = container.querySelector(`#${MODULE_NAME}_schema_preset_select`) as HTMLSelectElement;
    if (schemaSelect) {
        schemaSelect.innerHTML = `<option value="">Custom</option>${renderPresetOptions(schemaPresets, config.schemaPresetId)}`;
        schemaSelect.value = config.schemaPresetId || '';
        schemaSelect.disabled = isGenerating;
    }

    // Update schema textarea
    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
    if (schemaTextarea) {
        let schemaContent = config.customSchema;
        if (config.schemaPresetId) {
            const preset = getSchemaPreset(config.schemaPresetId);
            if (preset) schemaContent = JSON.stringify(preset.schema, null, 2);
        }
        if (schemaTextarea.value !== schemaContent) {
            schemaTextarea.value = schemaContent;
        }
        schemaTextarea.disabled = isGenerating;
    }

    // Update schema validation status
    if (config.useStructuredOutput) {
        updateSchemaValidation(container, schemaTextarea?.value || '');
    }

    // Update schema action buttons
    updateSchemaActionButtons(container, schemaTextarea?.value || '');

    // Update run button
    const runBtn = container.querySelector(`#${MODULE_NAME}_run_stage_btn`) as HTMLButtonElement;
    if (runBtn) {
        runBtn.disabled = isGenerating;
        if (isGenerating) {
            runBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Running...';
        } else {
            runBtn.innerHTML = `<i class="fa-solid fa-play"></i> Run ${STAGE_LABELS[stage]} <kbd>Ctrl+Enter</kbd>`;
        }
    }

    // Update save preset buttons
    updateSavePresetButtons(container, config);
}

// ============================================================================
// SCHEMA ACTION BUTTONS
// ============================================================================

function updateSchemaActionButtons(container: HTMLElement, schemaContent: string): void {
    const validateBtn = container.querySelector(`#${MODULE_NAME}_validate_schema_btn`) as HTMLButtonElement;
    const fixBtn = container.querySelector(`#${MODULE_NAME}_fix_schema_btn`) as HTMLButtonElement;
    const formatBtn = container.querySelector(`#${MODULE_NAME}_format_schema_btn`) as HTMLButtonElement;

    const hasContent = schemaContent.trim().length > 0;

    if (validateBtn) {
        validateBtn.disabled = !hasContent;
    }

    if (formatBtn) {
        formatBtn.disabled = !hasContent;
    }

    if (fixBtn && hasContent) {
        const validation = validateSchema(schemaContent);
        // Enable fix button if there are warnings or if it's invalid but might be fixable
        const needsFix = (validation.warnings?.length ?? 0) > 0 || !validation.valid;
        fixBtn.disabled = !needsFix;
    } else if (fixBtn) {
        fixBtn.disabled = true;
    }
}

// ============================================================================
// SCHEMA ACTION HANDLERS (called from popup.ts)
// ============================================================================

export async function handleValidateSchema(schemaContent: string): Promise<void> {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to validate');
        return;
    }

    const validation = validateSchema(schemaContent);

    if (!validation.valid) {
        toastr.error(`Invalid: ${validation.error}`);
        return;
    }

    // For warnings/info with more than 2 items, use Popup instead of toastr
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();

    if (validation.warnings?.length) {
        if (validation.warnings.length > 2) {
            const content = `
                <h3>Schema Valid with Warnings</h3>
                <ul>
                    ${validation.warnings.map(w => `<li>${w}</li>`).join('')}
                </ul>
            `;
            await new Popup(content, POPUP_TYPE.TEXT, '', { wide: false }).show();
        } else {
            toastr.warning(`Valid with ${validation.warnings.length} warning(s):\n${validation.warnings.join('\n')}`);
        }
        return;
    }

    if (validation.info?.length) {
        if (validation.info.length > 2) {
            const content = `
                <h3>Schema Valid</h3>
                <ul>
                    ${validation.info.map(i => `<li>${i}</li>`).join('')}
                </ul>
            `;
            await new Popup(content, POPUP_TYPE.TEXT, '', { wide: false }).show();
        } else {
            toastr.success(`Valid!\n${validation.info.join('\n')}`);
        }
    } else {
        toastr.success('Schema is valid!');
    }
}

export function handleFixSchema(schemaContent: string): string | null {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to fix');
        return null;
    }

    // First try to parse it
    const validation = validateSchema(schemaContent);

    if (!validation.schema) {
        toastr.error('Cannot fix: schema is not valid JSON or missing required structure');
        return null;
    }

    try {
        const fixed = autoFixSchema(validation.schema);
        const fixedJson = JSON.stringify(fixed, null, 2);

        // Validate the fixed version
        const revalidation = validateSchema(fixedJson);

        if (!revalidation.valid) {
            toastr.warning('Auto-fix applied but schema still has issues');
        } else if (revalidation.warnings?.length) {
            toastr.info(`Fixed! ${revalidation.warnings.length} warning(s) remain`);
        } else {
            toastr.success('Schema fixed successfully!');
        }

        return fixedJson;
    } catch (e) {
        toastr.error(`Fix failed: ${(e as Error).message}`);
        return null;
    }
}

export function handleFormatSchema(schemaContent: string): string | null {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to format');
        return null;
    }

    try {
        const parsed = JSON.parse(schemaContent);
        const formatted = JSON.stringify(parsed, null, 2);
        toastr.success('Schema formatted');
        return formatted;
    } catch (e) {
        toastr.error(`Cannot format: ${(e as Error).message}`);
        return null;
    }
}

// ============================================================================
// SAVE PRESET BUTTONS
// ============================================================================

function updateSavePresetButtons(container: HTMLElement, config: StageConfig): void {
    const promptTextarea = container.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;

    const savePromptBtn = container.querySelector(`#${MODULE_NAME}_save_prompt_preset_btn`) as HTMLButtonElement;
    const saveSchemaBtn = container.querySelector(`#${MODULE_NAME}_save_schema_preset_btn`) as HTMLButtonElement;

    if (savePromptBtn && promptTextarea) {
        const currentPrompt = promptTextarea.value.trim();
        const presetPrompt = config.promptPresetId
            ? getPromptPreset(config.promptPresetId)?.prompt || ''
            : '';

        // Enable if there's content and it differs from the selected preset
        const hasContent = currentPrompt.length > 0;
        const isDifferent = currentPrompt !== presetPrompt;
        savePromptBtn.disabled = !hasContent || (config.promptPresetId !== null && !isDifferent);
    }

    if (saveSchemaBtn && schemaTextarea) {
        const currentSchema = schemaTextarea.value.trim();
        const presetSchema = config.schemaPresetId
            ? JSON.stringify(getSchemaPreset(config.schemaPresetId)?.schema, null, 2)
            : '';

        // Enable if there's valid content and it differs from the selected preset
        const hasContent = currentSchema.length > 0;
        const isDifferent = currentSchema !== presetSchema;
        const isValid = hasContent ? validateSchema(currentSchema).valid : false;
        saveSchemaBtn.disabled = !hasContent || !isValid || (config.schemaPresetId !== null && !isDifferent);
    }
}

// ============================================================================
// SAVE PRESET HANDLERS (called from popup.ts)
// ============================================================================

export interface SavePresetResult {
    success: boolean;
    presetId?: string;
}

export async function handleSavePromptPreset(stage: StageName, promptContent: string): Promise<SavePresetResult> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    if (!promptContent.trim()) {
        toastr.warning('No prompt content to save');
        return { success: false };
    }

    const name = await Popup.show.input(
        'Save Prompt Preset',
        'Enter a name for this preset:',
        `Custom ${STAGE_LABELS[stage]} Prompt`,
    );

    if (name === null || name === POPUP_RESULT.CANCELLED) {
        return { success: false };
    }

    if (!name.trim()) {
        toastr.warning('Preset name cannot be empty');
        return { success: false };
    }

    try {
        const newPreset = savePromptPreset({
            name: name.trim(),
            prompt: promptContent,
            stages: [stage],
        });
        toastr.success(`Prompt preset "${name}" saved`);
        return { success: true, presetId: newPreset.id };
    } catch (e) {
        toastr.error(`Failed to save preset: ${(e as Error).message}`);
        return { success: false };
    }
}

export async function handleSaveSchemaPreset(stage: StageName, schemaContent: string): Promise<SavePresetResult> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    if (!schemaContent.trim()) {
        toastr.warning('No schema content to save');
        return { success: false };
    }

    // Validate first
    const validation = validateSchema(schemaContent);
    if (!validation.valid) {
        toastr.error(`Invalid schema: ${validation.error}`);
        return { success: false };
    }

    const name = await Popup.show.input(
        'Save Schema Preset',
        'Enter a name for this preset:',
        `Custom ${STAGE_LABELS[stage]} Schema`,
    );

    if (name === null || name === POPUP_RESULT.CANCELLED) {
        return { success: false };
    }

    if (!name.trim()) {
        toastr.warning('Preset name cannot be empty');
        return { success: false };
    }

    try {
        const newPreset = saveSchemaPreset({
            name: name.trim(),
            schema: validation.schema!,
            stages: [stage],
        });
        toastr.success(`Schema preset "${name}" saved`);
        return { success: true, presetId: newPreset.id };
    } catch (e) {
        toastr.error(`Failed to save preset: ${(e as Error).message}`);
        return { success: false };
    }
}

// ============================================================================
// HELPERS
// ============================================================================

function renderPresetOptions(presets: (PromptPreset | SchemaPreset)[], selectedId: string | null): string {
    return presets.map(p => {
        const selected = p.id === selectedId ? 'selected' : '';
        const icon = p.isBuiltin ? '📦' : '📝';
        return `<option value="${p.id}" ${selected}>${icon} ${escapeHtml(p.name)}</option>`;
    }).join('');
}

function updateSchemaValidation(container: HTMLElement, schemaContent: string): void {
    // Remove existing status
    const existingStatus = container.querySelector(`.${MODULE_NAME}_schema_status`);
    if (existingStatus) {
        existingStatus.remove();
    }

    if (!schemaContent.trim()) {
        return;
    }

    const validation = validateSchema(schemaContent);
    let statusHtml = '';

    if (!validation.valid) {
        statusHtml = `<div class="${MODULE_NAME}_schema_status error"><i class="fa-solid fa-circle-xmark"></i> ${escapeHtml(validation.error || 'Invalid schema')}</div>`;
    } else if (validation.warnings?.length) {
        statusHtml = `<div class="${MODULE_NAME}_schema_status warning"><i class="fa-solid fa-triangle-exclamation"></i> ${validation.warnings.length} warning(s)</div>`;
    } else {
        statusHtml = `<div class="${MODULE_NAME}_schema_status success"><i class="fa-solid fa-circle-check"></i> Valid schema</div>`;
    }

    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`);
    if (schemaTextarea) {
        schemaTextarea.insertAdjacentHTML('afterend', statusHtml);
    }
}

function escapeHtml(text: string): string {
    const { DOMPurify } = SillyTavern.libs;
    return DOMPurify.sanitize(text, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/results-panel.ts
```ts
// src/ui/components/results-panel.ts
//
// Results display and actions component

import { MODULE_NAME, STAGE_LABELS } from '../../constants';
import { formatResponse, formatStructuredResponse } from '../formatter';
import { canExport, canRefine, extractVerdict } from '../../pipeline';
import type { StageName, StageStatus, StageResult, PipelineState, IterationVerdict } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the results panel
 */
export function renderResultsPanel(
    stage: StageName,
    result: StageResult | null,
    status: StageStatus,
    isGenerating: boolean,
): string {
    if (isGenerating && status === 'running') {
        return renderLoading(stage);
    }

    if (!result) {
        return renderPlaceholder(stage, status);
    }

    return renderResult(stage, result);
}

function renderLoading(stage: StageName): string {
    return `
    <div class="${MODULE_NAME}_results_loading">
      <i class="fa-solid fa-spinner fa-spin fa-2x"></i>
      <p>Running ${STAGE_LABELS[stage]}...</p>
      <button id="${MODULE_NAME}_cancel_btn" class="menu_button">
        <i class="fa-solid fa-stop"></i>
        <span>Cancel</span>
      </button>
    </div>
  `;
}

/**
 * Render loading state for refinement
 */
export function renderRefinementLoading(iteration: number): string {
    return `
    <div class="${MODULE_NAME}_results_loading">
      <i class="fa-solid fa-spinner fa-spin fa-2x"></i>
      <p>Refining (Iteration #${iteration + 1})...</p>
      <button id="${MODULE_NAME}_cancel_btn" class="menu_button">
        <i class="fa-solid fa-stop"></i>
        <span>Cancel</span>
      </button>
    </div>
  `;
}

function renderPlaceholder(stage: StageName, status: StageStatus): string {
    let message = `Run ${STAGE_LABELS[stage]} to see results`;
    let icon = 'fa-play';

    if (status === 'skipped') {
        message = `${STAGE_LABELS[stage]} was skipped`;
        icon = 'fa-forward';
    }

    return `
    <div class="${MODULE_NAME}_results_placeholder">
      <i class="fa-solid ${icon}"></i>
      <p>${message}</p>
    </div>
  `;
}

function renderResult(stage: StageName, result: StageResult): string {
    const formattedContent = result.isStructured
        ? formatStructuredResponse(result.response, null, MODULE_NAME)
        : formatResponse(result.response, MODULE_NAME);

    const timestamp = new Date(result.timestamp).toLocaleTimeString();

    // Extract verdict if this is an analyze result
    let verdictBadge = '';
    if (stage === 'analyze') {
        const verdict = extractVerdict(result.response);
        verdictBadge = renderVerdictBadge(verdict);
    }

    return `
    <div class="${MODULE_NAME}_results_content">
      <!-- Toolbar -->
      <div class="${MODULE_NAME}_results_toolbar">
        <div class="${MODULE_NAME}_results_info">
          <span class="${MODULE_NAME}_badge">${STAGE_LABELS[stage]}</span>
          ${verdictBadge}
          <span class="${MODULE_NAME}_results_time">${timestamp}</span>
          ${result.locked ? `<span class="${MODULE_NAME}_badge ${MODULE_NAME}_badge_locked"><i class="fa-solid fa-lock"></i> Locked</span>` : ''}
        </div>
        <div class="${MODULE_NAME}_results_actions">
          <!-- Always render BOTH buttons, use hidden class based on locked state -->
          <button id="${MODULE_NAME}_lock_btn" class="${MODULE_NAME}_icon_btn ${result.locked ? 'hidden' : ''}" title="Lock result">
            <i class="fa-solid fa-lock"></i>
          </button>
          <button id="${MODULE_NAME}_unlock_btn" class="${MODULE_NAME}_icon_btn ${result.locked ? '' : 'hidden'}" title="Unlock for editing">
            <i class="fa-solid fa-lock-open"></i>
          </button>
          <button id="${MODULE_NAME}_copy_btn" class="${MODULE_NAME}_icon_btn" title="Copy to clipboard">
            <i class="fa-solid fa-copy"></i>
          </button>
        </div>
      </div>

      <!-- Content -->
      <div class="${MODULE_NAME}_results_body">
        ${formattedContent}
      </div>

      <!-- Footer Actions -->
      <div class="${MODULE_NAME}_results_footer" id="${MODULE_NAME}_results_footer">
        <!-- Populated by updateResultsPanelState -->
      </div>
    </div>
  `;
}

function renderVerdictBadge(verdict: IterationVerdict): string {
    const icons: Record<IterationVerdict, string> = {
        accept: 'fa-check-circle',
        needs_refinement: 'fa-wrench',
        regression: 'fa-arrow-down',
    };

    const labels: Record<IterationVerdict, string> = {
        accept: 'Accept',
        needs_refinement: 'Needs Work',
        regression: 'Regression',
    };

    return `
    <span class="${MODULE_NAME}_badge ${MODULE_NAME}_verdict_badge ${MODULE_NAME}_verdict_${verdict}">
      <i class="fa-solid ${icons[verdict]}"></i>
      ${labels[verdict]}
    </span>
  `;
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update results panel state
 */
export function updateResultsPanelState(
    container: HTMLElement,
    stage: StageName,
    result: StageResult | null,
    status: StageStatus,
    isGenerating: boolean,
    nextStage: StageName | null,
    pipeline: PipelineState,
): void {
    const shouldShowLoading = isGenerating && status === 'running';
    const shouldShowResult = result && !shouldShowLoading;
    const shouldShowPlaceholder = !result && !shouldShowLoading;

    // Always re-render if state type changes OR if showing placeholder (stage name might have changed)
    if (shouldShowLoading) {
        container.innerHTML = renderLoading(stage);
        return;
    }

    if (shouldShowPlaceholder) {
        container.innerHTML = renderPlaceholder(stage, status);
        return;
    }

    if (shouldShowResult) {
        // Only re-render result if we don't have content or timestamp changed
        const existingContent = container.querySelector(`.${MODULE_NAME}_results_content`);
        const existingTimestamp = container.querySelector(`.${MODULE_NAME}_results_time`)?.textContent;
        const newTimestamp = new Date(result.timestamp).toLocaleTimeString();

        if (!existingContent || existingTimestamp !== newTimestamp) {
            container.innerHTML = renderResult(stage, result);
        }
    }

    // Update footer actions
    const footer = container.querySelector(`#${MODULE_NAME}_results_footer`);
    if (footer && result) {
        footer.innerHTML = renderFooterActions(stage, result, nextStage, pipeline);
    }

    // Update lock/unlock button visibility
    const lockBtn = container.querySelector(`#${MODULE_NAME}_lock_btn`);
    const unlockBtn = container.querySelector(`#${MODULE_NAME}_unlock_btn`);

    if (lockBtn && unlockBtn) {
        lockBtn.classList.toggle('hidden', !!result?.locked);
        unlockBtn.classList.toggle('hidden', !result?.locked);
    }
}

function renderFooterActions(
    stage: StageName,
    result: StageResult,
    nextStage: StageName | null,
    pipeline: PipelineState,
): string {
    const actions: string[] = [];

    // Regenerate (if not locked)
    if (!result.locked) {
        actions.push(`
      <button id="${MODULE_NAME}_regenerate_btn" class="menu_button">
        <i class="fa-solid fa-rotate"></i>
        <span>Regenerate</span>
      </button>
    `);
    }

    // Stage-specific actions
    if (stage === 'rewrite' && pipeline.character) {
        // Apply to Character button - the primary action for rewrite stage
        actions.push(`
      <button id="${MODULE_NAME}_apply_btn" class="menu_button ${MODULE_NAME}_apply_btn">
        <i class="fa-solid fa-check-double"></i>
        <span>Apply to Character</span>
      </button>
    `);
    }

    if (stage === 'analyze') {
        const verdict = extractVerdict(result.response);
        const canRefineResult = canRefine(pipeline);

        // Refine button (if we can refine)
        if (canRefineResult.canRun) {
            const isRecommended = verdict === 'needs_refinement';
            actions.push(`
        <button id="${MODULE_NAME}_refine_btn" class="menu_button ${isRecommended ? MODULE_NAME + '_refine_recommended' : ''}">
          <i class="fa-solid fa-arrows-rotate"></i>
          <span>Refine</span>
          ${pipeline.iterationCount > 0 ? `<span class="${MODULE_NAME}_iteration_badge">#${pipeline.iterationCount + 1}</span>` : ''}
        </button>
      `);
        }

        // Accept button (if we have a rewrite)
        if (pipeline.results.rewrite && !pipeline.results.rewrite.locked) {
            const isRecommended = verdict === 'accept';
            actions.push(`
        <button id="${MODULE_NAME}_accept_btn" class="menu_button ${isRecommended ? MODULE_NAME + '_accept_recommended' : ''}">
          <i class="fa-solid fa-check"></i>
          <span>Accept Rewrite</span>
        </button>
      `);
        }
    }

    // Continue to next stage (not on analyze - use refine/accept instead)
    if (nextStage && stage !== 'analyze') {
        actions.push(`
      <button id="${MODULE_NAME}_continue_btn" class="menu_button ${MODULE_NAME}_continue_btn">
        <i class="fa-solid fa-arrow-right"></i>
        <span>Continue to ${STAGE_LABELS[nextStage]}</span>
      </button>
    `);
    }

    // Export (if we have rewrite results)
    if (canExport(pipeline)) {
        actions.push(`
      <button id="${MODULE_NAME}_export_btn" class="menu_button">
        <i class="fa-solid fa-file-export"></i>
        <span>Export</span>
      </button>
    `);
    }

    return `<div class="${MODULE_NAME}_footer_actions">${actions.join('')}</div>`;
}
```

## FILE: src/ui/components/iteration-history.ts
```ts
// src/ui/components/iteration-history.ts
//
// Iteration history display component

import { MODULE_NAME } from '../../constants';
import type { IterationSnapshot, IterationVerdict } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the iteration history panel
 * @param history - Array of iteration snapshots
 * @param currentIteration - Current iteration number
 * @param historyLoaded - Whether history has been loaded from persistence
 */
export function renderIterationHistory(
    history: IterationSnapshot[],
    currentIteration: number,
    historyLoaded: boolean,
): string {
    if (history.length === 0 && currentIteration === 0) {
        return '';
    }

    // Show loading state while history is being loaded from localforage
    const listContent = !historyLoaded
        ? `<div class="${MODULE_NAME}_iteration_loading">
             <i class="fa-solid fa-spinner fa-spin"></i>
             <span>Loading history...</span>
           </div>`
        : history.length === 0
            ? `<div class="${MODULE_NAME}_iteration_empty">No previous iterations</div>`
            : history.map((snap, i) => renderIterationItem(snap, i)).join('');

    return `
    <div class="${MODULE_NAME}_iteration_history" id="${MODULE_NAME}_iteration_history">
      <div class="${MODULE_NAME}_iteration_header">
        <i class="fa-solid fa-clock-rotate-left"></i>
        <span>Iteration History</span>
        <span class="${MODULE_NAME}_iteration_count">${currentIteration > 0 ? `Current: #${currentIteration + 1}` : 'Initial'}</span>
      </div>
      <div class="${MODULE_NAME}_iteration_list">
        ${listContent}
      </div>
    </div>
  `;
}

function renderIterationItem(snap: IterationSnapshot, index: number): string {
    const verdictIcon = getVerdictIcon(snap.verdict);
    const verdictClass = getVerdictClass(snap.verdict);
    const time = new Date(snap.timestamp).toLocaleTimeString();

    return `
    <div class="${MODULE_NAME}_iteration_item ${verdictClass}" data-index="${index}">
      <div class="${MODULE_NAME}_iteration_item_header">
        <span class="${MODULE_NAME}_iteration_num">#${snap.iteration + 1}</span>
        <span class="${MODULE_NAME}_iteration_verdict">
          <i class="fa-solid ${verdictIcon}"></i>
          ${formatVerdict(snap.verdict)}
        </span>
        <span class="${MODULE_NAME}_iteration_time">${time}</span>
      </div>
      <div class="${MODULE_NAME}_iteration_preview">
        ${escapeHtml(snap.rewritePreview)}...
      </div>
      <div class="${MODULE_NAME}_iteration_actions">
        <button
          class="${MODULE_NAME}_iteration_revert_btn menu_button"
          data-index="${index}"
          title="Revert to this version"
        >
          <i class="fa-solid fa-rotate-left"></i>
          Revert
        </button>
        <button
          class="${MODULE_NAME}_iteration_view_btn menu_button"
          data-index="${index}"
          title="View full content"
        >
          <i class="fa-solid fa-eye"></i>
          View
        </button>
      </div>
    </div>
  `;
}

function getVerdictIcon(verdict: IterationVerdict): string {
    switch (verdict) {
        case 'accept': return 'fa-check-circle';
        case 'needs_refinement': return 'fa-wrench';
        case 'regression': return 'fa-arrow-down';
        default: return 'fa-question-circle';
    }
}

function getVerdictClass(verdict: IterationVerdict): string {
    return `${MODULE_NAME}_verdict_${verdict}`;
}

function formatVerdict(verdict: IterationVerdict): string {
    switch (verdict) {
        case 'accept': return 'Accepted';
        case 'needs_refinement': return 'Needs Work';
        case 'regression': return 'Regression';
        default: return 'Unknown';
    }
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update iteration history state
 */
export function updateIterationHistoryState(
    container: HTMLElement,
    history: IterationSnapshot[],
    currentIteration: number,
    historyLoaded: boolean,
): void {
    const historyEl = container.querySelector(`#${MODULE_NAME}_iteration_history`);

    if (!historyEl && (history.length > 0 || currentIteration > 0)) {
        // Need to add history panel
        const html = renderIterationHistory(history, currentIteration, historyLoaded);
        container.insertAdjacentHTML('beforeend', html);
    } else if (historyEl) {
        // Update existing
        const countEl = historyEl.querySelector(`.${MODULE_NAME}_iteration_count`);
        if (countEl) {
            countEl.textContent = currentIteration > 0 ? `Current: #${currentIteration + 1}` : 'Initial';
        }

        const listEl = historyEl.querySelector(`.${MODULE_NAME}_iteration_list`);
        if (listEl) {
            if (!historyLoaded) {
                listEl.innerHTML = `<div class="${MODULE_NAME}_iteration_loading">
                    <i class="fa-solid fa-spinner fa-spin"></i>
                    <span>Loading history...</span>
                </div>`;
            } else if (history.length === 0) {
                listEl.innerHTML = `<div class="${MODULE_NAME}_iteration_empty">No previous iterations</div>`;
            } else {
                listEl.innerHTML = history.map((snap, i) => renderIterationItem(snap, i)).join('');
            }
        }
    }
}

/**
 * Render iteration view modal content
 */
export function renderIterationViewContent(snap: IterationSnapshot): string {
    const { moment } = SillyTavern.libs;

    return `
    <div class="${MODULE_NAME}_iteration_view">
      <div class="${MODULE_NAME}_iteration_view_header">
        <h3>Iteration #${snap.iteration + 1}</h3>
        <span class="${MODULE_NAME}_iteration_verdict ${getVerdictClass(snap.verdict)}">
          <i class="fa-solid ${getVerdictIcon(snap.verdict)}"></i>
          ${formatVerdict(snap.verdict)}
        </span>
        <span class="${MODULE_NAME}_iteration_time">${moment(snap.timestamp).format('YYYY-MM-DD HH:mm:ss')}</span>
      </div>

      <div class="${MODULE_NAME}_iteration_view_section">
        <h4>Rewrite</h4>
        <div class="${MODULE_NAME}_iteration_view_content">
          ${escapeHtml(snap.rewriteResponse)}
        </div>
      </div>

      <div class="${MODULE_NAME}_iteration_view_section">
        <h4>Analysis</h4>
        <div class="${MODULE_NAME}_iteration_view_content">
          ${escapeHtml(snap.analysisResponse)}
        </div>
      </div>
    </div>
  `;
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: templates/panel.html
```html
<div id="character_tools_settings" class="extension_settings">
  <div class="inline-drawer">
    <div class="inline-drawer-toggle inline-drawer-header">
      <b><i class="fa-solid fa-wand-magic-sparkles"></i> Character Tools</b>
      <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
    </div>
    <div class="inline-drawer-content">
      <div class="character_tools_panel_version">
        <small class="opacity50">v1.0.0</small>
      </div>
      <!-- Quick Launch -->
      <div class="character_tools_panel_launch">
        <button id="character_tools_open_btn" class="menu_button menu_button_icon wide100p">
          <i class="fa-solid fa-rocket"></i>
          <span>Open Character Tools</span>
        </button>
      </div>

      <hr>

      <!-- Debug Toggle -->
      <div class="character_tools_panel_row">
        <label class="checkbox_label">
          <input type="checkbox" id="character_tools_debug_toggle">
          <span>Debug Mode</span>
        </label>
        <small class="opacity50">Log requests/responses to console</small>
      </div>

    </div>
  </div>
</div>
```

## FILE: style.css
```css
/* style.css - Character Tools Extension v1.0.0 */

/* ============================================================================
   VARIABLES - Extension-specific only, inherit ST for everything else
   ============================================================================ */

:root {
  --ct-spacing-xs: 4px;
  --ct-spacing-sm: 8px;
  --ct-spacing-md: 12px;
  --ct-spacing-lg: 16px;
  --ct-spacing-xl: 24px;
  --ct-radius-sm: 4px;
  --ct-radius-md: 6px;
  --ct-radius-lg: 8px;
  --ct-transition: 0.15s ease;
}

/* ============================================================================
   EXTENSION PANEL
   ============================================================================ */

.character_tools_panel_launch {
  margin-bottom: var(--ct-spacing-md);
}

.character_tools_panel_launch .menu_button {
  font-size: 1.05em;
  padding: var(--ct-spacing-md) var(--ct-spacing-lg);
}

.character_tools_panel_row {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-xs);
}

.character_tools_panel_version {
  text-align: right;
  margin-bottom: var(--ct-spacing-sm);
}

/* ============================================================================
   POPUP - LAYOUT
   ============================================================================ */

.character_tools_popup {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  min-width: 600px;
  max-width: 900px;
  color: var(--SmartThemeBodyColor);
  font-family: var(--mainFontFamily);
}

/* Header - Sticky */
.character_tools_popup_header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  position: sticky;
  top: 0;
  z-index: 10;
  background: var(--SmartThemeBlurTintColor);
  margin: calc(-1 * var(--ct-spacing-lg)) calc(-1 * var(--ct-spacing-lg)) 0;
  padding: var(--ct-spacing-lg);
  padding-bottom: var(--ct-spacing-md);
}

.character_tools_popup_title {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 1.3em;
  font-weight: 600;
  color: var(--SmartThemeBodyColor);
  flex-shrink: 0;
}

.character_tools_popup_header_right {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  flex-shrink: 0;
}

.character_tools_api_status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.85em;
  color: var(--SmartThemeBodyColor);
  opacity: 0.7;
}

.character_tools_api_status i {
  font-size: 8px;
}

.character_tools_api_status.connected i {
  color: var(--success, #2ecc71);
}

.character_tools_api_status.disconnected i {
  color: var(--failure, #e74c3c);
}

/* Sections */
.character_tools_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_section_grow {
  flex: 1;
  min-height: 200px;
}

.character_tools_section_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_section_header i {
  width: 18px;
  text-align: center;
  opacity: 0.8;
}

/* ============================================================================
   ICON BUTTON - Theme Agnostic
   ============================================================================ */

.character_tools_icon_btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  background: transparent;
  border: 1px solid transparent;
  border-radius: var(--ct-radius-md);
  cursor: pointer;
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
  transition: all var(--ct-transition);
  flex-shrink: 0;
}

.character_tools_icon_btn:hover {
  opacity: 1;
  background: var(--SmartThemeBorderColor);
}

.character_tools_icon_btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.character_tools_icon_btn.hidden {
  display: none;
}

/* ============================================================================
   MENU BUTTON OVERRIDES - Ensure theme consistency
   ============================================================================ */

.character_tools_popup .menu_button,
.character_tools_settings_modal .menu_button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--ct-spacing-xs);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  color: var(--SmartThemeBodyColor);
  font-family: var(--mainFontFamily);
  font-size: 0.9em;
  cursor: pointer;
  transition: all var(--ct-transition);
  white-space: nowrap;
}

.character_tools_popup .menu_button:hover,
.character_tools_settings_modal .menu_button:hover {
  background: var(--SmartThemeBorderColor);
}

.character_tools_popup .menu_button:disabled,
.character_tools_settings_modal .menu_button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.character_tools_popup .menu_button i,
.character_tools_settings_modal .menu_button i {
  font-size: 0.9em;
}

/* ============================================================================
   BADGES
   ============================================================================ */

.character_tools_badge {
  display: inline-flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.75em;
  font-weight: 600;
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.character_tools_badge_locked {
  background: var(--SmartThemeBorderColor);
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   CHARACTER SELECT
   ============================================================================ */

.character_tools_char_select {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
  position: relative;
}

/* Search */
.character_tools_search_wrapper {
  position: relative;
}

.character_tools_search_wrapper.hidden {
  display: none;
}

.character_tools_search_container {
  position: relative;
  display: flex;
  align-items: center;
}

.character_tools_search_icon {
  position: absolute;
  left: 12px;
  opacity: 0.5;
  pointer-events: none;
  z-index: 1;
  color: var(--SmartThemeBodyColor);
}

.character_tools_search_input {
  padding-left: 36px !important;
  width: 100%;
}

/* Dropdown */
.character_tools_dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 300px;
  overflow-y: auto;
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-top: none;
  border-radius: 0 0 var(--ct-radius-lg) var(--ct-radius-lg);
  z-index: 1000;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}

.character_tools_dropdown.hidden {
  display: none;
}

.character_tools_dropdown_item {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  cursor: pointer;
  transition: background var(--ct-transition);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  min-height: 56px;
  color: var(--SmartThemeBodyColor);
}

.character_tools_dropdown_item:last-child {
  border-bottom: none;
}

.character_tools_dropdown_item:hover,
.character_tools_dropdown_item.selected {
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_dropdown_avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  background: var(--SmartThemeBorderColor);
}

.character_tools_dropdown_info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
  flex: 1;
  overflow: hidden;
}

.character_tools_dropdown_name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.character_tools_dropdown_desc {
  font-size: 0.8em;
  opacity: 0.6;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.character_tools_dropdown_empty {
  padding: var(--ct-spacing-lg);
  text-align: center;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

/* Character Preview */
.character_tools_char_preview {
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  overflow: hidden;
}

.character_tools_char_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
}

.character_tools_char_avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  background: var(--SmartThemeBorderColor);
}

.character_tools_char_info {
  flex: 1;
  min-width: 0;
  text-align: left;
}

.character_tools_char_name {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_char_meta {
  font-size: 0.85em;
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
}

/* Character Fields */
.character_tools_char_fields {
  max-height: 200px;
  overflow-y: auto;
}

.character_tools_field_row {
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_field_row:last-child {
  border-bottom: none;
}

.character_tools_field_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  cursor: pointer;
  transition: background var(--ct-transition);
  color: var(--SmartThemeBodyColor);
  text-align: left;
}

.character_tools_field_header:hover {
  background: var(--SmartThemeChatTintColor);
}

.character_tools_field_header i {
  font-size: 0.8em;
  opacity: 0.5;
  width: 12px;
  transition: transform var(--ct-transition);
  flex-shrink: 0;
}

.character_tools_field_label {
  flex: 1;
  font-weight: 500;
  text-align: left;
}

.character_tools_field_tokens {
  font-size: 0.8em;
  opacity: 0.7;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
  text-align: right;
  flex-shrink: 0;
}

.character_tools_field_content {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md) var(--ct-spacing-md);
  padding-left: calc(var(--ct-spacing-md) + 20px);
  background: var(--SmartThemeChatTintColor);
}

.character_tools_field_content.hidden {
  display: none;
}

.character_tools_field_text {
  font-size: 0.9em;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 150px;
  overflow-y: auto;
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   PIPELINE NAV
   ============================================================================ */

.character_tools_pipeline_nav {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-md);
}

.character_tools_stage_row {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: var(--ct-spacing-sm);
}

.character_tools_stage_node {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
}

/* Stage Checkbox */
.character_tools_stage_checkbox {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: var(--SmartThemeQuoteColor);
  flex-shrink: 0;
}

/* Stage Button */
.character_tools_stage_btn {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  cursor: pointer;
  color: var(--SmartThemeBodyColor);
  font-size: 0.9em;
  font-family: var(--mainFontFamily);
  transition: all var(--ct-transition);
}

.character_tools_stage_btn:hover {
  background: var(--SmartThemeBorderColor);
}

.character_tools_stage_btn.active {
  background: var(--SmartThemeQuoteColor);
  border-color: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_status_icon {
  font-size: 0.75em;
  margin-left: 4px;
}

.character_tools_stage_complete .character_tools_status_icon {
  color: var(--success, #2ecc71);
}

.character_tools_stage_running .character_tools_status_icon {
  color: var(--warning, #f39c12);
}

/* Stage Connector */
.character_tools_stage_connector {
  width: 20px;
  height: 2px;
  background: var(--SmartThemeBorderColor);
  margin: 0 4px;
  flex-shrink: 0;
}

.character_tools_stage_connector.active {
  background: var(--SmartThemeQuoteColor);
}

/* Pipeline Actions */
.character_tools_pipeline_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_pipeline_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

/* ============================================================================
   STAGE CONFIG
   ============================================================================ */

.character_tools_stage_config {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-md);
}

.character_tools_config_group {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_config_header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-sm);
  min-width: 0;
}

.character_tools_config_header_actions {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  flex-shrink: 1;
  min-width: 0;
  overflow: hidden;
}

.character_tools_config_header_actions .character_tools_icon_btn {
  width: 28px;
  height: 28px;
}

.character_tools_config_label {
  font-weight: 500;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
  flex-shrink: 0;
}

.character_tools_preset_select {
  width: auto;
  min-width: 0;
  max-width: 100%;
  flex: 1 1 120px;
  text-overflow: ellipsis;
}

.character_tools_prompt_textarea {
  resize: vertical;
  min-height: 100px;
  font-size: 0.9em;
  line-height: 1.5;
}

.character_tools_schema_textarea {
  resize: vertical;
  min-height: 80px;
  font-size: 0.85em;
  font-family: var(--monoFontFamily);
}

.character_tools_config_footer {
  display: flex;
  justify-content: flex-end;
}

.character_tools_char_count {
  font-size: 0.8em;
  opacity: 0.5;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
}

/* Schema Section */
.character_tools_schema_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_schema_section.hidden {
  display: none;
}

.character_tools_schema_status {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.85em;
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  border-radius: var(--ct-radius-sm);
}

.character_tools_schema_status.success {
  color: var(--success, #2ecc71);
  background: rgba(46, 204, 113, 0.15);
}

.character_tools_schema_status.warning {
  color: var(--warning, #f39c12);
  background: rgba(243, 156, 18, 0.15);
}

.character_tools_schema_status.error {
  color: var(--failure, #e74c3c);
  background: rgba(231, 76, 60, 0.15);
}

.character_tools_schema_status.info {
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
}

/* Schema Actions */
.character_tools_schema_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  margin-top: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_schema_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

/* Config Actions */
.character_tools_config_actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: var(--ct-spacing-sm);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_token_estimate {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.85em;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
  opacity: 0.7;
}

.character_tools_token_estimate.warning {
  color: var(--warning, #f39c12);
  opacity: 1;
}

.character_tools_token_estimate.danger {
  color: var(--failure, #e74c3c);
  opacity: 1;
}

#character_tools_run_stage_btn kbd {
  font-size: 0.7em;
  padding: 2px 6px;
  background: var(--SmartThemeBorderColor);
  border-radius: 3px;
  opacity: 0.7;
  font-family: var(--monoFontFamily);
  margin-left: var(--ct-spacing-sm);
}

/* Checkbox Label */
.character_tools_checkbox_label {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  cursor: pointer;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_checkbox_label input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: var(--SmartThemeQuoteColor);
  flex-shrink: 0;
}

/* ============================================================================
   RESULTS PANEL
   ============================================================================ */

.character_tools_results_loading,
.character_tools_results_placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-xl) var(--ct-spacing-lg);
  text-align: center;
  min-height: 150px;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_placeholder {
  opacity: 0.5;
}

.character_tools_results_placeholder i,
.character_tools_results_loading i.fa-2x {
  font-size: 2em;
}

/* Cancel button in loading state */
.character_tools_results_loading .menu_button {
  margin-top: var(--ct-spacing-sm);
}

/* Results Content */
.character_tools_results_content {
  display: flex;
  flex-direction: column;
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  background: var(--SmartThemeBlurTintColor);
  overflow: hidden;
}

.character_tools_results_toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  flex-wrap: wrap;
  gap: var(--ct-spacing-sm);
}

.character_tools_results_info {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 0.85em;
  flex-wrap: wrap;
}

.character_tools_results_time {
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_actions {
  display: flex;
  gap: var(--ct-spacing-xs);
}

.character_tools_results_body {
  padding: var(--ct-spacing-lg);
  max-height: 400px;
  overflow-y: auto;
  line-height: 1.6;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_footer {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_footer_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_footer_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

/* Continue Button - Prominent */
.character_tools_continue_btn {
  background: var(--SmartThemeQuoteColor) !important;
  color: var(--SmartThemeBlurTintColor) !important;
  border-color: var(--SmartThemeQuoteColor) !important;
}

.character_tools_continue_btn:hover {
  filter: brightness(1.1);
}

/* Apply Button - Primary Action */
.character_tools_apply_btn {
  background: var(--success, #2ecc71) !important;
  color: #fff !important;
  border-color: var(--success, #2ecc71) !important;
}

.character_tools_apply_btn:hover {
  filter: brightness(1.1);
}

/* ============================================================================
   SETTINGS MODAL
   ============================================================================ */

.character_tools_settings_modal {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  min-width: 500px;
  max-width: 700px;
  color: var(--SmartThemeBodyColor);
  font-family: var(--mainFontFamily);
}

.character_tools_settings_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 1.2em;
  font-weight: 600;
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_settings_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_settings_section_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-weight: 600;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_settings_hint {
  font-size: 0.85em;
  opacity: 0.6;
  margin: 0;
  color: var(--SmartThemeBodyColor);
}

.character_tools_settings_row {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
}

.character_tools_settings_row_spread {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-md);
  flex-wrap: wrap;
}

.character_tools_settings_grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--ct-spacing-md);
}

.character_tools_settings_grid_5 {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
  gap: var(--ct-spacing-sm);
}

.character_tools_settings_field {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-xs);
}

.character_tools_settings_field label {
  font-size: 0.85em;
  opacity: 0.8;
  color: var(--SmartThemeBodyColor);
}

.character_tools_settings_field .text_pole {
  min-width: 0;
  width: 100%;
}

.character_tools_system_prompt_textarea {
  resize: vertical;
  min-height: 100px;
  font-size: 0.9em;
}

/* Keyboard Shortcuts */
.character_tools_shortcuts_list {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_shortcut_item {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_shortcut_item kbd {
  display: inline-block;
  padding: 3px 8px;
  font-family: var(--monoFontFamily);
  font-size: 0.85em;
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-sm);
  box-shadow: 0 1px 0 var(--SmartThemeBorderColor);
}

.character_tools_shortcut_item span {
  opacity: 0.7;
}

/* Presets */
.character_tools_presets_grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--ct-spacing-lg);
}

.character_tools_preset_column h4 {
  margin: 0 0 var(--ct-spacing-sm);
  font-size: 0.9em;
  opacity: 0.8;
  color: var(--SmartThemeBodyColor);
  text-align: center;
}

.character_tools_preset_list {
  max-height: 150px;
  overflow-y: auto;
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  background: var(--SmartThemeBlurTintColor);
}

.character_tools_preset_item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_preset_item:last-child {
  border-bottom: none;
}

.character_tools_preset_item.builtin {
  opacity: 0.7;
}

.character_tools_preset_name {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
}

.character_tools_preset_name i {
  font-size: 0.75em;
  opacity: 0.5;
}

.character_tools_preset_delete {
  background: none;
  border: none;
  color: var(--failure, #e74c3c);
  cursor: pointer;
  padding: var(--ct-spacing-xs);
  opacity: 0.6;
  transition: opacity var(--ct-transition);
}

.character_tools_preset_delete:hover {
  opacity: 1;
}

.character_tools_preset_empty {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

/* Debug */
.character_tools_debug_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_debug_log_viewer {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
  margin-top: var(--ct-spacing-sm);
}

.character_tools_debug_log_viewer.hidden {
  display: none;
}

.character_tools_debug_log_list {
  max-height: 120px;
  overflow-y: auto;
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  font-family: var(--monoFontFamily);
  font-size: 0.8em;
}

.character_tools_debug_log_entry {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  cursor: pointer;
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  transition: background var(--ct-transition);
  color: var(--SmartThemeBodyColor);
}

.character_tools_debug_log_entry:hover {
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_debug_log_entry:last-child {
  border-bottom: none;
}

.character_tools_debug_log_empty {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_debug_log_detail {
  max-height: 120px;
  overflow: auto;
  margin: 0;
  padding: var(--ct-spacing-sm);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  font-family: var(--monoFontFamily);
  font-size: 0.75em;
  white-space: pre-wrap;
  word-break: break-all;
  color: var(--SmartThemeBodyColor);
}

/* Settings Footer */
.character_tools_settings_footer {
  padding-top: var(--ct-spacing-md);
  border-top: 1px solid var(--SmartThemeBorderColor);
  text-align: center;
}

.character_tools_settings_version {
  font-size: 0.8em;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   STRUCTURED OUTPUT FORMATTING
   ============================================================================ */

.character_tools_structured_content,
.character_tools_markdown_content {
  text-align: left;
  color: var(--SmartThemeBodyColor);
}

.character_tools_hero {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--ct-spacing-lg) var(--ct-spacing-xl);
  margin-bottom: var(--ct-spacing-lg);
  background: var(--SmartThemeChatTintColor);
  border-radius: var(--ct-radius-lg);
  border-left: 4px solid var(--SmartThemeQuoteColor);
}

.character_tools_hero_label {
  font-size: 1.1em;
  font-weight: 600;
  opacity: 0.9;
}

.character_tools_hero_value {
  font-size: 2em;
  font-weight: 700;
}

.character_tools_hero_max {
  font-size: 0.5em;
  opacity: 0.5;
  font-weight: 400;
}

.character_tools_field {
  margin-bottom: var(--ct-spacing-md);
}

.character_tools_field:last-child {
  margin-bottom: 0;
}

.character_tools_field_value {
  line-height: 1.5;
}

.character_tools_nested {
  padding-left: var(--ct-spacing-lg);
  border-left: 2px solid var(--SmartThemeBorderColor);
  margin-top: var(--ct-spacing-sm);
}

.character_tools_list {
  margin: 0;
  padding-left: 20px;
  line-height: 1.6;
}

.character_tools_list li {
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_list li:last-child {
  margin-bottom: 0;
}

.character_tools_cards {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_card {
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
}

.character_tools_card_header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_card_title {
  font-weight: 600;
}

.character_tools_card_body {
  opacity: 0.9;
}

.character_tools_card_extra {
  margin-top: var(--ct-spacing-sm);
  padding-top: var(--ct-spacing-sm);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_score {
  font-weight: 700;
}

.character_tools_score_max {
  font-size: 0.7em;
  opacity: 0.5;
  font-weight: 400;
}

.character_tools_num {
  font-family: var(--monoFontFamily);
}

.character_tools_yes {
  color: var(--success, #2ecc71);
}

.character_tools_no {
  color: var(--failure, #e74c3c);
}

.character_tools_null,
.character_tools_empty {
  opacity: 0.5;
  font-style: italic;
}

.character_tools_link {
  color: var(--SmartThemeQuoteColor);
  text-decoration: underline;
}

.character_tools_text p {
  margin: 0.4em 0;
}

.character_tools_text p:first-child {
  margin-top: 0;
}

.character_tools_text p:last-child {
  margin-bottom: 0;
}

.character_tools_json {
  margin: 0;
  padding: var(--ct-spacing-sm);
  background: var(--SmartThemeChatTintColor);
  border-radius: var(--ct-radius-sm);
  font-size: 0.8em;
  overflow-x: auto;
  max-height: 200px;
}

/* ============================================================================
   MARKDOWN FORMATTING
   ============================================================================ */

.character_tools_markdown_content h1 {
  font-size: 1.4em;
  color: var(--SmartThemeQuoteColor);
  margin: 1em 0 0.5em;
  padding-bottom: 0.3em;
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_markdown_content h1:first-child {
  margin-top: 0;
}

.character_tools_markdown_content h2 {
  font-size: 1.2em;
  color: var(--SmartThemeQuoteColor);
  margin: 1em 0 0.4em;
}

.character_tools_markdown_content h3 {
  font-size: 1.1em;
  color: var(--SmartThemeQuoteColor);
  margin: 0.8em 0 0.3em;
}

.character_tools_markdown_content h4,
.character_tools_markdown_content h5,
.character_tools_markdown_content h6 {
  font-size: 1em;
  color: var(--SmartThemeQuoteColor);
  margin: 0.6em 0 0.2em;
}

.character_tools_markdown_content p {
  margin: 0.6em 0;
  line-height: 1.6;
}

.character_tools_markdown_content ul,
.character_tools_markdown_content ol {
  padding-left: 1.8em;
  margin: 0.6em 0;
}

.character_tools_markdown_content li {
  margin-bottom: 0.4em;
  line-height: 1.5;
}

.character_tools_markdown_content code {
  background: var(--SmartThemeChatTintColor);
  padding: 0.15em 0.4em;
  border-radius: 3px;
  font-size: 0.9em;
  font-family: var(--monoFontFamily);
}

.character_tools_markdown_content pre {
  background: var(--SmartThemeChatTintColor);
  padding: var(--ct-spacing-md);
  border-radius: var(--ct-radius-md);
  overflow-x: auto;
  margin: 0.8em 0;
  border: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_markdown_content pre code {
  background: none;
  padding: 0;
  font-size: 0.85em;
}

.character_tools_markdown_content blockquote {
  border-left: 3px solid var(--SmartThemeQuoteColor);
  margin: 0.8em 0;
  padding: 0.5em 0 0.5em 1em;
  background: var(--SmartThemeChatTintColor);
  border-radius: 0 var(--ct-radius-sm) var(--ct-radius-sm) 0;
}

.character_tools_markdown_content table {
  border-collapse: collapse;
  width: 100%;
  margin: 0.8em 0;
}

.character_tools_markdown_content th,
.character_tools_markdown_content td {
  border: 1px solid var(--SmartThemeBorderColor);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  text-align: left;
}

.character_tools_markdown_content th {
  background: var(--SmartThemeChatTintColor);
  font-weight: 600;
}

.character_tools_markdown_content hr {
  border: none;
  border-top: 1px solid var(--SmartThemeBorderColor);
  margin: 1.5em 0;
}

.character_tools_markdown_content a {
  color: var(--SmartThemeQuoteColor);
  text-decoration: underline;
}

/* ============================================================================
   ITERATION SYSTEM
   ============================================================================ */

/* Iteration Indicator in Header */
.character_tools_iteration_indicator {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.8em;
  font-weight: 600;
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
  margin-left: auto;
}

.character_tools_iteration_indicator.hidden {
  display: none;
}

/* Iteration History Panel */
.character_tools_iteration_history {
  margin-top: var(--ct-spacing-md);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  background: var(--SmartThemeBlurTintColor);
  overflow: hidden;
}

.character_tools_iteration_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  font-weight: 600;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_count {
  margin-left: auto;
  font-weight: normal;
  opacity: 0.7;
}

.character_tools_iteration_list {
  max-height: 200px;
  overflow-y: auto;
}

.character_tools_iteration_empty,
.character_tools_iteration_loading {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_loading {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--ct-spacing-sm);
}

/* Iteration Item */
.character_tools_iteration_item {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  transition: background var(--ct-transition);
}

.character_tools_iteration_item:last-child {
  border-bottom: none;
}

.character_tools_iteration_item:hover {
  background: var(--SmartThemeChatTintColor);
}

.character_tools_iteration_item_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  margin-bottom: var(--ct-spacing-xs);
  flex-wrap: wrap;
}

.character_tools_iteration_num {
  font-weight: 600;
  font-size: 0.9em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_iteration_verdict {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.8em;
  font-weight: 500;
}

.character_tools_iteration_time {
  margin-left: auto;
  font-size: 0.75em;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_preview {
  font-size: 0.85em;
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--SmartThemeBodyColor);
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_iteration_actions {
  display: flex;
  gap: var(--ct-spacing-xs);
}

.character_tools_iteration_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.8em;
}

/* Verdict Colors */
.character_tools_verdict_accept .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_accept {
  color: var(--success, #2ecc71);
}

.character_tools_verdict_needs_refinement .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_needs_refinement {
  color: var(--warning, #f39c12);
}

.character_tools_verdict_regression .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_regression {
  color: var(--failure, #e74c3c);
}

/* Verdict Badge in Results */
.character_tools_verdict_badge {
  display: inline-flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.75em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.character_tools_verdict_badge.character_tools_verdict_accept {
  background: rgba(46, 204, 113, 0.2);
}

.character_tools_verdict_badge.character_tools_verdict_needs_refinement {
  background: rgba(243, 156, 18, 0.2);
}

.character_tools_verdict_badge.character_tools_verdict_regression {
  background: rgba(231, 76, 60, 0.2);
}

/* Refine/Accept Button Styling */
.character_tools_refine_recommended {
  background: var(--warning, #f39c12) !important;
  color: #fff !important;
  border-color: var(--warning, #f39c12) !important;
}

.character_tools_refine_recommended:hover {
  filter: brightness(1.1);
}

.character_tools_accept_recommended {
  background: var(--success, #2ecc71) !important;
  color: #fff !important;
  border-color: var(--success, #2ecc71) !important;
}

.character_tools_accept_recommended:hover {
  filter: brightness(1.1);
}

.character_tools_iteration_badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  border-radius: 10px;
  background: var(--SmartThemeBorderColor);
  font-size: 0.75em;
  font-weight: 600;
  margin-left: var(--ct-spacing-xs);
}

/* Iteration View Modal */
.character_tools_iteration_view {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_view_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  flex-wrap: wrap;
}

.character_tools_iteration_view_header h3 {
  margin: 0;
  font-size: 1.2em;
}

.character_tools_iteration_view_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_iteration_view_section h4 {
  margin: 0;
  font-size: 1em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_iteration_view_content {
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  max-height: 300px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-size: 0.9em;
  line-height: 1.5;
}

/* ============================================================================
   LOADING OVERLAY
   ============================================================================ */

.character_tools_loading_overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}

.character_tools_loading_content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-xl);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  color: var(--SmartThemeBodyColor);
}

.character_tools_loading_content p {
  margin: 0;
  font-size: 0.95em;
}

/* ============================================================================
   APPLY PREVIEW (in confirmation popup)
   ============================================================================ */

.character_tools_apply_preview {
  margin-top: var(--ct-spacing-md);
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  font-size: 0.9em;
}

.character_tools_apply_preview p {
  margin: 0 0 var(--ct-spacing-sm);
}

.character_tools_apply_preview ul {
  margin: 0;
  padding-left: 1.5em;
}

.character_tools_apply_preview li {
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_apply_preview details {
  margin-top: var(--ct-spacing-sm);
}

.character_tools_apply_preview summary {
  cursor: pointer;
  opacity: 0.7;
}

.character_tools_apply_preview pre {
  margin: var(--ct-spacing-sm) 0 0;
  padding: var(--ct-spacing-sm);
  background: var(--SmartThemeBlurTintColor);
  border-radius: var(--ct-radius-sm);
  font-size: 0.85em;
  overflow-x: auto;
  max-height: 150px;
}

.character_tools_apply_warning {
  display: flex;
  align-items: flex-start;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm);
  background: rgba(243, 156, 18, 0.15);
  border-radius: var(--ct-radius-sm);
  color: var(--warning, #f39c12);
}

.character_tools_apply_warning i {
  flex-shrink: 0;
  margin-top: 2px;
}

/* ============================================================================
   UTILITIES
   ============================================================================ */

.hidden {
  display: none !important;
}

/* ============================================================================
   MOBILE - PORTRAIT (max-width: 600px)
   ============================================================================ */

@media (max-width: 600px) {
  /* Popup sizing */
  .character_tools_popup {
    min-width: unset;
    width: 100%;
    max-width: 100%;
    gap: var(--ct-spacing-md);
  }

  /* Header adjustments */
  .character_tools_popup_header {
    flex-wrap: wrap;
    gap: var(--ct-spacing-sm);
    padding: var(--ct-spacing-md);
    margin: calc(-1 * var(--ct-spacing-md)) calc(-1 * var(--ct-spacing-md)) 0;
  }

  .character_tools_popup_title {
    font-size: 1.1em;
  }

  .character_tools_popup_header_right {
    gap: var(--ct-spacing-sm);
  }

  .character_tools_api_status span {
    display: none;
  }

  /* Section headers */
  .character_tools_section_header {
    font-size: 0.9em;
  }

  /* Character select */
  .character_tools_char_header {
    padding: var(--ct-spacing-sm);
  }

  .character_tools_char_avatar {
    width: 40px;
    height: 40px;
  }

  .character_tools_char_name {
    font-size: 1em;
  }

  .character_tools_char_fields {
    max-height: 120px;
  }

  /* Pipeline nav */
  .character_tools_stage_row {
    gap: var(--ct-spacing-xs);
  }

  .character_tools_stage_btn {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
    font-size: 0.8em;
  }

  .character_tools_stage_btn span {
    display: none;
  }

  .character_tools_stage_connector {
    width: 12px;
    margin: 0 2px;
  }

  .character_tools_pipeline_actions {
    flex-direction: column;
    width: 100%;
  }

  .character_tools_pipeline_actions .menu_button {
    width: 100%;
    justify-content: center;
  }

  /* Stage config */
  .character_tools_config_header {
    flex-wrap: wrap;
  }

  .character_tools_preset_select {
    min-width: 100px;
    max-width: 160px;
    font-size: 0.85em;
  }

  .character_tools_prompt_textarea {
    min-height: 80px;
    font-size: 0.85em;
  }

  .character_tools_schema_textarea {
    min-height: 60px;
    font-size: 0.8em;
  }

  .character_tools_schema_actions {
    flex-wrap: wrap;
  }

  .character_tools_schema_actions .menu_button {
    flex: 1 1 auto;
    min-width: 80px;
  }

  /* Results */
  .character_tools_results_body {
    padding: var(--ct-spacing-sm);
    max-height: 250px;
    font-size: 0.9em;
  }

  .character_tools_results_toolbar {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }

  .character_tools_results_footer {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }

  .character_tools_footer_actions {
    flex-direction: column;
    width: 100%;
  }

  .character_tools_footer_actions .menu_button {
    width: 100%;
    justify-content: center;
  }

  /* Iteration history */
  .character_tools_iteration_list {
    max-height: 150px;
  }

  .character_tools_iteration_item_header {
    font-size: 0.85em;
  }

  .character_tools_iteration_actions {
    flex-wrap: wrap;
  }

  .character_tools_iteration_actions .menu_button {
    flex: 1;
  }

  /* Settings modal */
  .character_tools_settings_modal {
    min-width: unset;
    max-width: 100%;
  }

  .character_tools_settings_grid {
    grid-template-columns: 1fr;
  }

  .character_tools_settings_grid_5 {
    grid-template-columns: repeat(2, 1fr);
  }

  .character_tools_presets_grid {
    grid-template-columns: 1fr;
    gap: var(--ct-spacing-md);
  }

  .character_tools_shortcuts_list {
    font-size: 0.85em;
  }

  .character_tools_shortcut_item kbd {
    padding: 2px 6px;
    font-size: 0.8em;
  }

  /* Structured output */
  .character_tools_hero {
    flex-direction: column;
    text-align: center;
    gap: var(--ct-spacing-sm);
    padding: var(--ct-spacing-md);
  }

  .character_tools_hero_value {
    font-size: 1.5em;
  }

  .character_tools_card {
    padding: var(--ct-spacing-sm);
  }

  /* Markdown */
  .character_tools_markdown_content h1 {
    font-size: 1.2em;
  }

  .character_tools_markdown_content h2 {
    font-size: 1.1em;
  }

  .character_tools_markdown_content h3 {
    font-size: 1em;
  }

  .character_tools_markdown_content pre {
    padding: var(--ct-spacing-sm);
    font-size: 0.8em;
  }

  .character_tools_markdown_content table {
    font-size: 0.85em;
  }

  .character_tools_markdown_content th,
  .character_tools_markdown_content td {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }
}

/* ============================================================================
   MOBILE - LANDSCAPE (max-height: 500px and orientation: landscape)
   Prioritize horizontal space, compress vertical
   ============================================================================ */

@media (max-height: 500px) and (orientation: landscape) {
  /* Popup - use available width better */
  .character_tools_popup {
    gap: var(--ct-spacing-sm);
    min-width: unset;
    max-width: 95vw;
  }

  /* Header - compact but keep all elements visible */
  .character_tools_popup_header {
    padding: var(--ct-spacing-xs) var(--ct-spacing-md);
    margin: calc(-1 * var(--ct-spacing-sm)) calc(-1 * var(--ct-spacing-sm)) 0;
    gap: var(--ct-spacing-sm);
  }

  .character_tools_popup_title {
    font-size: 1em;
  }

  .character_tools_popup_header_right {
    gap: var(--ct-spacing-xs);
  }

  /* Keep API status text visible in landscape - we have width */
  .character_tools_api_status span {
    display: inline;
  }

  .character_tools_icon_btn {
    width: 28px;
    height: 28px;
  }

  /* Sections - tighter */
  .character_tools_section {
    gap: var(--ct-spacing-xs);
  }

  .character_tools_section_header {
    font-size: 0.85em;
  }

  /* Character select - minimal height */
  .character_tools_char_header {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }

  .character_tools_char_avatar {
    width: 32px;
    height: 32px;
  }

  .character_tools_char_name {
    font-size: 0.95em;
  }

  .character_tools_char_fields {
    max-height: 60px;
  }

  /* Pipeline - horizontal layout works, just compress */
  .character_tools_stage_row {
    gap: var(--ct-spacing-xs);
  }

  .character_tools_stage_btn {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
    font-size: 0.8em;
  }

  /* Keep stage labels in landscape - we have width */
  .character_tools_stage_btn span {
    display: inline;
  }

  .character_tools_stage_connector {
    width: 16px;
  }

  /* Pipeline actions - horizontal row, not stacked */
  .character_tools_pipeline_actions {
    flex-direction: row;
    flex-wrap: nowrap;
  }

  .character_tools_pipeline_actions .menu_button {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
    font-size: 0.8em;
  }

  /* Stage config - side by side where possible */
  .character_tools_config_header {
    gap: var(--ct-spacing-sm);
  }

  .character_tools_preset_select {
    min-width: 100px;
    max-width: 180px;
    font-size: 0.85em;
  }

  .character_tools_prompt_textarea {
    min-height: 50px;
    font-size: 0.85em;
  }

  .character_tools_schema_textarea {
    min-height: 40px;
  }

  /* Results - compressed height */
  .character_tools_results_body {
    max-height: 120px;
    padding: var(--ct-spacing-sm);
    font-size: 0.85em;
  }

  .character_tools_results_toolbar,
  .character_tools_results_footer {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }

  /* Footer actions - horizontal */
  .character_tools_footer_actions {
    flex-direction: row;
    flex-wrap: wrap;
  }

  .character_tools_footer_actions .menu_button {
    font-size: 0.8em;
  }

  /* Iteration - minimal */
  .character_tools_iteration_list {
    max-height: 80px;
  }

  .character_tools_iteration_view_content {
    max-height: 120px;
  }

  /* Settings modal - critical fixes */
  .character_tools_settings_modal {
    min-width: unset;
    max-width: 90vw;
    gap: var(--ct-spacing-md);
  }

  .character_tools_settings_header {
    font-size: 1em;
    padding-bottom: var(--ct-spacing-sm);
  }

  .character_tools_settings_section {
    gap: var(--ct-spacing-xs);
  }

  .character_tools_settings_section_header {
    font-size: 0.9em;
  }

  /* Settings grid - 3 columns max in landscape to prevent overflow */
  .character_tools_settings_grid_5 {
    grid-template-columns: repeat(3, 1fr);
    gap: var(--ct-spacing-xs);
  }

  .character_tools_settings_field label {
    font-size: 0.8em;
  }

  .character_tools_settings_field .text_pole {
    font-size: 0.85em;
    padding: var(--ct-spacing-xs);
  }

  .character_tools_system_prompt_textarea {
    min-height: 60px;
    font-size: 0.85em;
  }

  /* Presets grid - side by side */
  .character_tools_presets_grid {
    grid-template-columns: 1fr 1fr;
    gap: var(--ct-spacing-sm);
  }

  .character_tools_preset_list {
    max-height: 80px;
  }

  /* Shortcuts - inline */
  .character_tools_shortcuts_list {
    flex-direction: row;
    flex-wrap: wrap;
    gap: var(--ct-spacing-md);
  }

  .character_tools_shortcut_item {
    font-size: 0.8em;
  }

  /* Debug section */
  .character_tools_debug_log_list,
  .character_tools_debug_log_detail {
    max-height: 60px;
  }
}

/* ============================================================================
   LANDSCAPE - VERY SHORT (max-height: 400px)
   Extreme compression for very short viewports
   ============================================================================ */

@media (max-height: 400px) and (orientation: landscape) {
  .character_tools_popup {
    gap: var(--ct-spacing-xs);
  }

  .character_tools_popup_header {
    padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  }

  .character_tools_popup_title {
    font-size: 0.9em;
  }

  .character_tools_popup_title i {
    display: none;
  }

  .character_tools_section_header {
    font-size: 0.8em;
  }

  .character_tools_section_header i {
    display: none;
  }

  .character_tools_char_fields {
    display: none;
  }

  .character_tools_stage_btn span {
    display: none;
  }

  .character_tools_prompt_textarea {
    min-height: 40px;
  }

  .character_tools_results_body {
    max-height: 80px;
  }

  .character_tools_iteration_history {
    display: none;
  }

  /* Settings - even more compact */
  .character_tools_settings_grid_5 {
    grid-template-columns: repeat(5, 1fr);
    gap: 2px;
  }

  .character_tools_settings_field label {
    font-size: 0.7em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .character_tools_settings_field .text_pole {
    font-size: 0.8em;
    padding: 2px 4px;
    height: 28px;
  }
}

/* ============================================================================
   TABLET (601px - 768px)
   ============================================================================ */

@media (min-width: 601px) and (max-width: 768px) {
  .character_tools_popup {
    min-width: unset;
    max-width: 100%;
  }

  .character_tools_settings_grid_5 {
    grid-template-columns: repeat(3, 1fr);
  }

  .character_tools_stage_btn span {
    display: inline;
  }

  .character_tools_footer_actions {
    flex-wrap: wrap;
  }

  .character_tools_footer_actions .menu_button {
    flex: 1 1 auto;
    min-width: 120px;
  }
}

/* ============================================================================
   REDUCED MOTION
   ============================================================================ */

@media (prefers-reduced-motion: reduce) {
  .character_tools_popup *,
  .character_tools_settings_modal * {
    transition: none !important;
    animation: none !important;
  }
}

/* ============================================================================
   HIGH CONTRAST MODE SUPPORT
   ============================================================================ */

@media (prefers-contrast: high) {
  .character_tools_popup,
  .character_tools_settings_modal {
    --ct-radius-sm: 2px;
    --ct-radius-md: 3px;
    --ct-radius-lg: 4px;
  }

  .character_tools_badge,
  .character_tools_verdict_badge,
  .character_tools_iteration_indicator {
    border: 1px solid currentColor;
  }

  .character_tools_stage_btn,
  .character_tools_popup .menu_button,
  .character_tools_settings_modal .menu_button {
    border-width: 2px;
  }

  .character_tools_stage_btn.active,
  .character_tools_continue_btn,
  .character_tools_apply_btn,
  .character_tools_refine_recommended,
  .character_tools_accept_recommended {
    outline: 2px solid currentColor;
    outline-offset: 2px;
  }
}
```

## FILE: manifest.json
```json
{
  "display_name": "Character Tools",
  "loading_order": 1,
  "requires": [],
  "optional": [],
  "dependencies": [],
  "js": "dist/index.js",
  "css": "style.css",
  "author": "Inktomi",
  "version": "1.0.0",
  "homePage": "https://github.com/Inktomi93/SillyTavern-CharacterTools",
  "auto_update": true,
  "minimum_client_version": "",
  "i18n": {}
}
```

## FILE: globals.d.ts
```ts
// globals.d.ts
export {};

// Development: absolute path to your ST install
import '/home/inktomi/SillyTavern/public/global';

// Production paths (uncomment when publishing, comment out dev path above)
// import '../../../../public/global'; // user-scoped
// import '../../../../global'; // server-scoped

// Extend ST's types with what we need
declare global {
  // toastr is a global loaded by ST
  const toastr: {
    success: (message: string, title?: string) => void;
    error: (message: string, title?: string) => void;
    warning: (message: string, title?: string) => void;
    info: (message: string, title?: string) => void;
  };

  interface PresetManager {
    apiId: string;
    getPresetList: (api?: string) => {
      presets: Record<string, unknown>[];
      preset_names: Record<string, number>;
      settings: Record<string, unknown>;
    };
    getSelectedPreset: () => unknown;
    getSelectedPresetName: () => string;
    selectPreset: (value: string) => boolean;
    getAllPresets: () => unknown[];
  }

  interface ChatCompletionResult {
    content: string;
    reasoning?: string;
  }

  interface ChatCompletionRequestOptions {
    stream: boolean;
    messages: Array<{ role: string; content: string }>;
    max_tokens?: number;
    temperature?: number;
  }

  interface ChatCompletionService {
    sendRequest: (options: ChatCompletionRequestOptions) => Promise<ChatCompletionResult>;
    processRequest: (
      options: ChatCompletionRequestOptions,
      presetOptions: { presetName?: string },
      extractData: boolean,
      signal: AbortSignal | null
    ) => Promise<ChatCompletionResult>;
  }
}
```

## FILE: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES6",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "./out",
    "strict": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "globals.d.ts"],
  "exclude": ["node_modules", "dist", "bin"]
}
```

## FILE: webpack.config.js
```js
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import TerserPlugin from 'terser-webpack-plugin';

const __dirname =
  import.meta.dirname ?? path.dirname(fileURLToPath(import.meta.url));

export default {
    mode: 'production',
    entry: path.join(__dirname, 'src/index.ts'),
    output: {
        path: path.join(__dirname, 'dist/'),
        filename: 'index.js',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: 'ts-loader',
                exclude: /node_modules/,
            },
        ],
    },
    optimization: {
        minimizer: [
            new TerserPlugin({
                extractComments: false,
                terserOptions: {
                    format: {
                        comments: false,
                    },
                },
            }),
        ],
    },
};
```

## FILE: package.json
```json
{
  "name": "extension-webpack-template",
  "type": "module",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "webpack --mode production",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "css-loader": "^7.1.2",
    "globals": "^16.0.0",
    "html-loader": "^5.1.0",
    "style-loader": "^4.0.0",
    "ts-loader": "^9.5.1",
    "typescript-eslint": "^8.29.0",
    "webpack-cli": "^5.1.4"
  }
}
```

