# PROJECT SNAPSHOT
Generated: Fri Dec 26 06:57:45 AM MST 2025

## DIRECTORY STRUCTURE
```
.
├── CONTRIBUTING.md
├── eslint.config.mjs
├── globals.d.ts
├── LICENSE
├── manifest.json
├── package.json
├── package-lock.json
├── project_snapshot.txt
├── README.md
├── snapshot.sh
├── src
│   ├── character.ts
│   ├── constants.ts
│   ├── debug.ts
│   ├── generator.ts
│   ├── index.ts
│   ├── pipeline.ts
│   ├── presets.ts
│   ├── schema.ts
│   ├── settings.ts
│   ├── types.ts
│   └── ui
│       ├── components
│       │   ├── character-select.ts
│       │   ├── iteration-history.ts
│       │   ├── pipeline-nav.ts
│       │   ├── results-panel.ts
│       │   └── stage-config.ts
│       ├── formatter.ts
│       ├── panel.ts
│       ├── popup.ts
│       └── settings-modal.ts
├── style.css
├── templates
│   └── panel.html
├── tsconfig.json
└── webpack.config.js
```

## FILE: src/index.ts
```ts
// src/index.ts
//
// Extension entry point

import { getSettings } from './settings';
import { initPanel } from './ui/panel';
import { debugLog } from './debug';

function init(): void {
    debugLog('info', 'Extension initializing', { version: '2.0.0' });

    initPanel();
    registerEventListeners();

    debugLog('info', 'Extension loaded', getSettings());
}

function registerEventListeners(): void {
    const { eventSource, eventTypes } = SillyTavern.getContext();

    // Log API changes for debugging
    eventSource.on(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, () => {
        debugLog('info', 'Chat completion source changed', null);
    });

    eventSource.on(eventTypes.CHATCOMPLETION_MODEL_CHANGED, () => {
        debugLog('info', 'Chat completion model changed', null);
    });

    debugLog('info', 'Event listeners registered', null);
}

// Wait for app ready
const { eventSource, eventTypes } = SillyTavern.getContext();
eventSource.on(eventTypes.APP_READY, init);
```

## FILE: src/types.ts
```ts
// src/types.ts

// ============================================================================
// CORE TYPES
// ============================================================================

export type StageName = 'score' | 'rewrite' | 'analyze';

export type StageStatus = 'pending' | 'running' | 'complete' | 'skipped';

// ============================================================================
// CHARACTER
// ============================================================================

export interface Character {
  name: string;
  avatar: string;
  description: string;
  personality: string;
  first_mes: string;
  mes_example: string;
  scenario: string;
  system_prompt?: string;
  post_history_instructions?: string;
  creator_notes?: string;
  tags?: string[];
}

export interface CharacterField {
  key: keyof Character;
  label: string;
  scoreable: boolean;
}

export interface PopulatedField {
  key: string;
  label: string;
  value: string;
  charCount: number;
  scoreable: boolean;
}

// ============================================================================
// GENERATION
// ============================================================================

export interface GenerationConfig {
  source: string;
  model: string;
  temperature: number;
  maxTokens: number;
  frequencyPenalty: number;
  presencePenalty: number;
  topP: number;
}

export type GenerationResult =
  | { success: true; response: string; isStructured: boolean }
  | { success: false; error: string };

// ============================================================================
// SCHEMA
// ============================================================================

export interface StructuredOutputSchema {
  name: string;
  strict?: boolean;
  value: JsonSchemaValue;
}

export interface JsonSchemaValue {
  $schema?: string;
  type: string;
  properties?: Record<string, unknown>;
  required?: string[];
  additionalProperties?: boolean;
  items?: unknown;
  $defs?: Record<string, JsonSchemaValue>;
  definitions?: Record<string, JsonSchemaValue>;
  anyOf?: unknown[];
  allOf?: unknown[];
  enum?: unknown[];
  const?: unknown;
  format?: string;
  pattern?: string;
  description?: string;
  title?: string;
  default?: unknown;
  $ref?: string;
  minItems?: number;
  [key: string]: unknown;
}

export interface SchemaValidationResult {
  valid: boolean;
  error?: string;
  warnings?: string[];
  info?: string[];
  schema?: StructuredOutputSchema;
}

// ============================================================================
// PRESETS
// ============================================================================

export interface PromptPreset {
  id: string;
  name: string;
  prompt: string;
  stages: StageName[];  // Empty array = available for all stages
  isBuiltin: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface SchemaPreset {
  id: string;
  name: string;
  schema: StructuredOutputSchema;
  stages: StageName[];  // Empty array = available for all stages
  isBuiltin: boolean;
  createdAt: number;
  updatedAt: number;
}

// ============================================================================
// STAGE CONFIGURATION
// ============================================================================

export interface StageDefaults {
  promptPresetId: string | null;  // null = use customPrompt
  customPrompt: string;
  schemaPresetId: string | null;  // null = use customSchema or none
  customSchema: string;           // JSON string, empty = no schema
  useStructuredOutput: boolean;
}

export interface StageConfig {
  promptPresetId: string | null;
  customPrompt: string;
  schemaPresetId: string | null;
  customSchema: string;
  useStructuredOutput: boolean;
}

// ============================================================================
// ITERATION SYSTEM
// ============================================================================

export type IterationVerdict = 'accept' | 'needs_refinement' | 'regression';

export interface IterationSnapshot {
  iteration: number;
  rewriteResponse: string;
  rewritePreview: string;  // First 200 chars for UI display
  analysisResponse: string;
  analysisPreview: string;
  verdict: IterationVerdict;
  timestamp: number;
}

// ============================================================================
// PIPELINE
// ============================================================================

export interface StageResult {
  response: string;
  isStructured: boolean;
  promptUsed: string;
  schemaUsed: StructuredOutputSchema | null;
  timestamp: number;
  locked: boolean;
}

export interface PipelineState {
  // Selected character
  character: Character | null;
  characterIndex: number | null;

  // Stage results
  results: {
    score: StageResult | null;
    rewrite: StageResult | null;
    analyze: StageResult | null;
  };

  // Stage configs (runtime, may differ from defaults)
  configs: {
    score: StageConfig;
    rewrite: StageConfig;
    analyze: StageConfig;
  };

  // Pipeline flow
  selectedStages: StageName[];
  currentStage: StageName | null;
  stageStatus: Record<StageName, StageStatus>;

  // Iteration system
  iterationCount: number;
  iterationHistory: IterationSnapshot[];
  isRefining: boolean;  // True when in refinement mode (after first analyze)

  // Export
  exportData: string | null;
}

// ============================================================================
// SETTINGS
// ============================================================================

export interface Settings {
  // Generation settings
  useCurrentSettings: boolean;
  generationConfig: GenerationConfig;
  systemPrompt: string;

  // Presets
  promptPresets: PromptPreset[];
  schemaPresets: SchemaPreset[];

  // Per-stage defaults
  stageDefaults: Record<StageName, StageDefaults>;

  // Refinement settings
  refinementPrompt: string;

  // Debug
  debugMode: boolean;

  // Version for migrations
  settingsVersion: number;
}

// ============================================================================
// DEBUG
// ============================================================================

export type DebugLogType = 'request' | 'response' | 'error' | 'info' | 'state';

export interface DebugLogEntry {
  timestamp: Date;
  type: DebugLogType;
  label: string;
  data: unknown;
}

// ============================================================================
// UI STATE
// ============================================================================

export interface PopupState {
  isOpen: boolean;
  isGenerating: boolean;
  abortController: AbortController | null;
  activePanel: 'main' | 'settings';
  expandedFields: Set<string>;  // Character field keys that are expanded
}

// ============================================================================
// COMPONENT PROPS (for future component isolation)
// ============================================================================

export interface CharacterSelectProps {
  characters: Character[];
  selectedIndex: number | null;
  onSelect: (char: Character, index: number) => void;
  onClear: () => void;
}

export interface PipelineNavProps {
  selectedStages: StageName[];
  stageStatus: Record<StageName, StageStatus>;
  currentStage: StageName | null;
  onToggleStage: (stage: StageName) => void;
  onSelectStage: (stage: StageName) => void;
  onRunSelected: () => void;
  onRunAll: () => void;
  onReset: () => void;
  hasCharacter: boolean;
}

export interface StageConfigProps {
  stage: StageName;
  config: StageConfig;
  promptPresets: PromptPreset[];
  schemaPresets: SchemaPreset[];
  onConfigChange: (config: Partial<StageConfig>) => void;
  onSavePromptPreset: (name: string) => void;
  onSaveSchemaPreset: (name: string) => void;
  tokenEstimate: number | null;
  contextSize: number;
}

export interface ResultsPanelProps {
  stage: StageName;
  result: StageResult | null;
  status: StageStatus;
  onRegenerate: () => void;
  onLock: () => void;
  onUnlock: () => void;
  onContinue: () => void;
  onCopy: () => void;
  nextStage: StageName | null;
  canContinue: boolean;
}
```

## FILE: src/constants.ts
```ts
// src/constants.ts
import type {
    CharacterField,
    StructuredOutputSchema,
    PromptPreset,
    SchemaPreset,
    StageDefaults,
    StageName,
    GenerationConfig,
    Settings,
} from './types';

// ============================================================================
// MODULE INFO
// ============================================================================

export const MODULE_NAME = 'character_tools';
export const EXTENSION_PATH = 'third-party/my-extension';
export const SETTINGS_VERSION = 3;  // Bump for refinement additions

// ============================================================================
// CHARACTER FIELDS
// ============================================================================

export const CHARACTER_FIELDS: readonly CharacterField[] = Object.freeze([
    { key: 'description', label: 'Description', scoreable: true },
    { key: 'personality', label: 'Personality', scoreable: true },
    { key: 'first_mes', label: 'First Message', scoreable: true },
    { key: 'scenario', label: 'Scenario', scoreable: true },
    { key: 'mes_example', label: 'Example Messages', scoreable: true },
    { key: 'system_prompt', label: 'System Prompt', scoreable: true },
    { key: 'post_history_instructions', label: 'Post-History Instructions', scoreable: false },
    { key: 'creator_notes', label: 'Creator Notes', scoreable: false },
]);

// ============================================================================
// STAGE DEFINITIONS
// ============================================================================

export const STAGES: readonly StageName[] = Object.freeze(['score', 'rewrite', 'analyze']);

export const STAGE_LABELS: Record<StageName, string> = {
    score: 'Score',
    rewrite: 'Rewrite',
    analyze: 'Analyze',
};

export const STAGE_ICONS: Record<StageName, string> = {
    score: 'fa-star-half-stroke',
    rewrite: 'fa-pen-fancy',
    analyze: 'fa-magnifying-glass-chart',
};

export const STAGE_DESCRIPTIONS: Record<StageName, string> = {
    score: 'Rate and critique the character card',
    rewrite: 'Generate an improved version',
    analyze: 'Compare original vs rewrite, check for soul loss',
};

// ============================================================================
// DEFAULT SYSTEM PROMPT
// ============================================================================

export const DEFAULT_SYSTEM_PROMPT = `You are a creative writing assistant specializing in character development for roleplay and fiction. Analyze character cards and provide thoughtful, actionable feedback.

Adapt your response style to the task:
- For scoring: Be critical but fair, rate 1-10 with specific justifications
- For rewrites: Preserve the character's core identity while improving weak areas
- For analysis: Compare versions objectively, identify what was lost or gained
- For refinement: Address specific issues from analysis while keeping improvements

Focus on: writing quality, character depth, consistency, roleplay usability, and potential issues (contradictions, clichés, underdeveloped areas).

Always maintain the character's essential personality and unique traits. Improvements should enhance, not replace, what makes the character interesting.`;

// ============================================================================
// DEFAULT REFINEMENT PROMPT
// ============================================================================

export const DEFAULT_REFINEMENT_PROMPT = `You are refining a character card rewrite based on analysis feedback.

## Original Character (Ground Truth)
{{original_character}}

## Current Rewrite (Iteration {{iteration_number}})
{{current_rewrite}}

## Analysis of Current Rewrite
{{current_analysis}}

{{#if score_results}}
## Original Score Feedback (Reference)
{{score_results}}
{{/if}}

---

## Your Task

Create an improved version that:

1. **Addresses Issues**: Fix the specific problems identified in the analysis
2. **Preserves Wins**: Keep what the analysis said was working well
3. **Maintains Soul**: The character must still feel like the original, just better
4. **Avoids Regression**: Don't reintroduce problems that were already fixed

Output the complete refined character card with all fields. Mark significantly changed sections with [REFINED] at the start.

Do NOT explain your changes - just output the improved character card.`;

// ============================================================================
// BUILTIN PROMPT PRESETS
// ============================================================================

export const BUILTIN_PROMPT_PRESETS: readonly PromptPreset[] = Object.freeze([
    {
        id: 'builtin_score_default',
        name: 'Default Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Rate this character card on a scale of 1-10 for each populated field. For each field, provide:

1. **Score** (1-10)
2. **Strengths** - What works well
3. **Weaknesses** - What needs improvement
4. **Specific Suggestions** - Concrete changes to improve it

After scoring all fields, provide:
- **Overall Score** (weighted average, with First Message and Description weighted higher)
- **Top 3 Priority Improvements** - The changes that would have the biggest impact
- **Summary** - A brief overall assessment

Be critical but constructive. Vague praise is useless. Specific, actionable feedback is gold.`,
    },
    {
        id: 'builtin_score_quick',
        name: 'Quick Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Give a quick assessment of this character card:

1. Overall score (1-10)
2. Three biggest strengths
3. Three areas needing work
4. One-sentence summary

Keep it concise but useful.`,
    },
    {
        id: 'builtin_rewrite_default',
        name: 'Default Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Based on the scoring feedback, rewrite this character card to address the identified weaknesses while preserving its strengths.

Guidelines:
- Maintain the character's core personality and unique traits
- Improve weak areas identified in the score
- Keep the same general length unless brevity/expansion was specifically noted
- Preserve any distinctive voice or style that works
- Fix contradictions and fill gaps
- Make the character more engaging for roleplay

Output the complete rewritten character card with all fields, using the same field structure as the original. Mark significantly changed sections with [REVISED] at the start.

{{score_results}}`,
    },
    {
        id: 'builtin_rewrite_conservative',
        name: 'Conservative Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Make minimal, surgical improvements to this character card. Only change what's clearly broken or weak.

Rules:
- Change as little as possible
- Preserve the author's voice completely
- Only fix obvious issues (contradictions, grammar, clarity)
- Do NOT add new content unless filling a critical gap
- Do NOT change style or tone

Output only the fields you changed, with [ORIGINAL] and [REVISED] versions for comparison.

{{score_results}}`,
    },
    {
        id: 'builtin_rewrite_expansive',
        name: 'Expansive Rewrite',
        stages: ['rewrite'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Significantly expand and enhance this character card. Add depth, detail, and richness.

Goals:
- Flesh out underdeveloped areas
- Add sensory details and specific examples
- Deepen personality with quirks, contradictions, history
- Improve example messages with more variety
- Make the character feel more three-dimensional

Don't change the core concept, but make it shine. Output the complete expanded character card.

{{score_results}}`,
    },
    {
        id: 'builtin_analyze_default',
        name: 'Default Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Compare the original character card with the rewritten version. Analyze:

## What Was Preserved
- Core personality traits that remained intact
- Distinctive elements that were kept
- Voice and style consistency

## What Was Lost
- Any personality aspects that were diminished or removed
- Unique quirks that disappeared
- Tone shifts that changed the character's feel

## What Was Gained
- New depth or detail added
- Improvements that enhance the character
- Better clarity or consistency

## Soul Check
Does the rewritten version still feel like the same character? Rate the "soul preservation" from 1-10 and explain.

## Verdict
State clearly: **ACCEPT** (ready to use), **NEEDS REFINEMENT** (good progress but has issues), or **REGRESSION** (worse than before).

## Specific Issues to Address
If verdict is NEEDS REFINEMENT, list the specific problems that should be fixed in the next iteration.

---

### Original Character:
{{original_character}}

### Rewritten Version:
{{rewrite_results}}

### Score Feedback:
{{score_results}}`,
    },
    {
        id: 'builtin_analyze_iteration',
        name: 'Iteration Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `This is iteration {{iteration_number}} of refinement. Compare the current rewrite against the original.

## Progress Check
- What issues from previous analysis were addressed?
- What new issues (if any) were introduced?
- Is this version better, worse, or lateral move from the last?

## Current State Assessment

### Preserved from Original
Core traits and elements that remain intact.

### Still Missing or Lost
Things from the original that should be restored.

### Successfully Improved
What's genuinely better now.

### New Problems
Any issues introduced by this iteration.

## Soul Preservation Score
Rate 1-10: Does this still feel like the original character?

## Verdict
**ACCEPT** - Ready to use, no more iterations needed
**NEEDS REFINEMENT** - Making progress, but specific issues remain
**REGRESSION** - This iteration made things worse, consider reverting

## Next Steps
If NEEDS REFINEMENT: List exactly what the next iteration should fix.
If REGRESSION: Explain what went wrong and what to preserve from previous version.

---

### Original Character:
{{original_character}}

### Current Rewrite (Iteration {{iteration_number}}):
{{rewrite_results}}`,
    },
    {
        id: 'builtin_analyze_quick',
        name: 'Quick Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: `Quick comparison of original vs rewrite:

1. Soul preserved? (Yes/Partially/No)
2. Best improvement made
3. Biggest thing lost (if any)
4. Verdict: ACCEPT / NEEDS REFINEMENT / REGRESSION

{{original_character}}

{{rewrite_results}}`,
    },
    {
        id: 'builtin_freeform',
        name: 'Freeform',
        stages: [],  // Available for all stages
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        prompt: '[Enter your custom instructions here]',
    },
]);

// ============================================================================
// BUILTIN SCHEMA PRESETS
// ============================================================================

const SCORE_SCHEMA: StructuredOutputSchema = {
    name: 'CharacterScore',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            fieldScores: {
                type: 'array',
                items: {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        field: { type: 'string' },
                        score: { type: 'number' },
                        strengths: { type: 'string' },
                        weaknesses: { type: 'string' },
                        suggestions: { type: 'string' },
                    },
                    required: ['field', 'score', 'strengths', 'weaknesses', 'suggestions'],
                },
            },
            overallScore: { type: 'number' },
            priorityImprovements: {
                type: 'array',
                items: { type: 'string' },
            },
            summary: { type: 'string' },
        },
        required: ['fieldScores', 'overallScore', 'priorityImprovements', 'summary'],
    },
};

const QUICK_SCORE_SCHEMA: StructuredOutputSchema = {
    name: 'QuickScore',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            overallScore: { type: 'number' },
            strengths: {
                type: 'array',
                items: { type: 'string' },
            },
            weaknesses: {
                type: 'array',
                items: { type: 'string' },
            },
            summary: { type: 'string' },
        },
        required: ['overallScore', 'strengths', 'weaknesses', 'summary'],
    },
};

const ANALYZE_SCHEMA: StructuredOutputSchema = {
    name: 'CharacterAnalysis',
    strict: true,
    value: {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object',
        additionalProperties: false,
        properties: {
            preserved: {
                type: 'array',
                items: { type: 'string' },
            },
            lost: {
                type: 'array',
                items: { type: 'string' },
            },
            gained: {
                type: 'array',
                items: { type: 'string' },
            },
            soulPreservationScore: { type: 'number' },
            soulAssessment: { type: 'string' },
            verdict: {
                type: 'string',
                enum: ['ACCEPT', 'NEEDS_REFINEMENT', 'REGRESSION'],
            },
            issuesToAddress: {
                type: 'array',
                items: { type: 'string' },
            },
            recommendations: {
                type: 'array',
                items: { type: 'string' },
            },
        },
        required: ['preserved', 'lost', 'gained', 'soulPreservationScore', 'soulAssessment', 'verdict', 'issuesToAddress', 'recommendations'],
    },
};

export const BUILTIN_SCHEMA_PRESETS: readonly SchemaPreset[] = Object.freeze([
    {
        id: 'builtin_schema_score',
        name: 'Default Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: SCORE_SCHEMA,
    },
    {
        id: 'builtin_schema_quick_score',
        name: 'Quick Score',
        stages: ['score'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: QUICK_SCORE_SCHEMA,
    },
    {
        id: 'builtin_schema_analyze',
        name: 'Default Analyze',
        stages: ['analyze'],
        isBuiltin: true,
        createdAt: 0,
        updatedAt: 0,
        schema: ANALYZE_SCHEMA,
    },
]);

// ============================================================================
// DEFAULT STAGE CONFIGS
// ============================================================================

export const DEFAULT_STAGE_DEFAULTS: Record<StageName, StageDefaults> = {
    score: {
        promptPresetId: 'builtin_score_default',
        customPrompt: '',
        schemaPresetId: 'builtin_schema_score',
        customSchema: '',
        useStructuredOutput: false,  // Off by default, user can enable
    },
    rewrite: {
        promptPresetId: 'builtin_rewrite_default',
        customPrompt: '',
        schemaPresetId: null,  // Rewrite typically doesn't use structured output
        customSchema: '',
        useStructuredOutput: false,
    },
    analyze: {
        promptPresetId: 'builtin_analyze_default',
        customPrompt: '',
        schemaPresetId: 'builtin_schema_analyze',
        customSchema: '',
        useStructuredOutput: false,
    },
};

// ============================================================================
// DEFAULT GENERATION CONFIG
// ============================================================================

export const DEFAULT_GENERATION_CONFIG: GenerationConfig = {
    source: 'openrouter',
    model: 'anthropic/claude-sonnet-4',
    temperature: 1,
    maxTokens: 4096,
    frequencyPenalty: 0,
    presencePenalty: 0,
    topP: 1,
};

// ============================================================================
// COMPLETE DEFAULT SETTINGS
// ============================================================================

export const DEFAULT_SETTINGS: Settings = Object.freeze({
    useCurrentSettings: true,
    generationConfig: DEFAULT_GENERATION_CONFIG,
    systemPrompt: DEFAULT_SYSTEM_PROMPT,
    promptPresets: [...BUILTIN_PROMPT_PRESETS],
    schemaPresets: [...BUILTIN_SCHEMA_PRESETS],
    stageDefaults: DEFAULT_STAGE_DEFAULTS,
    refinementPrompt: DEFAULT_REFINEMENT_PROMPT,
    debugMode: false,
    settingsVersion: SETTINGS_VERSION,
});

// ============================================================================
// TEMPLATE PLACEHOLDERS
// ============================================================================

// These placeholders can be used in prompts and will be replaced at runtime
export const TEMPLATE_PLACEHOLDERS = {
    ORIGINAL_CHARACTER: '{{original_character}}',
    SCORE_RESULTS: '{{score_results}}',
    REWRITE_RESULTS: '{{rewrite_results}}',
    CURRENT_REWRITE: '{{current_rewrite}}',
    CURRENT_ANALYSIS: '{{current_analysis}}',
    ITERATION_NUMBER: '{{iteration_number}}',
    CHARACTER_NAME: '{{char_name}}',
    USER_NAME: '{{user_name}}',
} as const;

// ============================================================================
// UI CONSTANTS
// ============================================================================

export const TOKEN_WARNING_THRESHOLD = 0.5;   // 50% of context
export const TOKEN_DANGER_THRESHOLD = 0.8;    // 80% of context

export const DEBOUNCE_DELAY = {
    SEARCH: 150,
    TOKEN_ESTIMATE: 300,
    SAVE: 500,
    VALIDATE: 500,
} as const;

export const MAX_DROPDOWN_RESULTS = 10;
export const MAX_DEBUG_LOG_ENTRIES = 100;
export const MAX_ITERATION_HISTORY = 20;  // Don't keep more than this many snapshots

// ============================================================================
// CSS CLASS PREFIX
// ============================================================================

// All CSS classes should use this prefix
export const CSS_PREFIX = 'character_tools';

// Helper to generate prefixed class names
export function css(...names: string[]): string {
    return names.map(n => `${CSS_PREFIX}_${n}`).join(' ');
}

// Helper for BEM-style classes
export function bem(block: string, element?: string, modifier?: string): string {
    let className = `${CSS_PREFIX}_${block}`;
    if (element) className += `__${element}`;
    if (modifier) className += `--${modifier}`;
    return className;
}
```

## FILE: src/settings.ts
```ts
// src/settings.ts
import {
    MODULE_NAME,
    DEFAULT_SETTINGS,
    DEFAULT_SYSTEM_PROMPT,
    DEFAULT_GENERATION_CONFIG,
    DEFAULT_STAGE_DEFAULTS,
    DEFAULT_REFINEMENT_PROMPT,
    BUILTIN_PROMPT_PRESETS,
    BUILTIN_SCHEMA_PRESETS,
    SETTINGS_VERSION,
} from './constants';
import type {
    Settings,
    GenerationConfig,
    StageName,
    StageDefaults,
    PromptPreset,
    SchemaPreset,
    StructuredOutputSchema,
    JsonSchemaValue,
} from './types';
import { debugLog } from './debug';

// ============================================================================
// SETTINGS ACCESS
// ============================================================================

/**
 * Get current settings, initializing with defaults if needed.
 * Handles migrations from older versions.
 */
export function getSettings(): Settings {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();

    if (!extensionSettings[MODULE_NAME]) {
        debugLog('info', 'Initializing settings with defaults', null);
        extensionSettings[MODULE_NAME] = structuredClone(DEFAULT_SETTINGS);
        saveSettingsDebounced();
        return extensionSettings[MODULE_NAME] as Settings;
    }

    const settings = extensionSettings[MODULE_NAME] as Settings;
    let needsSave = false;

    // Run migrations if version is old or missing
    if (!settings.settingsVersion || settings.settingsVersion < SETTINGS_VERSION) {
        needsSave = migrateSettings(settings);
    }

    // Ensure all required fields exist (defensive)
    needsSave = ensureSettingsIntegrity(settings) || needsSave;

    if (needsSave) {
        saveSettingsDebounced();
    }

    return settings;
}

/**
 * Migrate settings from older versions
 */
function migrateSettings(settings: Settings): boolean {
    const oldVersion = settings.settingsVersion || 1;
    debugLog('info', 'Migrating settings', { from: oldVersion, to: SETTINGS_VERSION });

    let migrated = false;

    // v1 -> v2: Add preset system, stage defaults
    if (oldVersion < 2) {
        // Migrate from old flat structure to new preset-based structure

        // Handle old useRawMode -> useCurrentSettings
        if ((settings as unknown as { useRawMode?: boolean }).useRawMode !== undefined) {
            settings.useCurrentSettings = !(settings as unknown as { useRawMode?: boolean }).useRawMode;
            delete (settings as unknown as { useRawMode?: boolean }).useRawMode;
        }

        // Handle old jsonSchema -> convert to preset if custom
        const oldSchema = (settings as unknown as { jsonSchema?: unknown }).jsonSchema;
        if (oldSchema && typeof oldSchema === 'object') {
            // User had a custom schema, we'll lose it but that's okay for migration
            delete (settings as unknown as { jsonSchema?: unknown }).jsonSchema;
        }

        // Handle old useStructuredOutput
        const oldUseStructured = (settings as unknown as { useStructuredOutput?: boolean }).useStructuredOutput;
        if (oldUseStructured !== undefined) {
            // Apply to score stage default
            if (!settings.stageDefaults) {
                settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
            }
            settings.stageDefaults.score.useStructuredOutput = oldUseStructured;
            delete (settings as unknown as { useStructuredOutput?: boolean }).useStructuredOutput;
        }

        migrated = true;
    }

    // v2 -> v3: Add refinement prompt
    if (oldVersion < 3) {
        if (!settings.refinementPrompt) {
            settings.refinementPrompt = DEFAULT_REFINEMENT_PROMPT;
        }

        // Add new builtin presets for iteration
        const existingIds = new Set(settings.promptPresets.map(p => p.id));
        for (const builtin of BUILTIN_PROMPT_PRESETS) {
            if (!existingIds.has(builtin.id)) {
                settings.promptPresets.push(structuredClone(builtin));
            }
        }

        migrated = true;
    }

    settings.settingsVersion = SETTINGS_VERSION;
    return migrated;
}

/**
 * Ensure all required settings fields exist
 */
function ensureSettingsIntegrity(settings: Settings): boolean {
    let modified = false;

    // Generation config
    if (!settings.generationConfig) {
        settings.generationConfig = structuredClone(DEFAULT_GENERATION_CONFIG);
        modified = true;
    } else {
        // Ensure all generation config fields exist
        const gc = settings.generationConfig;
        if (gc.frequencyPenalty === undefined) { gc.frequencyPenalty = 0; modified = true; }
        if (gc.presencePenalty === undefined) { gc.presencePenalty = 0; modified = true; }
        if (gc.topP === undefined) { gc.topP = 1; modified = true; }
    }

    // System prompt
    if (settings.systemPrompt === undefined) {
        settings.systemPrompt = DEFAULT_SYSTEM_PROMPT;
        modified = true;
    }

    // Refinement prompt
    if (settings.refinementPrompt === undefined) {
        settings.refinementPrompt = DEFAULT_REFINEMENT_PROMPT;
        modified = true;
    }

    // Presets - ensure builtins exist
    if (!settings.promptPresets) {
        settings.promptPresets = [...BUILTIN_PROMPT_PRESETS];
        modified = true;
    } else {
        // Ensure all builtins are present (user might have old version)
        const existingIds = new Set(settings.promptPresets.map(p => p.id));
        for (const builtin of BUILTIN_PROMPT_PRESETS) {
            if (!existingIds.has(builtin.id)) {
                settings.promptPresets.push(structuredClone(builtin));
                modified = true;
            }
        }
    }

    if (!settings.schemaPresets) {
        settings.schemaPresets = [...BUILTIN_SCHEMA_PRESETS];
        modified = true;
    } else {
        const existingIds = new Set(settings.schemaPresets.map(p => p.id));
        for (const builtin of BUILTIN_SCHEMA_PRESETS) {
            if (!existingIds.has(builtin.id)) {
                settings.schemaPresets.push(structuredClone(builtin));
                modified = true;
            }
        }
    }

    // Stage defaults
    if (!settings.stageDefaults) {
        settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
        modified = true;
    } else {
        // Ensure all stages have defaults
        for (const stage of ['score', 'rewrite', 'analyze'] as const) {
            if (!settings.stageDefaults[stage]) {
                settings.stageDefaults[stage] = structuredClone(DEFAULT_STAGE_DEFAULTS[stage]);
                modified = true;
            }
        }
    }

    // Debug mode
    if (settings.debugMode === undefined) {
        settings.debugMode = false;
        modified = true;
    }

    // useCurrentSettings
    if (settings.useCurrentSettings === undefined) {
        settings.useCurrentSettings = true;
        modified = true;
    }

    return modified;
}

// ============================================================================
// SETTINGS UPDATES
// ============================================================================

/**
 * Update a single setting value
 */
export function updateSetting<K extends keyof Settings>(key: K, value: Settings[K]): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    settings[key] = value;
    saveSettingsDebounced();
    debugLog('info', 'Setting updated', { key, value: typeof value === 'object' ? '[object]' : value });
}

/**
 * Update generation config (partial update)
 */
export function updateGenerationConfig(updates: Partial<GenerationConfig>): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.generationConfig) {
        settings.generationConfig = structuredClone(DEFAULT_GENERATION_CONFIG);
    }

    settings.generationConfig = { ...settings.generationConfig, ...updates };
    saveSettingsDebounced();
    debugLog('info', 'Generation config updated', updates);
}

/**
 * Update system prompt
 */
export function updateSystemPrompt(prompt: string): void {
    updateSetting('systemPrompt', prompt);
}

/**
 * Reset system prompt to default
 */
export function resetSystemPrompt(): void {
    updateSetting('systemPrompt', DEFAULT_SYSTEM_PROMPT);
}

/**
 * Update refinement prompt
 */
export function updateRefinementPrompt(prompt: string): void {
    updateSetting('refinementPrompt', prompt);
}

/**
 * Reset refinement prompt to default
 */
export function resetRefinementPrompt(): void {
    updateSetting('refinementPrompt', DEFAULT_REFINEMENT_PROMPT);
}

/**
 * Update stage defaults
 */
export function updateStageDefaults(stage: StageName, updates: Partial<StageDefaults>): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.stageDefaults) {
        settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
    }

    if (!settings.stageDefaults[stage]) {
        settings.stageDefaults[stage] = structuredClone(DEFAULT_STAGE_DEFAULTS[stage]);
    }

    settings.stageDefaults[stage] = { ...settings.stageDefaults[stage], ...updates };
    saveSettingsDebounced();
    debugLog('info', 'Stage defaults updated', { stage, updates });
}

/**
 * Reset stage defaults to builtin values
 */
export function resetStageDefaults(stage: StageName): void {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    if (!settings.stageDefaults) {
        settings.stageDefaults = structuredClone(DEFAULT_STAGE_DEFAULTS);
    }

    settings.stageDefaults[stage] = structuredClone(DEFAULT_STAGE_DEFAULTS[stage]);
    saveSettingsDebounced();
    debugLog('info', 'Stage defaults reset', { stage });
}

/**
 * Set debug mode
 */
export function setDebugMode(enabled: boolean): void {
    updateSetting('debugMode', enabled);
}

// ============================================================================
// PRESET MANAGEMENT
// ============================================================================

/**
 * Get all prompt presets, optionally filtered by stage
 */
export function getPromptPresets(stage?: StageName): PromptPreset[] {
    const settings = getSettings();

    if (!stage) {
        return settings.promptPresets;
    }

    return settings.promptPresets.filter(p =>
        p.stages.length === 0 || p.stages.includes(stage),
    );
}

/**
 * Get a specific prompt preset by ID
 */
export function getPromptPreset(id: string): PromptPreset | null {
    const settings = getSettings();
    return settings.promptPresets.find(p => p.id === id) || null;
}

/**
 * Save a new prompt preset
 */
export function savePromptPreset(preset: Omit<PromptPreset, 'id' | 'isBuiltin' | 'createdAt' | 'updatedAt'>): PromptPreset {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    const { uuidv4 } = SillyTavern.getContext();

    const now = Date.now();
    const newPreset: PromptPreset = {
        ...preset,
        id: `custom_prompt_${uuidv4()}`,
        isBuiltin: false,
        createdAt: now,
        updatedAt: now,
    };

    settings.promptPresets.push(newPreset);
    saveSettingsDebounced();
    debugLog('info', 'Prompt preset saved', { id: newPreset.id, name: newPreset.name });

    return newPreset;
}

/**
 * Update an existing prompt preset (only custom presets)
 */
export function updatePromptPreset(id: string, updates: Partial<Omit<PromptPreset, 'id' | 'isBuiltin' | 'createdAt'>>): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.promptPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.promptPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot update builtin preset', { id });
        return false;
    }

    settings.promptPresets[index] = {
        ...preset,
        ...updates,
        updatedAt: Date.now(),
    };

    saveSettingsDebounced();
    debugLog('info', 'Prompt preset updated', { id });
    return true;
}

/**
 * Delete a prompt preset (only custom presets)
 */
export function deletePromptPreset(id: string): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.promptPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.promptPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot delete builtin preset', { id });
        return false;
    }

    settings.promptPresets.splice(index, 1);

    // Clear any stage defaults that reference this preset
    for (const stage of ['score', 'rewrite', 'analyze'] as const) {
        if (settings.stageDefaults[stage]?.promptPresetId === id) {
            settings.stageDefaults[stage].promptPresetId = null;
        }
    }

    saveSettingsDebounced();
    debugLog('info', 'Prompt preset deleted', { id });
    return true;
}

/**
 * Get all schema presets, optionally filtered by stage
 */
export function getSchemaPresets(stage?: StageName): SchemaPreset[] {
    const settings = getSettings();

    if (!stage) {
        return settings.schemaPresets;
    }

    return settings.schemaPresets.filter(p =>
        p.stages.length === 0 || p.stages.includes(stage),
    );
}

/**
 * Get a specific schema preset by ID
 */
export function getSchemaPreset(id: string): SchemaPreset | null {
    const settings = getSettings();
    return settings.schemaPresets.find(p => p.id === id) || null;
}

/**
 * Save a new schema preset
 */
export function saveSchemaPreset(preset: Omit<SchemaPreset, 'id' | 'isBuiltin' | 'createdAt' | 'updatedAt'>): SchemaPreset {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;
    const { uuidv4 } = SillyTavern.getContext();

    // Auto-fix schema before saving
    const fixedSchema = ensureSchemaHasAdditionalProperties(preset.schema);

    const now = Date.now();
    const newPreset: SchemaPreset = {
        ...preset,
        schema: fixedSchema,
        id: `custom_schema_${uuidv4()}`,
        isBuiltin: false,
        createdAt: now,
        updatedAt: now,
    };

    settings.schemaPresets.push(newPreset);
    saveSettingsDebounced();
    debugLog('info', 'Schema preset saved', { id: newPreset.id, name: newPreset.name });

    return newPreset;
}

/**
 * Update an existing schema preset (only custom presets)
 */
export function updateSchemaPreset(id: string, updates: Partial<Omit<SchemaPreset, 'id' | 'isBuiltin' | 'createdAt'>>): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.schemaPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.schemaPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot update builtin preset', { id });
        return false;
    }

    // Auto-fix schema if provided
    if (updates.schema) {
        updates.schema = ensureSchemaHasAdditionalProperties(updates.schema);
    }

    settings.schemaPresets[index] = {
        ...preset,
        ...updates,
        updatedAt: Date.now(),
    };

    saveSettingsDebounced();
    debugLog('info', 'Schema preset updated', { id });
    return true;
}

/**
 * Delete a schema preset (only custom presets)
 */
export function deleteSchemaPreset(id: string): boolean {
    const { extensionSettings, saveSettingsDebounced } = SillyTavern.getContext();
    const settings = extensionSettings[MODULE_NAME] as Settings;

    const index = settings.schemaPresets.findIndex(p => p.id === id);
    if (index === -1) return false;

    const preset = settings.schemaPresets[index];
    if (preset.isBuiltin) {
        debugLog('error', 'Cannot delete builtin preset', { id });
        return false;
    }

    settings.schemaPresets.splice(index, 1);

    // Clear any stage defaults that reference this preset
    for (const stage of ['score', 'rewrite', 'analyze'] as const) {
        if (settings.stageDefaults[stage]?.schemaPresetId === id) {
            settings.stageDefaults[stage].schemaPresetId = null;
        }
    }

    saveSettingsDebounced();
    debugLog('info', 'Schema preset deleted', { id });
    return true;
}

// ============================================================================
// SCHEMA HELPERS
// ============================================================================

/**
 * Recursively add additionalProperties: false to all object types in a schema
 */
function ensureSchemaHasAdditionalProperties(schema: StructuredOutputSchema): StructuredOutputSchema {
    const fixed = structuredClone(schema);
    addAdditionalPropertiesToNode(fixed.value);
    return fixed;
}

function addAdditionalPropertiesToNode(node: JsonSchemaValue): void {
    if (node.type === 'object') {
        node.additionalProperties = false;

        if (node.properties && typeof node.properties === 'object') {
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    addAdditionalPropertiesToNode(prop as JsonSchemaValue);
                }
            }
        }
    }

    if (node.type === 'array' && node.items && typeof node.items === 'object') {
        if (!Array.isArray(node.items)) {
            addAdditionalPropertiesToNode(node.items as JsonSchemaValue);
        } else {
            node.items.forEach(item => {
                if (item && typeof item === 'object') {
                    addAdditionalPropertiesToNode(item as JsonSchemaValue);
                }
            });
        }
    }

    if (node.anyOf && Array.isArray(node.anyOf)) {
        node.anyOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                addAdditionalPropertiesToNode(variant as JsonSchemaValue);
            }
        });
    }

    if (node.allOf && Array.isArray(node.allOf)) {
        node.allOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                addAdditionalPropertiesToNode(variant as JsonSchemaValue);
            }
        });
    }

    // Handle $defs
    if (node.$defs && typeof node.$defs === 'object') {
        for (const def of Object.values(node.$defs)) {
            if (def && typeof def === 'object') {
                addAdditionalPropertiesToNode(def);
            }
        }
    }

    if (node.definitions && typeof node.definitions === 'object') {
        for (const def of Object.values(node.definitions)) {
            if (def && typeof def === 'object') {
                addAdditionalPropertiesToNode(def as JsonSchemaValue);
            }
        }
    }
}

// ============================================================================
// EXPORT HELPERS
// ============================================================================

/**
 * Export all custom presets as JSON (for backup/sharing)
 */
export function exportCustomPresets(): string {
    const settings = getSettings();

    const customPrompts = settings.promptPresets.filter(p => !p.isBuiltin);
    const customSchemas = settings.schemaPresets.filter(p => !p.isBuiltin);

    return JSON.stringify({
        version: SETTINGS_VERSION,
        exportedAt: new Date().toISOString(),
        promptPresets: customPrompts,
        schemaPresets: customSchemas,
    }, null, 2);
}

/**
 * Import presets from JSON
 */
export function importPresets(json: string): { prompts: number; schemas: number; errors: string[] } {
    const errors: string[] = [];
    let promptsImported = 0;
    let schemasImported = 0;

    try {
        const data = JSON.parse(json);

        if (data.promptPresets && Array.isArray(data.promptPresets)) {
            for (const preset of data.promptPresets) {
                try {
                    if (preset.name && preset.prompt) {
                        savePromptPreset({
                            name: preset.name,
                            prompt: preset.prompt,
                            stages: preset.stages || [],
                        });
                        promptsImported++;
                    }
                } catch (e) {
                    errors.push(`Failed to import prompt "${preset.name}": ${e}`);
                }
            }
        }

        if (data.schemaPresets && Array.isArray(data.schemaPresets)) {
            for (const preset of data.schemaPresets) {
                try {
                    if (preset.name && preset.schema) {
                        saveSchemaPreset({
                            name: preset.name,
                            schema: preset.schema,
                            stages: preset.stages || [],
                        });
                        schemasImported++;
                    }
                } catch (e) {
                    errors.push(`Failed to import schema "${preset.name}": ${e}`);
                }
            }
        }
    } catch (e) {
        errors.push(`Failed to parse JSON: ${e}`);
    }

    debugLog('info', 'Presets imported', { promptsImported, schemasImported, errors });
    return { prompts: promptsImported, schemas: schemasImported, errors };
}
```

## FILE: src/character.ts
```ts
// src/character.ts
//
// Character utilities - field extraction, formatting, etc.

import { CHARACTER_FIELDS } from './constants';
import type { Character, PopulatedField } from './types';

// ============================================================================
// FIELD EXTRACTION
// ============================================================================

/**
 * Get all populated fields from a character
 */
export function getPopulatedFields(char: Character): PopulatedField[] {
    return CHARACTER_FIELDS
        .filter(field => {
            const val = char[field.key];
            return val && typeof val === 'string' && val.trim().length > 0;
        })
        .map(field => {
            const value = (char[field.key] as string).trim();
            return {
                key: field.key,
                label: field.label,
                value,
                charCount: value.length,
                scoreable: field.scoreable,
            };
        });
}

/**
 * Get total character count across all fields
 */
export function getTotalCharCount(char: Character): number {
    return getPopulatedFields(char).reduce((sum, f) => sum + f.charCount, 0);
}

/**
 * Get count of populated fields
 */
export function getPopulatedFieldCount(char: Character): number {
    return getPopulatedFields(char).length;
}

// ============================================================================
// FORMATTING
// ============================================================================

/**
 * Build a formatted character summary for prompts
 */
export function buildCharacterSummary(char: Character): string {
    const fields = getPopulatedFields(char);
    const sections = fields.map(f => `### ${f.label}\n${f.value}`);
    return `# CHARACTER: ${char.name}\n\n${sections.join('\n\n')}`;
}

/**
 * Build a compact character summary (for display)
 */
export function buildCompactSummary(char: Character): string {
    const fields = getPopulatedFields(char);
    return `${char.name} - ${fields.length} fields, ${getTotalCharCount(char).toLocaleString()} chars`;
}

/**
 * Get a preview of a field value (truncated)
 */
export function getFieldPreview(value: string, maxLength: number = 100): string {
    if (value.length <= maxLength) {
        return value;
    }
    return value.substring(0, maxLength - 3) + '...';
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Check if a character has enough content to analyze
 */
export function hasAnalyzableContent(char: Character): boolean {
    const fields = getPopulatedFields(char);
    return fields.length > 0;
}

/**
 * Get validation issues with a character
 */
export function validateCharacter(char: Character): string[] {
    const issues: string[] = [];

    if (!char.name?.trim()) {
        issues.push('Character has no name');
    }

    const fields = getPopulatedFields(char);
    if (fields.length === 0) {
        issues.push('Character has no populated fields');
    }

    // Check for very short fields
    for (const field of fields) {
        if (field.charCount < 20 && field.scoreable) {
            issues.push(`${field.label} is very short (${field.charCount} chars)`);
        }
    }

    return issues;
}

// ============================================================================
// SEARCH
// ============================================================================

/**
 * Prepare character data for fuzzy search
 */
export function prepareForSearch(chars: Character[]): Array<{ char: Character; index: number; searchText: string }> {
    return chars
        .map((char, index) => ({
            char,
            index,
            searchText: [
                char.name,
                char.description?.substring(0, 200),
                char.personality?.substring(0, 100),
            ].filter(Boolean).join(' ').toLowerCase(),
        }))
        .filter(item => item.char?.name);
}
```

## FILE: src/generator.ts
```ts
// src/generator.ts
//
// Handles LLM generation for pipeline stages and refinement.
// Supports both ST's current settings and custom API configuration.

import { getSettings } from './settings';
import { debugLog } from './debug';
import type {
    StructuredOutputSchema,
    GenerationResult,
    PipelineState,
    StageName,
} from './types';
import { buildStagePrompt, buildRefinementPrompt, getStageSchema } from './pipeline';

// ============================================================================
// API STATUS
// ============================================================================

/**
 * Check if the API is ready for generation
 */
export function isApiReady(): boolean {
    const { onlineStatus } = SillyTavern.getContext();
    return onlineStatus === 'Valid' || onlineStatus === 'Connected';
}

/**
 * Get current API info for display
 */
export function getApiInfo(): { source: string; model: string; isReady: boolean } {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    if (settings.useCurrentSettings) {
        return {
            source: context.chatCompletionSettings?.chat_completion_source || context.mainApi || 'unknown',
            model: context.chatCompletionSettings?.openrouter_model ||
             context.chatCompletionSettings?.model_openai_select ||
             'unknown',
            isReady: isApiReady(),
        };
    }

    return {
        source: settings.generationConfig.source,
        model: settings.generationConfig.model,
        isReady: isApiReady(),
    };
}

// ============================================================================
// MAIN GENERATION FUNCTION
// ============================================================================

/**
 * Run generation for a pipeline stage
 */
export async function runStageGeneration(
    state: PipelineState,
    stage: StageName,
    signal?: AbortSignal,
): Promise<GenerationResult> {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    // Pre-flight checks
    if (signal?.aborted) {
        return { success: false, error: 'Generation cancelled' };
    }

    if (!state.character) {
        return { success: false, error: 'No character selected' };
    }

    if (!isApiReady()) {
        debugLog('error', 'API not ready', { onlineStatus: context.onlineStatus });
        return { success: false, error: 'API is not connected. Check your connection settings.' };
    }

    // Build prompt
    const userPrompt = buildStagePrompt(state, stage);
    if (!userPrompt) {
        return { success: false, error: 'No prompt configured for this stage' };
    }

    // Get schema if structured output is enabled
    const config = state.configs[stage];
    const jsonSchema = config.useStructuredOutput ? getStageSchema(state, stage) : null;

    // Substitute character placeholders in the prompt
    const processedPrompt = substituteCharacterPlaceholders(
        userPrompt,
        state.character.name,
        context.name1 || 'User',
    );

    debugLog('info', 'Starting stage generation', {
        stage,
        character: state.character.name,
        useCurrentSettings: settings.useCurrentSettings,
        useStructured: !!jsonSchema,
        schemaName: jsonSchema?.name,
        promptLength: processedPrompt.length,
    });

    return await executeGeneration(
        settings.systemPrompt,
        processedPrompt,
        jsonSchema,
        signal,
        settings.useCurrentSettings,
    );
}

/**
 * Run refinement generation
 */
export async function runRefinementGeneration(
    state: PipelineState,
    signal?: AbortSignal,
): Promise<GenerationResult> {
    const context = SillyTavern.getContext();
    const settings = getSettings();

    // Pre-flight checks
    if (signal?.aborted) {
        return { success: false, error: 'Generation cancelled' };
    }

    if (!state.character) {
        return { success: false, error: 'No character selected' };
    }

    if (!state.results.rewrite || !state.results.analyze) {
        return { success: false, error: 'Refinement requires both rewrite and analyze results' };
    }

    if (!isApiReady()) {
        debugLog('error', 'API not ready', { onlineStatus: context.onlineStatus });
        return { success: false, error: 'API is not connected. Check your connection settings.' };
    }

    // Build refinement prompt
    const userPrompt = buildRefinementPrompt(state);
    if (!userPrompt) {
        return { success: false, error: 'Failed to build refinement prompt' };
    }

    // Substitute character placeholders
    const processedPrompt = substituteCharacterPlaceholders(
        userPrompt,
        state.character.name,
        context.name1 || 'User',
    );

    debugLog('info', 'Starting refinement generation', {
        iteration: state.iterationCount + 1,
        character: state.character.name,
        promptLength: processedPrompt.length,
    });

    // Refinement doesn't use structured output - we want free-form character card
    return await executeGeneration(
        settings.systemPrompt,
        processedPrompt,
        null,
        signal,
        settings.useCurrentSettings,
    );
}

/**
 * Core generation execution
 */
async function executeGeneration(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal: AbortSignal | undefined,
    useCurrentSettings: boolean,
): Promise<GenerationResult> {
    try {
        let response: string;

        if (useCurrentSettings) {
            response = await generateWithCurrentSettings(
                systemPrompt,
                userPrompt,
                jsonSchema,
                signal,
            );
        } else {
            response = await generateWithCustomSettings(
                systemPrompt,
                userPrompt,
                jsonSchema,
                signal,
            );
        }

        // Check abort after generation
        if (signal?.aborted) {
            return { success: false, error: 'Generation cancelled' };
        }

        if (!response || response.trim() === '') {
            debugLog('error', 'Empty response', null);
            return { success: false, error: 'Empty response from API' };
        }

        debugLog('info', 'Generation complete', {
            responseLength: response.length,
            isStructured: !!jsonSchema,
        });

        return {
            success: true,
            response,
            isStructured: !!jsonSchema,
        };
    } catch (err) {
        // Handle abort errors gracefully
        if ((err as Error).name === 'AbortError' || signal?.aborted) {
            debugLog('info', 'Generation aborted', null);
            return { success: false, error: 'Generation cancelled' };
        }

        debugLog('error', 'Generation exception', {
            message: err instanceof Error ? err.message : String(err),
        });

        const errorMessage = err instanceof Error ? err.message : String(err);
        return { success: false, error: errorMessage };
    }
}

// ============================================================================
// GENERATION METHODS
// ============================================================================

/**
 * Generate using ST's current API settings
 */
async function generateWithCurrentSettings(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal?: AbortSignal,
): Promise<string> {
    const { generateRaw, substituteParams } = SillyTavern.getContext();

    // Run ST's macro substitution on system prompt
    const processedSystemPrompt = substituteParams(systemPrompt);

    debugLog('request', 'generateRaw request', {
        hasSchema: !!jsonSchema,
        schemaName: jsonSchema?.name,
        systemPromptLength: processedSystemPrompt.length,
        userPromptLength: userPrompt.length,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const rawResponse = await generateRaw({
        prompt: [
            { role: 'system', content: processedSystemPrompt },
            { role: 'user', content: userPrompt },
        ],
        jsonSchema: jsonSchema as StructuredOutputSchema | null,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const response = ensureString(rawResponse);

    debugLog('response', 'generateRaw response', {
        type: typeof rawResponse,
        length: response.length,
        preview: response.substring(0, 200),
    });

    return response;
}

/**
 * Generate using custom API settings
 */
async function generateWithCustomSettings(
    systemPrompt: string,
    userPrompt: string,
    jsonSchema: StructuredOutputSchema | null,
    signal?: AbortSignal,
): Promise<string> {
    const { ChatCompletionService, substituteParams } = SillyTavern.getContext();
    const settings = getSettings();
    const config = settings.generationConfig;

    // Run ST's macro substitution on system prompt
    const processedSystemPrompt = substituteParams(systemPrompt);

    const requestOptions: Record<string, unknown> = {
        stream: true,
        messages: [
            { role: 'system', content: processedSystemPrompt },
            { role: 'user', content: userPrompt },
        ],
        chat_completion_source: config.source,
        model: config.model,
        temperature: config.temperature,
        max_tokens: config.maxTokens,
        frequency_penalty: config.frequencyPenalty,
        presence_penalty: config.presencePenalty,
        top_p: config.topP,
    };

    if (jsonSchema) {
        requestOptions.json_schema = jsonSchema;
    }

    debugLog('request', 'ChatCompletionService request', {
        source: config.source,
        model: config.model,
        stream: true,
        hasSchema: !!jsonSchema,
    });

    if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }

    const result = await ChatCompletionService.sendRequest(requestOptions);

    debugLog('response', 'ChatCompletionService result type', {
        type: typeof result,
        isFunction: typeof result === 'function',
        isGenerator: result && typeof result === 'object' && Symbol.asyncIterator in result,
    });

    let response: string;

    // When stream: true, result is a generator function - consume it
    if (typeof result === 'function') {
        response = await consumeStreamGenerator(result, signal);
    } else if (result && typeof result === 'object') {
        const resultObj = result as Record<string, unknown>;

        if (resultObj.error) {
            debugLog('error', 'API returned error', result);
            throw new Error(`API error: ${JSON.stringify(result)}`);
        }

        response = ensureString(resultObj.content || result);
    } else {
        response = ensureString(result);
    }

    debugLog('response', 'Final response', {
        length: response.length,
        preview: response.substring(0, 200),
    });

    return response;
}

/**
 * Consume a streaming generator and return the final accumulated text
 */
async function consumeStreamGenerator(
    generatorFn: () => AsyncGenerator<unknown>,
    signal?: AbortSignal,
): Promise<string> {
    let finalText = '';

    try {
        const generator = generatorFn();

        for await (const chunk of generator) {
            // Check abort during streaming
            if (signal?.aborted) {
                debugLog('info', 'Stream aborted', { textSoFar: finalText.length });
                throw new DOMException('Aborted', 'AbortError');
            }

            const chunkObj = chunk as Record<string, unknown>;

            if (typeof chunkObj.text === 'string') {
                finalText = chunkObj.text;
            }

            if (chunkObj.error) {
                throw new Error(ensureString(chunkObj.error));
            }
        }
    } catch (err) {
        if ((err as Error).name === 'AbortError') {
            throw err;
        }

        debugLog('error', 'Stream consumption error', {
            error: err,
            textSoFar: finalText.length,
        });

        // Return partial response if we have one
        if (finalText) {
            debugLog('info', 'Returning partial response after stream error', {
                length: finalText.length,
            });
            return finalText;
        }

        throw err;
    }

    debugLog('info', 'Stream consumed', { finalLength: finalText.length });
    return finalText;
}

// ============================================================================
// TOKEN ESTIMATION
// ============================================================================

/**
 * Get accurate token count for a stage
 */
export async function getStageTokenCount(
    state: PipelineState,
    stage: StageName,
): Promise<{ promptTokens: number; contextSize: number; percentage: number } | null> {
    const { getTokenCountAsync, maxContext } = SillyTavern.getContext();
    const settings = getSettings();

    if (!state.character) return null;

    try {
        const prompt = buildStagePrompt(state, stage);
        if (!prompt) return null;

        const fullPrompt = settings.systemPrompt + '\n\n' + prompt;
        const promptTokens = await getTokenCountAsync(fullPrompt);
        const percentage = Math.round((promptTokens / maxContext) * 100);

        return {
            promptTokens,
            contextSize: maxContext,
            percentage,
        };
    } catch (e) {
        debugLog('error', 'Token count failed', e);
        return null;
    }
}

/**
 * Get token count for refinement prompt
 */
export async function getRefinementTokenCount(
    state: PipelineState,
): Promise<{ promptTokens: number; contextSize: number; percentage: number } | null> {
    const { getTokenCountAsync, maxContext } = SillyTavern.getContext();
    const settings = getSettings();

    if (!state.character || !state.results.rewrite || !state.results.analyze) return null;

    try {
        const prompt = buildRefinementPrompt(state);
        if (!prompt) return null;

        const fullPrompt = settings.systemPrompt + '\n\n' + prompt;
        const promptTokens = await getTokenCountAsync(fullPrompt);
        const percentage = Math.round((promptTokens / maxContext) * 100);

        return {
            promptTokens,
            contextSize: maxContext,
            percentage,
        };
    } catch (e) {
        debugLog('error', 'Refinement token count failed', e);
        return null;
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Safely convert response to string
 */
function ensureString(value: unknown): string {
    if (typeof value === 'string') return value;
    if (value === null || value === undefined) return '';
    if (typeof value === 'object') {
        try {
            return JSON.stringify(value);
        } catch {
            return String(value);
        }
    }
    return String(value);
}

/**
 * Replace {{char}} and {{user}} placeholders with actual names
 * This is needed because we're not in a chat context where ST auto-substitutes
 */
function substituteCharacterPlaceholders(
    text: string,
    charName: string,
    userName: string,
): string {
    return text
        .replace(/\{\{char\}\}/gi, charName)
        .replace(/\{\{user\}\}/gi, userName);
}
```

## FILE: src/schema.ts
```ts
// src/schema.ts
import type { StructuredOutputSchema, SchemaValidationResult, JsonSchemaValue } from './types';

// ============================================================================
// PROVIDER LIMITS
// ============================================================================

// Anthropic limits (strictest - design for these)
const ANTHROPIC_LIMITS = {
    MAX_ANYOF_VARIANTS: 8,
    MAX_DEFS: 100,
    MAX_NESTING_DEPTH: 10,
    MAX_PROPERTIES_PER_OBJECT: 100,
    MAX_ENUM_VALUES: 500,
    SUPPORTED_STRING_FORMATS: [
        'date-time', 'time', 'date', 'duration',
        'email', 'hostname', 'uri', 'ipv4', 'ipv6', 'uuid',
    ] as const,
    SUPPORTED_MINMAX_ITEMS: [0, 1] as const,
} as const;

// Features that will be silently ignored (not errors, but won't work)
const IGNORED_CONSTRAINTS = {
    numeric: ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum', 'multipleOf'],
    string: ['minLength', 'maxLength'],
    array: ['maxItems', 'uniqueItems', 'contains', 'minContains', 'maxContains'],
    object: ['minProperties', 'maxProperties', 'propertyNames', 'patternProperties'],
} as const;

// Completely unsupported features (will cause errors)
const UNSUPPORTED_FEATURES = [
    'if', 'then', 'else',           // Conditional schemas
    'not',                           // Negation
    'oneOf',                         // Use anyOf instead
    'dependentRequired',             // Dependent requirements
    'dependentSchemas',              // Dependent schemas
    'unevaluatedProperties',         // OpenAPI 3.1 feature
    'unevaluatedItems',              // OpenAPI 3.1 feature
    '$dynamicRef',                   // Dynamic references
    '$dynamicAnchor',                // Dynamic anchors
] as const;

// Regex features NOT supported
const UNSUPPORTED_REGEX_FEATURES = [
    { pattern: /\(\?[=!<]/, name: 'lookahead/lookbehind assertions' },
    { pattern: /\\[1-9]/, name: 'backreferences' },
    { pattern: /\\[bB]/, name: 'word boundaries' },
] as const;

// ============================================================================
// VALIDATION TYPES
// ============================================================================

interface ValidationContext {
  errors: string[];
  warnings: string[];
  info: string[];
  stats: {
    defCount: number;
    anyOfCount: number;
    totalAnyOfVariants: number;
    maxDepth: number;
    propertyCount: number;
    optionalFieldCount: number;
    enumCount: number;
  };
  currentDepth: number;
  seenRefs: Set<string>;
  defs: Record<string, JsonSchemaValue>;
}

const SCHEMA_GENERATION_PROMPT = `Generate a JSON Schema for structured LLM output based on the user's description.

Requirements:
- Output ONLY valid JSON, no markdown, no explanation
- Use this exact wrapper format: {"name": "SchemaName", "strict": true, "value": {...}}
- The "value" must be a valid JSON Schema with "type": "object"
- Add "additionalProperties": false to ALL object types (required for Anthropic)
- All object properties should be in a "required" array unless explicitly optional
- Use simple types: string, number, integer, boolean, array, object
- For arrays, always specify "items" with a schema
- Keep it minimal - only what the user asked for

User's description:`;

export async function generateSchemaFromDescription(description: string): Promise<{
  success: boolean;
  schema?: string;
  error?: string;
}> {
    const { generateRaw } = SillyTavern.getContext();

    if (!description.trim()) {
        return { success: false, error: 'Please describe what you want in the schema' };
    }

    try {
        const response = await generateRaw({
            prompt: `${SCHEMA_GENERATION_PROMPT}\n\n${description}`,
            systemPrompt: 'You are a JSON Schema expert. Output only valid JSON, nothing else.',
        });

        // Clean up response - strip markdown code blocks if present
        let cleaned = response.trim();
        if (cleaned.startsWith('```')) {
            cleaned = cleaned.replace(/^```(?:json)?\s*/, '').replace(/\s*```$/, '');
        }

        // Validate what we got
        const validation = validateSchema(cleaned);

        if (!validation.valid) {
            return {
                success: false,
                error: `Generated schema is invalid: ${validation.error}`,
                schema: cleaned, // Return it anyway so user can fix
            };
        }

        // Auto-fix if needed
        if (validation.warnings?.length) {
            const fixed = autoFixSchema(validation.schema!);
            return {
                success: true,
                schema: JSON.stringify(fixed, null, 2),
            };
        }

        return {
            success: true,
            schema: JSON.stringify(validation.schema, null, 2),
        };
    } catch (e) {
        return {
            success: false,
            error: `Generation failed: ${(e as Error).message}`,
        };
    }
}

// ============================================================================
// MAIN VALIDATION FUNCTION
// ============================================================================

/**
 * Validates a JSON schema for Anthropic/OpenRouter structured output compatibility.
 *
 * Checks:
 * - JSON syntax validity
 * - Required ST wrapper structure (name, value)
 * - Anthropic-specific limits (anyOf variants, nesting depth, etc.)
 * - Required additionalProperties: false on all objects
 * - Unsupported JSON Schema features
 * - Regex pattern compatibility
 * - Optional field count (spawns anyOf with null)
 */
export function validateSchema(input: string): SchemaValidationResult {
    // Empty input = disable structured output
    if (!input.trim()) {
        return { valid: true, schema: undefined };
    }

    // Parse JSON
    let parsed: unknown;
    try {
        parsed = JSON.parse(input);
    } catch (e) {
        const error = e instanceof Error ? e.message : 'Invalid JSON';
        // Try to give helpful position info
        const match = error.match(/position (\d+)/);
        const position = match ? ` (character ${match[1]})` : '';
        return { valid: false, error: `JSON syntax error${position}: ${error}` };
    }

    // Must be an object
    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
        return { valid: false, error: 'Schema must be a JSON object, not ' + (Array.isArray(parsed) ? 'array' : typeof parsed) };
    }

    const obj = parsed as Record<string, unknown>;

    // ========== ST WRAPPER VALIDATION ==========

    // Required: name (string, non-empty, valid identifier)
    if (typeof obj.name !== 'string') {
        return { valid: false, error: 'Missing required \'name\' property (string)' };
    }
    if (!obj.name.trim()) {
        return { valid: false, error: '\'name\' cannot be empty' };
    }
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(obj.name)) {
        return { valid: false, error: `'name' must be a valid identifier (got '${obj.name}'). Use letters, numbers, underscores; start with letter or underscore.` };
    }

    // Required: value (object with type)
    if (typeof obj.value !== 'object' || obj.value === null || Array.isArray(obj.value)) {
        return { valid: false, error: 'Missing or invalid \'value\' property (must be object)' };
    }

    const value = obj.value as JsonSchemaValue;

    if (typeof value.type !== 'string' && !value.anyOf && !value.allOf && !value.$ref) {
        return { valid: false, error: '\'value\' must have a \'type\', \'anyOf\', \'allOf\', or \'$ref\'' };
    }

    // Optional: strict (boolean)
    if (obj.strict !== undefined && typeof obj.strict !== 'boolean') {
        return { valid: false, error: '\'strict\' must be a boolean if provided' };
    }

    // ========== DEEP SCHEMA VALIDATION ==========

    const ctx: ValidationContext = {
        errors: [],
        warnings: [],
        info: [],
        stats: {
            defCount: 0,
            anyOfCount: 0,
            totalAnyOfVariants: 0,
            maxDepth: 0,
            propertyCount: 0,
            optionalFieldCount: 0,
            enumCount: 0,
        },
        currentDepth: 0,
        seenRefs: new Set(),
        defs: {},
    };

    // Extract $defs/definitions first
    if (value.$defs && typeof value.$defs === 'object') {
        ctx.defs = value.$defs as Record<string, JsonSchemaValue>;
        ctx.stats.defCount = Object.keys(ctx.defs).length;
    } else if (value.definitions && typeof value.definitions === 'object') {
        ctx.defs = value.definitions as Record<string, JsonSchemaValue>;
        ctx.stats.defCount = Object.keys(ctx.defs).length;
    }

    if (ctx.stats.defCount > ANTHROPIC_LIMITS.MAX_DEFS) {
        ctx.errors.push(`Too many definitions: ${ctx.stats.defCount} (limit: ${ANTHROPIC_LIMITS.MAX_DEFS})`);
    }

    // Validate the schema tree
    validateSchemaNode(value, 'value', ctx);

    // Check optional field explosion
    if (ctx.stats.optionalFieldCount > 0) {
        const implicitAnyOfs = ctx.stats.optionalFieldCount;
        const totalAnyOfs = ctx.stats.totalAnyOfVariants + implicitAnyOfs * 2; // Each optional spawns anyOf[type, null]

        if (implicitAnyOfs > 10) {
            ctx.warnings.push(
                `${implicitAnyOfs} optional fields detected. Each spawns an implicit anyOf with null. ` +
        'Consider making fields required or reducing optionals.',
            );
        }

        if (totalAnyOfs > 50) {
            ctx.warnings.push(
                `High anyOf count (~${totalAnyOfs} including implicit nullables). ` +
        'May cause slow schema compilation or errors.',
            );
        }
    }

    // ========== BUILD RESULT ==========

    if (ctx.errors.length > 0) {
        return {
            valid: false,
            error: ctx.errors.join('\n'),
            warnings: ctx.warnings.length > 0 ? ctx.warnings : undefined,
        };
    }

    const schema: StructuredOutputSchema = {
        name: obj.name,
        strict: obj.strict as boolean | undefined ?? true, // Default to strict
        value: value,
    };

    // Add stats as info
    ctx.info.push(
        `Schema stats: ${ctx.stats.propertyCount} properties, ` +
    `${ctx.stats.defCount} definitions, ` +
    `${ctx.stats.anyOfCount} anyOf blocks, ` +
    `${ctx.stats.optionalFieldCount} optional fields, ` +
    `max depth ${ctx.stats.maxDepth}`,
    );

    return {
        valid: true,
        schema,
        warnings: ctx.warnings.length > 0 ? ctx.warnings : undefined,
        info: ctx.info.length > 0 ? ctx.info : undefined,
    };
}

// ============================================================================
// RECURSIVE NODE VALIDATION
// ============================================================================

function validateSchemaNode(
    node: JsonSchemaValue,
    path: string,
    ctx: ValidationContext,
): void {
    ctx.currentDepth++;
    ctx.stats.maxDepth = Math.max(ctx.stats.maxDepth, ctx.currentDepth);

    // Check nesting depth
    if (ctx.currentDepth > ANTHROPIC_LIMITS.MAX_NESTING_DEPTH) {
        ctx.errors.push(`${path}: Exceeds maximum nesting depth of ${ANTHROPIC_LIMITS.MAX_NESTING_DEPTH}`);
        ctx.currentDepth--;
        return;
    }

    // Check for completely unsupported features
    for (const feature of UNSUPPORTED_FEATURES) {
        if (node[feature] !== undefined) {
            ctx.errors.push(`${path}: '${feature}' is not supported`);
        }
    }

    // Check for ignored constraints (warn, don't error)
    for (const key of IGNORED_CONSTRAINTS.numeric) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.string) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.array) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }
    for (const key of IGNORED_CONSTRAINTS.object) {
        if (node[key] !== undefined) {
            ctx.warnings.push(`${path}: '${key}' will be ignored (not supported)`);
        }
    }

    // Handle $ref
    if (node.$ref && typeof node.$ref === 'string') {
        validateRef(node.$ref, path, ctx);
        ctx.currentDepth--;
        return; // $ref replaces the node
    }

    // Handle type-specific validation
    const types = Array.isArray(node.type) ? node.type : [node.type];

    for (const type of types) {
        switch (type) {
            case 'object':
                validateObjectNode(node, path, ctx);
                break;
            case 'array':
                validateArrayNode(node, path, ctx);
                break;
            case 'string':
                validateStringNode(node, path, ctx);
                break;
            case 'number':
            case 'integer':
                validateNumericNode(node, path, ctx);
                break;
            case 'boolean':
            case 'null':
                // No special validation needed
                break;
            default:
                if (type && !node.anyOf && !node.allOf) {
                    ctx.warnings.push(`${path}: Unknown type '${type}'`);
                }
        }
    }

    // Handle anyOf
    if (node.anyOf && Array.isArray(node.anyOf)) {
        validateAnyOf(node.anyOf, path, ctx);
    }

    // Handle allOf
    if (node.allOf && Array.isArray(node.allOf)) {
        validateAllOf(node.allOf, path, ctx);
    }

    // Handle enum
    if (node.enum && Array.isArray(node.enum)) {
        validateEnum(node.enum, path, ctx);
    }

    // Handle const
    if (node.const !== undefined) {
        validateConst(node.const, path, ctx);
    }

    ctx.currentDepth--;
}

// ============================================================================
// TYPE-SPECIFIC VALIDATORS
// ============================================================================

function validateObjectNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // CRITICAL: additionalProperties must be false
    if (node.additionalProperties !== false) {
        ctx.warnings.push(`${path}: Missing 'additionalProperties: false' (REQUIRED for Anthropic)`);
    }

    // Validate properties
    if (node.properties && typeof node.properties === 'object') {
        const props = node.properties as Record<string, JsonSchemaValue>;
        const propCount = Object.keys(props).length;
        ctx.stats.propertyCount += propCount;

        if (propCount > ANTHROPIC_LIMITS.MAX_PROPERTIES_PER_OBJECT) {
            ctx.warnings.push(
                `${path}: ${propCount} properties (may be slow, consider splitting)`,
            );
        }

        // Track optional fields
        const required = (node.required as string[]) || [];
        for (const [key, prop] of Object.entries(props)) {
            if (!required.includes(key)) {
                ctx.stats.optionalFieldCount++;
            }

            if (prop && typeof prop === 'object') {
                validateSchemaNode(prop, `${path}.${key}`, ctx);
            }
        }
    }
}

function validateArrayNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // minItems only supports 0 or 1
    if (node.minItems !== undefined) {
        const allowed = ANTHROPIC_LIMITS.SUPPORTED_MINMAX_ITEMS as readonly number[];
        if (!allowed.includes(node.minItems as number)) {
            ctx.warnings.push(
                `${path}: 'minItems: ${node.minItems}' not supported (only 0 or 1 allowed)`,
            );
        }
    }

    // Validate items schema
    if (node.items) {
        if (typeof node.items === 'object' && !Array.isArray(node.items)) {
            validateSchemaNode(node.items as JsonSchemaValue, `${path}.items`, ctx);
        } else if (Array.isArray(node.items)) {
            // Tuple validation (array of schemas)
            node.items.forEach((item, i) => {
                if (item && typeof item === 'object') {
                    validateSchemaNode(item as JsonSchemaValue, `${path}.items[${i}]`, ctx);
                }
            });
        }
    }

    // prefixItems (JSON Schema draft 2020-12)
    if (node.prefixItems && Array.isArray(node.prefixItems)) {
        node.prefixItems.forEach((item, i) => {
            if (item && typeof item === 'object') {
                validateSchemaNode(item as JsonSchemaValue, `${path}.prefixItems[${i}]`, ctx);
            }
        });
    }
}

function validateStringNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // Check format
    if (node.format && typeof node.format === 'string') {
        const supported = ANTHROPIC_LIMITS.SUPPORTED_STRING_FORMATS as readonly string[];
        if (!supported.includes(node.format)) {
            ctx.warnings.push(
                `${path}: format '${node.format}' may not be supported. ` +
        `Supported: ${supported.join(', ')}`,
            );
        }
    }

    // Check pattern (regex)
    if (node.pattern && typeof node.pattern === 'string') {
        validateRegexPattern(node.pattern, path, ctx);
    }
}

function validateNumericNode(node: JsonSchemaValue, path: string, ctx: ValidationContext): void {
    // All numeric constraints are ignored, already warned above
    // Nothing additional to check
}

function validateRef(ref: string, path: string, ctx: ValidationContext): void {
    // External refs not supported
    if (ref.startsWith('http://') || ref.startsWith('https://')) {
        ctx.errors.push(`${path}: External $ref not supported ('${ref}')`);
        return;
    }

    // Check for circular refs
    if (ctx.seenRefs.has(ref)) {
    // Not necessarily an error, but worth noting
        ctx.info.push(`${path}: Circular reference to '${ref}'`);
        return;
    }

    ctx.seenRefs.add(ref);

    // Validate the referenced definition exists
    const refPath = ref.replace(/^#\/(\$defs|definitions)\//, '');
    if (!ctx.defs[refPath]) {
        ctx.errors.push(`${path}: Reference '${ref}' not found in definitions`);
    }
}

function validateAnyOf(variants: unknown[], path: string, ctx: ValidationContext): void {
    ctx.stats.anyOfCount++;
    ctx.stats.totalAnyOfVariants += variants.length;

    if (variants.length > ANTHROPIC_LIMITS.MAX_ANYOF_VARIANTS) {
        ctx.errors.push(
            `${path}: anyOf has ${variants.length} variants (max: ${ANTHROPIC_LIMITS.MAX_ANYOF_VARIANTS})`,
        );
    }

    if (variants.length === 0) {
        ctx.errors.push(`${path}: anyOf cannot be empty`);
        return;
    }

    variants.forEach((variant, i) => {
        if (variant && typeof variant === 'object') {
            validateSchemaNode(variant as JsonSchemaValue, `${path}.anyOf[${i}]`, ctx);
        }
    });
}

function validateAllOf(variants: unknown[], path: string, ctx: ValidationContext): void {
    if (variants.length === 0) {
        ctx.errors.push(`${path}: allOf cannot be empty`);
        return;
    }

    variants.forEach((variant, i) => {
        if (variant && typeof variant === 'object') {
            const v = variant as Record<string, unknown>;

            // allOf with $ref not supported
            if (v.$ref) {
                ctx.errors.push(`${path}.allOf[${i}]: allOf with $ref not supported`);
            }

            validateSchemaNode(v as JsonSchemaValue, `${path}.allOf[${i}]`, ctx);
        }
    });
}

function validateEnum(values: unknown[], path: string, ctx: ValidationContext): void {
    ctx.stats.enumCount++;

    if (values.length === 0) {
        ctx.errors.push(`${path}: enum cannot be empty`);
        return;
    }

    if (values.length > ANTHROPIC_LIMITS.MAX_ENUM_VALUES) {
        ctx.warnings.push(
            `${path}: enum has ${values.length} values (may be slow)`,
        );
    }

    // Check for complex types (not allowed)
    for (let i = 0; i < values.length; i++) {
        const val = values[i];
        const t = typeof val;

        if (t !== 'string' && t !== 'number' && t !== 'boolean' && val !== null) {
            ctx.errors.push(
                `${path}.enum[${i}]: Complex type not allowed in enum (got ${t}). ` +
        'Only string, number, boolean, null permitted.',
            );
            break; // One error is enough
        }
    }

    // Check for duplicates
    const seen = new Set();
    for (const val of values) {
        const key = JSON.stringify(val);
        if (seen.has(key)) {
            ctx.warnings.push(`${path}: Duplicate value in enum: ${key}`);
            break;
        }
        seen.add(key);
    }
}

function validateConst(value: unknown, path: string, ctx: ValidationContext): void {
    const t = typeof value;
    if (t !== 'string' && t !== 'number' && t !== 'boolean' && value !== null) {
        ctx.errors.push(
            `${path}: const must be string, number, boolean, or null (got ${t})`,
        );
    }
}

function validateRegexPattern(pattern: string, path: string, ctx: ValidationContext): void {
    // Check for unsupported regex features
    for (const { pattern: check, name } of UNSUPPORTED_REGEX_FEATURES) {
        if (check.test(pattern)) {
            ctx.errors.push(`${path}: Regex pattern uses unsupported feature: ${name}`);
        }
    }

    // Try to compile the regex to catch syntax errors
    try {
        new RegExp(pattern);
    } catch (e) {
        const msg = e instanceof Error ? e.message : 'Invalid regex';
        ctx.errors.push(`${path}: Invalid regex pattern: ${msg}`);
    }

    // Warn about complex quantifiers
    const complexQuantifier = /\{(\d+),(\d+)\}/g;
    let match;
    while ((match = complexQuantifier.exec(pattern)) !== null) {
        const min = parseInt(match[1], 10);
        const max = parseInt(match[2], 10);
        if (max - min > 100) {
            ctx.warnings.push(
                `${path}: Large quantifier range {${min},${max}} may cause issues`,
            );
        }
    }
}

// ============================================================================
// AUTO-FIX FUNCTIONS
// ============================================================================

/**
 * Auto-fixes a schema by:
 * 1. Adding additionalProperties: false to all objects
 * 2. Removing unsupported constraints (with description updates)
 * 3. Setting strict: true if not set
 */
export function autoFixSchema(schema: StructuredOutputSchema): StructuredOutputSchema {
    const fixed = structuredClone(schema);

    // Ensure strict mode
    if (fixed.strict === undefined) {
        fixed.strict = true;
    }

    // Fix the value recursively
    fixSchemaNode(fixed.value);

    return fixed;
}

function fixSchemaNode(node: JsonSchemaValue): void {
    // Fix objects
    if (node.type === 'object') {
        node.additionalProperties = false;

        if (node.properties && typeof node.properties === 'object') {
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    fixSchemaNode(prop as JsonSchemaValue);
                }
            }
        }
    }

    // Fix arrays
    if (node.type === 'array' && node.items && typeof node.items === 'object') {
        if (!Array.isArray(node.items)) {
            fixSchemaNode(node.items as JsonSchemaValue);
        } else {
            node.items.forEach(item => {
                if (item && typeof item === 'object') {
                    fixSchemaNode(item as JsonSchemaValue);
                }
            });
        }
    }

    // Fix anyOf
    if (node.anyOf && Array.isArray(node.anyOf)) {
        node.anyOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                fixSchemaNode(variant as JsonSchemaValue);
            }
        });
    }

    // Fix allOf
    if (node.allOf && Array.isArray(node.allOf)) {
        node.allOf.forEach(variant => {
            if (variant && typeof variant === 'object') {
                fixSchemaNode(variant as JsonSchemaValue);
            }
        });
    }

    // Move unsupported constraints to description
    const constraints: string[] = [];

    for (const key of IGNORED_CONSTRAINTS.numeric) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    for (const key of IGNORED_CONSTRAINTS.string) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    for (const key of IGNORED_CONSTRAINTS.array) {
        if (node[key] !== undefined) {
            constraints.push(`${key}: ${node[key]}`);
            delete node[key];
        }
    }

    // Fix minItems if invalid
    if (node.minItems !== undefined && node.minItems !== null) {
        const minItems = node.minItems as number;
        if (minItems !== 0 && minItems !== 1) {
            constraints.push(`minItems: ${minItems}`);
            node.minItems = minItems > 0 ? 1 : 0;
        }
    }

    // Append constraints to description
    if (constraints.length > 0) {
        const constraintNote = `[Constraints: ${constraints.join(', ')}]`;
        if (node.description) {
            node.description = `${node.description} ${constraintNote}`;
        } else {
            node.description = constraintNote;
        }
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Formats a schema object as a pretty-printed JSON string.
 */
export function formatSchema(schema: StructuredOutputSchema | null): string {
    if (!schema) return '';
    return JSON.stringify(schema, null, 2);
}

/**
 * Attempts to parse a structured output response.
 * Returns the parsed object or null if parsing fails.
 */
export function parseStructuredResponse(response: string): unknown | null {
    try {
        return JSON.parse(response);
    } catch {
    // Try to extract JSON from markdown code blocks
        const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlockMatch) {
            try {
                return JSON.parse(codeBlockMatch[1].trim());
            } catch {
                return null;
            }
        }
        return null;
    }
}

/**
 * Counts optional fields in a schema (fields not in 'required' array).
 * Each optional field spawns an implicit anyOf with null.
 */
export function countOptionalFields(schema: JsonSchemaValue): number {
    let count = 0;

    function walk(node: JsonSchemaValue): void {
        if (node.type === 'object' && node.properties) {
            const required = (node.required as string[]) || [];
            const props = node.properties as Record<string, JsonSchemaValue>;

            for (const [key, prop] of Object.entries(props)) {
                if (!required.includes(key)) {
                    count++;
                }
                if (prop && typeof prop === 'object') {
                    walk(prop);
                }
            }
        }

        if (node.type === 'array' && node.items && typeof node.items === 'object') {
            if (!Array.isArray(node.items)) {
                walk(node.items as JsonSchemaValue);
            }
        }

        if (node.anyOf && Array.isArray(node.anyOf)) {
            node.anyOf.forEach(v => {
                if (v && typeof v === 'object') walk(v as JsonSchemaValue);
            });
        }

        if (node.allOf && Array.isArray(node.allOf)) {
            node.allOf.forEach(v => {
                if (v && typeof v === 'object') walk(v as JsonSchemaValue);
            });
        }
    }

    walk(schema);
    return count;
}

/**
 * Estimates schema complexity for UI feedback.
 */
export function estimateSchemaComplexity(schema: StructuredOutputSchema): {
  level: 'simple' | 'moderate' | 'complex' | 'extreme';
  score: number;
  factors: string[];
} {
    const factors: string[] = [];
    let score = 0;

    const result = validateSchema(JSON.stringify(schema));
    if (!result.valid) {
        return { level: 'extreme', score: 100, factors: ['Invalid schema'] };
    }

    // Count various complexity factors
    const value = schema.value;

    function countNodes(node: JsonSchemaValue): number {
        let count = 1;
        if (node.properties) {
            count += Object.keys(node.properties).length;
            for (const prop of Object.values(node.properties)) {
                if (prop && typeof prop === 'object') {
                    count += countNodes(prop as JsonSchemaValue);
                }
            }
        }
        if (node.items && typeof node.items === 'object' && !Array.isArray(node.items)) {
            count += countNodes(node.items as JsonSchemaValue);
        }
        if (node.anyOf && Array.isArray(node.anyOf)) count += node.anyOf.length * 2;
        if (node.allOf && Array.isArray(node.allOf)) count += node.allOf.length * 2;
        return count;
    }

    const nodeCount = countNodes(value);
    const optionalCount = countOptionalFields(value);
    const defCount = Object.keys(value.$defs || value.definitions || {}).length;

    if (nodeCount > 50) {
        score += 30;
        factors.push(`${nodeCount} schema nodes`);
    } else if (nodeCount > 20) {
        score += 15;
        factors.push(`${nodeCount} schema nodes`);
    }

    if (optionalCount > 10) {
        score += 25;
        factors.push(`${optionalCount} optional fields (implicit anyOf)`);
    } else if (optionalCount > 5) {
        score += 10;
        factors.push(`${optionalCount} optional fields`);
    }

    if (defCount > 10) {
        score += 20;
        factors.push(`${defCount} definitions`);
    } else if (defCount > 5) {
        score += 10;
        factors.push(`${defCount} definitions`);
    }

    // Determine level
    let level: 'simple' | 'moderate' | 'complex' | 'extreme';
    if (score >= 60) {
        level = 'extreme';
    } else if (score >= 35) {
        level = 'complex';
    } else if (score >= 15) {
        level = 'moderate';
    } else {
        level = 'simple';
    }

    if (factors.length === 0) {
        factors.push('Simple schema');
    }

    return { level, score, factors };
}
```

## FILE: src/debug.ts
```ts
// src/debug.ts
//
// Debug logging and diagnostics for the extension.

import { MODULE_NAME, MAX_DEBUG_LOG_ENTRIES } from './constants';
import { getSettings } from './settings';
import type { DebugLogEntry, DebugLogType } from './types';

// ============================================================================
// LOG STORAGE
// ============================================================================

const logEntries: DebugLogEntry[] = [];

// ============================================================================
// LOGGING
// ============================================================================

/**
 * Check if debug mode is enabled
 */
export function isDebugMode(): boolean {
    try {
        return getSettings().debugMode;
    } catch {
    // Settings might not be initialized yet
        return false;
    }
}

/**
 * Log a debug entry
 */
export function debugLog(type: DebugLogType, label: string, data: unknown): void {
    const entry: DebugLogEntry = {
        timestamp: new Date(),
        type,
        label,
        data,
    };

    // Always store (for later viewing even if debug mode was off)
    logEntries.unshift(entry);
    if (logEntries.length > MAX_DEBUG_LOG_ENTRIES) {
        logEntries.pop();
    }

    // Only console log if debug mode is on
    if (isDebugMode()) {
        const prefix = `[${MODULE_NAME}:${type.toUpperCase()}]`;
        switch (type) {
            case 'error':
                console.error(prefix, label, data);
                break;
            case 'request':
            case 'response':
                console.debug(prefix, label, data);
                break;
            case 'state':
                console.log(prefix, label, data);
                break;
            default:
                console.log(prefix, label, data);
        }
    }
}

// ============================================================================
// LOG ACCESS
// ============================================================================

/**
 * Get all debug logs
 */
export function getDebugLogs(): DebugLogEntry[] {
    return [...logEntries];
}

/**
 * Get logs filtered by type
 */
export function getDebugLogsByType(type: DebugLogType): DebugLogEntry[] {
    return logEntries.filter(e => e.type === type);
}

/**
 * Clear all debug logs
 */
export function clearDebugLogs(): void {
    logEntries.length = 0;
}

// ============================================================================
// FORMATTING
// ============================================================================

/**
 * Format a log entry for display
 */
export function formatLogEntry(entry: DebugLogEntry): string {
    const time = entry.timestamp.toLocaleTimeString();
    const icon = {
        request: '📤',
        response: '📥',
        error: '❌',
        info: 'ℹ️',
        state: '🔄',
    }[entry.type];

    return `${icon} [${time}] ${entry.label}`;
}

/**
 * Format log data for display
 */
export function formatLogData(data: unknown): string {
    try {
        if (data === null) return 'null';
        if (data === undefined) return 'undefined';
        if (typeof data === 'string') return data;
        return JSON.stringify(data, null, 2);
    } catch {
        return String(data);
    }
}

// ============================================================================
// DIAGNOSTICS
// ============================================================================

/**
 * Collect debug info for current state
 */
export function collectDebugInfo(): Record<string, unknown> {
    const context = SillyTavern.getContext();

    let settings;
    try {
        settings = getSettings();
    } catch {
        settings = { error: 'Failed to load settings' };
    }

    return {
        extension: {
            settings: {
                useCurrentSettings: settings.useCurrentSettings,
                debugMode: settings.debugMode,
                generationConfig: settings.generationConfig,
                systemPromptLength: settings.systemPrompt?.length || 0,
                promptPresetCount: settings.promptPresets?.length || 0,
                schemaPresetCount: settings.schemaPresets?.length || 0,
            },
        },
        sillytavern: {
            mainApi: context.mainApi,
            onlineStatus: context.onlineStatus,
            chatCompletionSource: context.chatCompletionSettings?.chat_completion_source,
            currentModel: context.chatCompletionSettings?.openrouter_model ||
                    context.chatCompletionSettings?.model_openai_select,
            maxContext: context.maxContext,
            characterCount: context.characters?.length ?? 0,
            hasActiveChat: !!context.chat?.length,
        },
        logs: {
            total: logEntries.length,
            errors: logEntries.filter(e => e.type === 'error').length,
            recent: logEntries.slice(0, 10).map(e => ({
                type: e.type,
                label: e.label,
                time: e.timestamp.toISOString(),
            })),
        },
    };
}

/**
 * Export debug info as JSON string
 */
export function exportDebugInfo(): string {
    return JSON.stringify(collectDebugInfo(), null, 2);
}
```

## FILE: src/pipeline.ts
```ts
// src/pipeline.ts
//
// Pipeline state machine for managing the character analysis workflow.
// Handles stage progression, state transitions, result management, and iteration.

import type {
    StageName,
    StageStatus,
    StageResult,
    StageConfig,
    PipelineState,
    Character,
    PopulatedField,
    StructuredOutputSchema,
    IterationSnapshot,
    IterationVerdict,
} from './types';
import { STAGES, CHARACTER_FIELDS, MAX_ITERATION_HISTORY } from './constants';
import { createStageConfigFromDefaults, resolvePrompt, resolveSchema, processPromptTemplate } from './presets';
import { getSettings } from './settings';
import { debugLog } from './debug';

// ============================================================================
// PIPELINE STATE FACTORY
// ============================================================================

/**
 * Create a fresh pipeline state
 */
export function createPipelineState(): PipelineState {
    return {
        character: null,
        characterIndex: null,

        results: {
            score: null,
            rewrite: null,
            analyze: null,
        },

        configs: {
            score: createStageConfigFromDefaults('score'),
            rewrite: createStageConfigFromDefaults('rewrite'),
            analyze: createStageConfigFromDefaults('analyze'),
        },

        selectedStages: ['score', 'rewrite'],  // Default pipeline
        currentStage: null,
        stageStatus: {
            score: 'pending',
            rewrite: 'pending',
            analyze: 'pending',
        },

        // Iteration system
        iterationCount: 0,
        iterationHistory: [],
        isRefining: false,

        exportData: null,
    };
}

/**
 * Reset pipeline state while optionally keeping character selection
 */
export function resetPipeline(state: PipelineState, keepCharacter: boolean = false): PipelineState {
    const fresh = createPipelineState();

    if (keepCharacter && state.character) {
        fresh.character = state.character;
        fresh.characterIndex = state.characterIndex;
    }

    debugLog('state', 'Pipeline reset', { keepCharacter, hasCharacter: !!fresh.character });
    return fresh;
}

// ============================================================================
// CHARACTER MANAGEMENT
// ============================================================================

/**
 * Set the selected character and reset results
 */
export function setCharacter(state: PipelineState, character: Character | null, index: number | null): PipelineState {
    // If same character, don't reset
    if (state.characterIndex === index && index !== null) {
        return state;
    }

    const newState: PipelineState = {
        ...state,
        character,
        characterIndex: index,
        // Reset results when character changes
        results: {
            score: null,
            rewrite: null,
            analyze: null,
        },
        stageStatus: {
            score: 'pending',
            rewrite: 'pending',
            analyze: 'pending',
        },
        currentStage: null,
        // Reset iteration state
        iterationCount: 0,
        iterationHistory: [],
        isRefining: false,
        exportData: null,
    };

    debugLog('state', 'Character set', {
        name: character?.name,
        index,
        fieldsPopulated: character ? getPopulatedFields(character).length : 0,
    });

    return newState;
}

/**
 * Get populated fields from a character
 */
export function getPopulatedFields(char: Character): PopulatedField[] {
    return CHARACTER_FIELDS
        .filter(field => {
            const val = char[field.key];
            return val && typeof val === 'string' && val.trim().length > 0;
        })
        .map(field => {
            const value = (char[field.key] as string).trim();
            return {
                key: field.key,
                label: field.label,
                value,
                charCount: value.length,
                scoreable: field.scoreable,
            };
        });
}

/**
 * Build character summary for prompts
 */
export function buildCharacterSummary(char: Character): string {
    const fields = getPopulatedFields(char);

    const sections = fields.map(f => `### ${f.label}\n${f.value}`);

    return `# CHARACTER: ${char.name}\n\n${sections.join('\n\n')}`;
}

// ============================================================================
// STAGE SELECTION
// ============================================================================

/**
 * Toggle a stage in the selected stages list
 */
export function toggleStage(state: PipelineState, stage: StageName): PipelineState {
    const selected = new Set(state.selectedStages);

    if (selected.has(stage)) {
        selected.delete(stage);
    } else {
        selected.add(stage);
    }

    // Maintain order based on STAGES constant
    const orderedSelected = STAGES.filter(s => selected.has(s));

    debugLog('state', 'Stage toggled', { stage, selected: orderedSelected });

    return {
        ...state,
        selectedStages: orderedSelected,
    };
}

/**
 * Set all selected stages at once
 */
export function setSelectedStages(state: PipelineState, stages: StageName[]): PipelineState {
    // Maintain order based on STAGES constant
    const orderedSelected = STAGES.filter(s => stages.includes(s));

    return {
        ...state,
        selectedStages: orderedSelected,
    };
}

/**
 * Select all stages
 */
export function selectAllStages(state: PipelineState): PipelineState {
    return {
        ...state,
        selectedStages: [...STAGES],
    };
}

/**
 * Check if a stage can be run (has required dependencies)
 */
export function canRunStage(state: PipelineState, stage: StageName): { canRun: boolean; reason?: string } {
    if (!state.character) {
        return { canRun: false, reason: 'No character selected' };
    }

    // Check stage-specific dependencies
    switch (stage) {
        case 'score':
            // Score can always run if we have a character
            return { canRun: true };

        case 'rewrite':
            // Rewrite can run standalone OR with score results
            // If score is in selected stages and not complete, warn but allow
            if (state.selectedStages.includes('score') && !state.results.score?.locked) {
                return {
                    canRun: true,
                    reason: 'Score stage not complete - rewrite will run without score feedback',
                };
            }
            return { canRun: true };

        case 'analyze':
            // Analyze needs rewrite results to compare
            if (!state.results.rewrite) {
                return { canRun: false, reason: 'Analyze requires rewrite results to compare' };
            }
            return { canRun: true };

        default:
            return { canRun: false, reason: 'Unknown stage' };
    }
}

/**
 * Check if refinement can be run
 */
export function canRefine(state: PipelineState): { canRun: boolean; reason?: string } {
    if (!state.character) {
        return { canRun: false, reason: 'No character selected' };
    }

    if (!state.results.rewrite) {
        return { canRun: false, reason: 'No rewrite to refine' };
    }

    if (!state.results.analyze) {
        return { canRun: false, reason: 'Run analyze first to identify issues' };
    }

    return { canRun: true };
}

// ============================================================================
// STAGE CONFIG MANAGEMENT
// ============================================================================

/**
 * Update a stage's config
 */
export function updateStageConfig(
    state: PipelineState,
    stage: StageName,
    updates: Partial<StageConfig>,
): PipelineState {
    return {
        ...state,
        configs: {
            ...state.configs,
            [stage]: {
                ...state.configs[stage],
                ...updates,
            },
        },
    };
}

/**
 * Reset a stage's config to defaults
 */
export function resetStageConfig(state: PipelineState, stage: StageName): PipelineState {
    return {
        ...state,
        configs: {
            ...state.configs,
            [stage]: createStageConfigFromDefaults(stage),
        },
    };
}

// ============================================================================
// STAGE EXECUTION
// ============================================================================

/**
 * Mark a stage as running
 */
export function startStage(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage started', { stage });

    return {
        ...state,
        currentStage: stage,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'running' as StageStatus,
        },
    };
}

/**
 * Complete a stage with results
 */
export function completeStage(
    state: PipelineState,
    stage: StageName,
    result: Omit<StageResult, 'timestamp' | 'locked'>,
): PipelineState {
    const stageResult: StageResult = {
        ...result,
        timestamp: Date.now(),
        locked: false,
    };

    debugLog('state', 'Stage completed', {
        stage,
        responseLength: result.response.length,
        isStructured: result.isStructured,
    });

    // If this is analyze completing, we're now in refinement mode
    const isRefining = stage === 'analyze' && state.results.rewrite !== null;

    return {
        ...state,
        currentStage: null,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'complete' as StageStatus,
        },
        results: {
            ...state.results,
            [stage]: stageResult,
        },
        isRefining,
    };
}

/**
 * Mark a stage as failed (resets to pending)
 */
export function failStage(state: PipelineState, stage: StageName, _error: string): PipelineState {
    debugLog('state', 'Stage failed', { stage, error: _error });

    return {
        ...state,
        currentStage: null,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'pending' as StageStatus,
        },
    };
}

/**
 * Skip a stage
 */
export function skipStage(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage skipped', { stage });

    return {
        ...state,
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'skipped' as StageStatus,
        },
    };
}

/**
 * Lock a stage result (user accepted it)
 */
export function lockStageResult(state: PipelineState, stage: StageName): PipelineState {
    const result = state.results[stage];
    if (!result) return state;

    debugLog('state', 'Stage locked', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: {
                ...result,
                locked: true,
            },
        },
    };
}

/**
 * Unlock a stage result (user wants to regenerate)
 */
export function unlockStageResult(state: PipelineState, stage: StageName): PipelineState {
    const result = state.results[stage];
    if (!result) return state;

    debugLog('state', 'Stage unlocked', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: {
                ...result,
                locked: false,
            },
        },
    };
}

/**
 * Clear a stage result (for regeneration)
 */
export function clearStageResult(state: PipelineState, stage: StageName): PipelineState {
    debugLog('state', 'Stage result cleared', { stage });

    return {
        ...state,
        results: {
            ...state.results,
            [stage]: null,
        },
        stageStatus: {
            ...state.stageStatus,
            [stage]: 'pending' as StageStatus,
        },
    };
}

// ============================================================================
// ITERATION SYSTEM
// ============================================================================

/**
 * Extract verdict from analysis response
 */
export function extractVerdict(analysisResponse: string): IterationVerdict {
    const upper = analysisResponse.toUpperCase();

    // Check for explicit verdict markers
    if (upper.includes('VERDICT') || upper.includes('"VERDICT"')) {
        if (upper.includes('ACCEPT') && !upper.includes('NEEDS')) {
            return 'accept';
        }
        if (upper.includes('REGRESSION')) {
            return 'regression';
        }
        if (upper.includes('NEEDS_REFINEMENT') || upper.includes('NEEDS REFINEMENT')) {
            return 'needs_refinement';
        }
    }

    // Fallback heuristics
    if (upper.includes('READY TO USE') || upper.includes('NO MORE ITERATIONS')) {
        return 'accept';
    }
    if (upper.includes('WORSE THAN') || upper.includes('STEP BACKWARD') || upper.includes('LOST MORE')) {
        return 'regression';
    }

    // Default to needs refinement if we have any issues mentioned
    if (upper.includes('ISSUE') || upper.includes('PROBLEM') || upper.includes('SHOULD FIX')) {
        return 'needs_refinement';
    }

    return 'needs_refinement';
}

/**
 * Create a snapshot of the current iteration before refining
 */
export function createIterationSnapshot(state: PipelineState): IterationSnapshot | null {
    if (!state.results.rewrite || !state.results.analyze) {
        return null;
    }

    const verdict = extractVerdict(state.results.analyze.response);

    return {
        iteration: state.iterationCount,
        rewriteResponse: state.results.rewrite.response,
        rewritePreview: state.results.rewrite.response.substring(0, 200),
        analysisResponse: state.results.analyze.response,
        analysisPreview: state.results.analyze.response.substring(0, 200),
        verdict,
        timestamp: Date.now(),
    };
}

/**
 * Start a refinement iteration
 * - Snapshots current state
 * - Clears analyze result
 * - Increments iteration count
 */
export function startRefinement(state: PipelineState): PipelineState {
    const snapshot = createIterationSnapshot(state);

    if (!snapshot) {
        debugLog('error', 'Cannot start refinement - missing rewrite or analyze', null);
        return state;
    }

    // Add snapshot to history, trim if needed
    const newHistory = [...state.iterationHistory, snapshot];
    if (newHistory.length > MAX_ITERATION_HISTORY) {
        newHistory.shift();
    }

    debugLog('state', 'Starting refinement iteration', {
        iteration: state.iterationCount + 1,
        previousVerdict: snapshot.verdict,
    });

    return {
        ...state,
        iterationHistory: newHistory,
        iterationCount: state.iterationCount + 1,
        // Clear analyze so user must re-analyze after refinement
        results: {
            ...state.results,
            analyze: null,
        },
        stageStatus: {
            ...state.stageStatus,
            analyze: 'pending',
        },
        isRefining: true,
    };
}

/**
 * Complete a refinement (new rewrite generated)
 * The refinement result replaces the current rewrite
 */
export function completeRefinement(
    state: PipelineState,
    refinedRewrite: Omit<StageResult, 'timestamp' | 'locked'>,
): PipelineState {
    const stageResult: StageResult = {
        ...refinedRewrite,
        timestamp: Date.now(),
        locked: false,
    };

    debugLog('state', 'Refinement completed', {
        iteration: state.iterationCount,
        responseLength: refinedRewrite.response.length,
    });

    return {
        ...state,
        currentStage: null,
        results: {
            ...state.results,
            rewrite: stageResult,
            // analyze stays null - user must run it
        },
        stageStatus: {
            ...state.stageStatus,
            rewrite: 'complete',
            analyze: 'pending',
        },
    };
}

/**
 * Revert to a previous iteration
 */
export function revertToIteration(state: PipelineState, iterationIndex: number): PipelineState {
    if (iterationIndex < 0 || iterationIndex >= state.iterationHistory.length) {
        debugLog('error', 'Invalid iteration index', { iterationIndex, historyLength: state.iterationHistory.length });
        return state;
    }

    const snapshot = state.iterationHistory[iterationIndex];

    debugLog('state', 'Reverting to iteration', { iteration: snapshot.iteration });

    // Restore the rewrite from that iteration
    const restoredRewrite: StageResult = {
        response: snapshot.rewriteResponse,
        isStructured: false,
        promptUsed: '[Restored from iteration history]',
        schemaUsed: null,
        timestamp: Date.now(),
        locked: false,
    };

    // Trim history to that point
    const trimmedHistory = state.iterationHistory.slice(0, iterationIndex);

    return {
        ...state,
        results: {
            ...state.results,
            rewrite: restoredRewrite,
            analyze: null,
        },
        stageStatus: {
            ...state.stageStatus,
            rewrite: 'complete',
            analyze: 'pending',
        },
        iterationCount: snapshot.iteration,
        iterationHistory: trimmedHistory,
        isRefining: true,
    };
}

/**
 * Accept current rewrite as final (exit refinement loop)
 */
export function acceptRewrite(state: PipelineState): PipelineState {
    if (!state.results.rewrite) {
        return state;
    }

    debugLog('state', 'Rewrite accepted as final', { iteration: state.iterationCount });

    return {
        ...state,
        results: {
            ...state.results,
            rewrite: {
                ...state.results.rewrite,
                locked: true,
            },
        },
        isRefining: false,
    };
}

// ============================================================================
// PIPELINE NAVIGATION
// ============================================================================

/**
 * Get the next stage in the selected pipeline
 */
export function getNextStage(state: PipelineState, currentStage: StageName): StageName | null {
    const currentIndex = state.selectedStages.indexOf(currentStage);
    if (currentIndex === -1 || currentIndex >= state.selectedStages.length - 1) {
        return null;
    }
    return state.selectedStages[currentIndex + 1];
}

/**
 * Get the previous stage in the selected pipeline
 */
export function getPreviousStage(state: PipelineState, currentStage: StageName): StageName | null {
    const currentIndex = state.selectedStages.indexOf(currentStage);
    if (currentIndex <= 0) {
        return null;
    }
    return state.selectedStages[currentIndex - 1];
}

/**
 * Get the first incomplete stage in the pipeline
 */
export function getFirstIncompleteStage(state: PipelineState): StageName | null {
    for (const stage of state.selectedStages) {
        const status = state.stageStatus[stage];
        if (status === 'pending' || status === 'running') {
            return stage;
        }
    }
    return null;
}

/**
 * Check if all selected stages are complete
 */
export function isPipelineComplete(state: PipelineState): boolean {
    return state.selectedStages.every(stage => {
        const status = state.stageStatus[stage];
        return status === 'complete' || status === 'skipped';
    });
}

/**
 * Check if pipeline is ready for export
 */
export function canExport(state: PipelineState): boolean {
    // Need at least rewrite results to export
    return !!state.results.rewrite;
}

// ============================================================================
// PROMPT BUILDING
// ============================================================================

/**
 * Build the complete prompt for a stage, including template substitution.
 */
export function buildStagePrompt(state: PipelineState, stage: StageName): string | null {
    if (!state.character) {
        return null;
    }

    const config = state.configs[stage];
    const basePrompt = resolvePrompt(config);

    if (!basePrompt.trim()) {
        return null;
    }

    // Build character summary
    const characterSummary = buildCharacterSummary(state.character);

    // Build template context with all available data
    const { name1 } = SillyTavern.getContext();

    const context = {
        originalCharacter: characterSummary,
        scoreResults: state.results.score?.response || '',
        rewriteResults: state.results.rewrite?.response || '',
        currentRewrite: state.results.rewrite?.response || '',
        currentAnalysis: state.results.analyze?.response || '',
        iterationNumber: String(state.iterationCount + 1),
        charName: state.character.name,
        userName: name1 || 'User',
    };

    // Check which placeholders are used in the prompt
    const promptLower = basePrompt.toLowerCase();
    const usesCharacterPlaceholder = promptLower.includes('{{original_character}}');
    const usesScorePlaceholder = promptLower.includes('{{score_results}}');
    const usesRewritePlaceholder = promptLower.includes('{{rewrite_results}}');

    // Process template placeholders in the prompt
    const processedPrompt = processPromptTemplate(basePrompt, context);

    // If ALL relevant placeholders are used, just return the processed prompt
    const allPlaceholdersUsed = checkAllPlaceholdersUsed(stage, usesCharacterPlaceholder, usesScorePlaceholder, usesRewritePlaceholder, state);

    if (allPlaceholdersUsed) {
        return processedPrompt;
    }

    // Otherwise, build a structured prompt with all relevant data
    return buildStructuredPrompt(stage, state, characterSummary, processedPrompt, {
        usesCharacterPlaceholder,
        usesScorePlaceholder,
        usesRewritePlaceholder,
    });
}

/**
 * Build the refinement prompt
 */
export function buildRefinementPrompt(state: PipelineState): string | null {
    if (!state.character || !state.results.rewrite || !state.results.analyze) {
        return null;
    }

    const settings = getSettings();
    const basePrompt = settings.refinementPrompt;

    const characterSummary = buildCharacterSummary(state.character);
    const { name1 } = SillyTavern.getContext();

    const context = {
        originalCharacter: characterSummary,
        scoreResults: state.results.score?.response || '',
        rewriteResults: state.results.rewrite.response,
        currentRewrite: state.results.rewrite.response,
        currentAnalysis: state.results.analyze.response,
        iterationNumber: String(state.iterationCount + 1),
        charName: state.character.name,
        userName: name1 || 'User',
    };

    return processPromptTemplate(basePrompt, context);
}

/**
 * Check if all relevant placeholders for a stage are used
 */
function checkAllPlaceholdersUsed(
    stage: StageName,
    usesCharacter: boolean,
    usesScore: boolean,
    usesRewrite: boolean,
    state: PipelineState,
): boolean {
    switch (stage) {
        case 'score':
            // Score only needs character
            return usesCharacter;

        case 'rewrite':
            // Rewrite needs character, and score if available
            if (!usesCharacter) return false;
            if (state.results.score && !usesScore) return false;
            return true;

        case 'analyze':
            // Analyze needs character, rewrite, and score if available
            if (!usesCharacter) return false;
            if (state.results.rewrite && !usesRewrite) return false;
            if (state.results.score && !usesScore) return false;
            return true;

        default:
            return false;
    }
}

/**
 * Build a structured prompt with all relevant data prepended
 */
function buildStructuredPrompt(
    stage: StageName,
    state: PipelineState,
    characterSummary: string,
    instructions: string,
    usedPlaceholders: { usesCharacterPlaceholder: boolean; usesScorePlaceholder: boolean; usesRewritePlaceholder: boolean },
): string {
    const parts: string[] = [];

    // Always include character if not already in prompt via placeholder
    if (!usedPlaceholders.usesCharacterPlaceholder) {
        const stageAction = stage === 'score' ? 'Analyze' : stage === 'rewrite' ? 'Rewrite' : 'Compare';
        parts.push(`# Character to ${stageAction}`, '', characterSummary);
    }

    // Stage-specific data
    switch (stage) {
        case 'score':
            // Score only needs character - already added above
            break;

        case 'rewrite':
            // Include score results if available and not already in prompt
            if (state.results.score?.response && !usedPlaceholders.usesScorePlaceholder) {
                parts.push('', '---', '', '# Score Feedback', '', 'Use this feedback to guide your rewrite:', '', state.results.score.response);
            }
            break;

        case 'analyze':
            // Include rewrite results if available and not already in prompt
            if (state.results.rewrite?.response && !usedPlaceholders.usesRewritePlaceholder) {
                parts.push('', '---', '', '# Rewritten Version', '', 'Compare this against the original:', '', state.results.rewrite.response);
            }

            // Include score results if available and not already in prompt
            if (state.results.score?.response && !usedPlaceholders.usesScorePlaceholder) {
                parts.push('', '---', '', '# Original Score Feedback', '', 'Reference for what was identified as needing improvement:', '', state.results.score.response);
            }
            break;
    }

    // Add the instructions/prompt
    parts.push('', '---', '', '# Instructions', '', instructions);

    return parts.join('\n');
}

/**
 * Get the schema for a stage (if structured output is enabled)
 */
export function getStageSchema(state: PipelineState, stage: StageName): StructuredOutputSchema | null {
    const config = state.configs[stage];
    return resolveSchema(config);
}

// ============================================================================
// EXPORT
// ============================================================================

/**
 * Generate export data from rewrite results
 */
export function generateExportData(state: PipelineState): string | null {
    if (!state.results.rewrite || !state.character) {
        return null;
    }

    const rewriteResponse = state.results.rewrite.response;

    const exportLines = [
        `# ${state.character.name} (Rewritten)`,
        '',
        `Generated: ${new Date().toLocaleString()}`,
        `Iterations: ${state.iterationCount}`,
        '',
        '---',
        '',
        rewriteResponse,
    ];

    // If we have analyze results, include them as notes
    if (state.results.analyze) {
        exportLines.push(
            '',
            '---',
            '',
            '## Final Analysis',
            '',
            state.results.analyze.response,
        );
    }

    // If we have score results, include summary
    if (state.results.score) {
        exportLines.push(
            '',
            '---',
            '',
            '## Original Score',
            '',
            state.results.score.response,
        );
    }

    // Include iteration history summary if we have any
    if (state.iterationHistory.length > 0) {
        exportLines.push(
            '',
            '---',
            '',
            '## Iteration History',
            '',
        );

        for (const snap of state.iterationHistory) {
            exportLines.push(
                `### Iteration ${snap.iteration + 1} - ${snap.verdict.toUpperCase()}`,
                `${new Date(snap.timestamp).toLocaleString()}`,
                '',
            );
        }
    }

    return exportLines.join('\n');
}

/**
 * Set export data in state
 */
export function setExportData(state: PipelineState): PipelineState {
    const exportData = generateExportData(state);

    return {
        ...state,
        exportData,
    };
}

// ============================================================================
// STATE QUERIES
// ============================================================================

/**
 * Get a summary of pipeline state for debugging/display
 */
export function getPipelineSummary(state: PipelineState): {
  hasCharacter: boolean;
  characterName: string | null;
  selectedStages: StageName[];
  stageStatuses: Record<StageName, StageStatus>;
  completedStages: StageName[];
  lockedStages: StageName[];
  currentStage: StageName | null;
  canExport: boolean;
  isComplete: boolean;
  iterationCount: number;
  isRefining: boolean;
  lastVerdict: IterationVerdict | null;
} {
    const completedStages = STAGES.filter(s => state.stageStatus[s] === 'complete');
    const lockedStages = STAGES.filter(s => state.results[s]?.locked);

    const lastSnapshot = state.iterationHistory.length > 0
        ? state.iterationHistory[state.iterationHistory.length - 1]
        : null;

    return {
        hasCharacter: !!state.character,
        characterName: state.character?.name || null,
        selectedStages: state.selectedStages,
        stageStatuses: { ...state.stageStatus },
        completedStages,
        lockedStages,
        currentStage: state.currentStage,
        canExport: canExport(state),
        isComplete: isPipelineComplete(state),
        iterationCount: state.iterationCount,
        isRefining: state.isRefining,
        lastVerdict: lastSnapshot?.verdict || null,
    };
}

/**
 * Check if a specific stage has results (complete or not)
 */
export function hasStageResult(state: PipelineState, stage: StageName): boolean {
    return !!state.results[stage];
}

/**
 * Check if a specific stage result is locked
 */
export function isStageResultLocked(state: PipelineState, stage: StageName): boolean {
    return !!state.results[stage]?.locked;
}

/**
 * Get stage result if available
 */
export function getStageResult(state: PipelineState, stage: StageName): StageResult | null {
    return state.results[stage];
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Validate pipeline state before running
 */
export interface PipelineValidation {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export function validatePipeline(state: PipelineState): PipelineValidation {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Must have character
    if (!state.character) {
        errors.push('No character selected');
    }

    // Must have at least one stage selected
    if (state.selectedStages.length === 0) {
        errors.push('No stages selected');
    }

    // Check each selected stage
    for (const stage of state.selectedStages) {
        const config = state.configs[stage];
        const prompt = resolvePrompt(config);

        if (!prompt.trim()) {
            errors.push(`${stage}: No prompt configured`);
        }

        // Warn about missing dependencies (but don't error - we auto-include now)
        if (stage === 'rewrite' && !state.results.score && state.selectedStages.includes('score')) {
            warnings.push('Rewrite will run without score feedback (score not complete)');
        }

        if (stage === 'analyze' && !state.results.rewrite) {
            errors.push('Analyze requires rewrite results');
        }
    }

    // Check API readiness
    const { onlineStatus } = SillyTavern.getContext();
    if (onlineStatus !== 'Valid' && onlineStatus !== 'Connected') {
        errors.push('API is not connected');
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

/**
 * Validate refinement before running
 */
export function validateRefinement(state: PipelineState): PipelineValidation {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!state.character) {
        errors.push('No character selected');
    }

    if (!state.results.rewrite) {
        errors.push('No rewrite to refine');
    }

    if (!state.results.analyze) {
        errors.push('Run analyze first to identify issues');
    }

    // Check API readiness
    const { onlineStatus } = SillyTavern.getContext();
    if (onlineStatus !== 'Valid' && onlineStatus !== 'Connected') {
        errors.push('API is not connected');
    }

    // Warn if last verdict was accept
    const lastSnapshot = state.iterationHistory.length > 0
        ? state.iterationHistory[state.iterationHistory.length - 1]
        : null;

    if (lastSnapshot?.verdict === 'accept') {
        warnings.push('Last analysis suggested accepting the rewrite');
    }

    if (state.iterationCount >= 5) {
        warnings.push(`Already at iteration ${state.iterationCount + 1} - consider accepting or starting fresh`);
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

// ============================================================================
// SERIALIZATION (for potential future persistence)
// ============================================================================

/**
 * Serialize pipeline state to JSON-safe object
 */
export function serializePipelineState(state: PipelineState): Record<string, unknown> {
    return {
        characterIndex: state.characterIndex,
        results: state.results,
        configs: state.configs,
        selectedStages: state.selectedStages,
        stageStatus: state.stageStatus,
        iterationCount: state.iterationCount,
        iterationHistory: state.iterationHistory,
        isRefining: state.isRefining,
        exportData: state.exportData,
        // Don't serialize character - will be re-fetched by index
    };
}

/**
 * Deserialize pipeline state (would need character list to restore character)
 */
export function deserializePipelineState(
    data: Record<string, unknown>,
    characters: Character[],
): PipelineState | null {
    try {
        const characterIndex = data.characterIndex as number | null;
        const character = characterIndex !== null ? characters[characterIndex] : null;

        return {
            character,
            characterIndex,
            results: data.results as PipelineState['results'],
            configs: data.configs as PipelineState['configs'],
            selectedStages: data.selectedStages as StageName[],
            currentStage: null,  // Always reset to null on restore
            stageStatus: data.stageStatus as Record<StageName, StageStatus>,
            iterationCount: (data.iterationCount as number) || 0,
            iterationHistory: (data.iterationHistory as IterationSnapshot[]) || [],
            isRefining: (data.isRefining as boolean) || false,
            exportData: data.exportData as string | null,
        };
    } catch (e) {
        debugLog('error', 'Failed to deserialize pipeline state', e);
        return null;
    }
}
```

## FILE: src/presets.ts
```ts
// src/presets.ts
//
// This module provides higher-level preset operations and utilities.
// Basic CRUD is in settings.ts; this handles resolution, validation, and UI helpers.

import type {
    StageName,
    StageConfig,
    PromptPreset,
    SchemaPreset,
    StructuredOutputSchema,
} from './types';
import {
    getSettings,
    getPromptPreset,
    getSchemaPreset,
    getPromptPresets,
    getSchemaPresets,
} from './settings';
import { validateSchema, formatSchema } from './schema';
import { TEMPLATE_PLACEHOLDERS } from './constants';
import { debugLog } from './debug';

// ============================================================================
// STAGE CONFIG RESOLUTION
// ============================================================================

/**
 * Get the effective stage config, resolving presets to actual values.
 * Returns a StageConfig with resolved prompt and schema.
 */
export function getStageConfig(stage: StageName): StageConfig {
    const settings = getSettings();
    const defaults = settings.stageDefaults[stage];

    return {
        promptPresetId: defaults.promptPresetId,
        customPrompt: defaults.customPrompt,
        schemaPresetId: defaults.schemaPresetId,
        customSchema: defaults.customSchema,
        useStructuredOutput: defaults.useStructuredOutput,
    };
}

/**
 * Resolve a stage config to get the actual prompt text.
 * If a preset is selected, returns the preset's prompt.
 * Otherwise returns the custom prompt.
 */
export function resolvePrompt(config: StageConfig): string {
    if (config.promptPresetId) {
        const preset = getPromptPreset(config.promptPresetId);
        if (preset) {
            return preset.prompt;
        }
        debugLog('error', 'Prompt preset not found', { id: config.promptPresetId });
    }

    return config.customPrompt;
}

/**
 * Resolve a stage config to get the actual schema.
 * Returns null if structured output is disabled or no schema is configured.
 */
export function resolveSchema(config: StageConfig): StructuredOutputSchema | null {
    if (!config.useStructuredOutput) {
        return null;
    }

    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) {
            return preset.schema;
        }
        debugLog('error', 'Schema preset not found', { id: config.schemaPresetId });
    }

    // Try to parse custom schema
    if (config.customSchema) {
        const result = validateSchema(config.customSchema);
        if (result.valid && result.schema) {
            return result.schema;
        }
        debugLog('error', 'Custom schema invalid', { error: result.error });
    }

    return null;
}

/**
 * Create a fresh StageConfig from defaults
 */
export function createStageConfigFromDefaults(stage: StageName): StageConfig {
    const settings = getSettings();
    const defaults = settings.stageDefaults[stage];

    return {
        promptPresetId: defaults.promptPresetId,
        customPrompt: defaults.customPrompt,
        schemaPresetId: defaults.schemaPresetId,
        customSchema: defaults.customSchema,
        useStructuredOutput: defaults.useStructuredOutput,
    };
}

// ============================================================================
// PROMPT TEMPLATE PROCESSING
// ============================================================================

export interface TemplateContext {
  originalCharacter?: string;
  scoreResults?: string;
  rewriteResults?: string;
  currentRewrite?: string;
  currentAnalysis?: string;
  iterationNumber?: string;
  charName?: string;
  userName?: string;
}

/**
 * Process a prompt template, replacing placeholders with actual values.
 *
 * Order of operations:
 * 1. Run ST's substituteParams for standard macros ({{time}}, {{date}}, etc.)
 * 2. Replace our custom placeholders ({{original_character}}, {{score_results}}, etc.)
 * 3. Replace {{char}} and {{user}} with our specific character/user names
 *    (This overrides ST's substitution which uses the active chat character)
 * 4. Handle conditional blocks {{#if score_results}}...{{/if}}
 */
export function processPromptTemplate(prompt: string, context: TemplateContext): string {
    // First, run ST's macro substitution for standard macros
    const { substituteParams } = SillyTavern.getContext();
    let processed = substituteParams(prompt);

    // Handle conditional blocks first
    processed = processConditionalBlocks(processed, context);

    // Now replace our custom placeholders
    if (context.originalCharacter !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.ORIGINAL_CHARACTER), 'gi'),
            context.originalCharacter,
        );
    }

    if (context.scoreResults !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.SCORE_RESULTS), 'gi'),
            context.scoreResults,
        );
    }

    if (context.rewriteResults !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.REWRITE_RESULTS), 'gi'),
            context.rewriteResults,
        );
    }

    if (context.currentRewrite !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.CURRENT_REWRITE), 'gi'),
            context.currentRewrite,
        );
    }

    if (context.currentAnalysis !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.CURRENT_ANALYSIS), 'gi'),
            context.currentAnalysis,
        );
    }

    if (context.iterationNumber !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.ITERATION_NUMBER), 'gi'),
            context.iterationNumber,
        );
    }

    // Replace {{char_name}} with our specific character
    if (context.charName !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.CHARACTER_NAME), 'gi'),
            context.charName,
        );
    }

    // Replace {{user_name}} with our specific user
    if (context.userName !== undefined) {
        processed = processed.replace(
            new RegExp(escapeRegex(TEMPLATE_PLACEHOLDERS.USER_NAME), 'gi'),
            context.userName,
        );
    }

    // IMPORTANT: Also replace {{char}} and {{user}} with our specific names
    if (context.charName !== undefined) {
        processed = processed.replace(/\{\{char\}\}/gi, context.charName);
    }

    if (context.userName !== undefined) {
        processed = processed.replace(/\{\{user\}\}/gi, context.userName);
    }

    return processed;
}

/**
 * Process conditional blocks like {{#if score_results}}...{{/if}}
 */
function processConditionalBlocks(prompt: string, context: TemplateContext): string {
    // Match {{#if variable}}...{{/if}} blocks
    const conditionalRegex = /\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/gi;

    return prompt.replace(conditionalRegex, (match, variable, content) => {
        const varName = variable.toLowerCase();

        // Check if the variable has a truthy value
        let hasValue = false;

        switch (varName) {
            case 'score_results':
                hasValue = !!context.scoreResults?.trim();
                break;
            case 'rewrite_results':
                hasValue = !!context.rewriteResults?.trim();
                break;
            case 'current_rewrite':
                hasValue = !!context.currentRewrite?.trim();
                break;
            case 'current_analysis':
                hasValue = !!context.currentAnalysis?.trim();
                break;
            case 'original_character':
                hasValue = !!context.originalCharacter?.trim();
                break;
            case 'iteration_number':
                hasValue = !!context.iterationNumber && context.iterationNumber !== '0';
                break;
            default:
                hasValue = false;
        }

        return hasValue ? content : '';
    });
}

/**
 * Check if a prompt contains any template placeholders
 */
export function promptHasPlaceholders(prompt: string): string[] {
    const found: string[] = [];

    for (const [key, placeholder] of Object.entries(TEMPLATE_PLACEHOLDERS)) {
        if (prompt.toLowerCase().includes(placeholder.toLowerCase())) {
            found.push(key);
        }
    }

    return found;
}

/**
 * Get placeholders that are used but won't have values for a given stage
 */
export function getUnfilledPlaceholders(prompt: string, stage: StageName, hasScore: boolean, hasRewrite: boolean): string[] {
    const used = promptHasPlaceholders(prompt);
    const unfilled: string[] = [];

    for (const placeholder of used) {
        switch (placeholder) {
            case 'SCORE_RESULTS':
                if (!hasScore && stage !== 'score') {
                    unfilled.push('{{score_results}} - no score results available');
                }
                break;
            case 'REWRITE_RESULTS':
            case 'CURRENT_REWRITE':
                if (!hasRewrite && stage !== 'rewrite') {
                    unfilled.push('{{rewrite_results}} - no rewrite results available');
                }
                break;
            case 'CURRENT_ANALYSIS':
                // Only available during refinement
                unfilled.push('{{current_analysis}} - only available during refinement');
                break;
            // ORIGINAL_CHARACTER is always available if we have a character
            // CHAR_NAME and USER_NAME are always available
            // ITERATION_NUMBER is always available
        }
    }

    return unfilled;
}

// ============================================================================
// PRESET UI HELPERS
// ============================================================================

export interface PresetOption {
  id: string;
  name: string;
  isBuiltin: boolean;
  isSelected: boolean;
}

/**
 * Get prompt presets formatted for a dropdown, with selection state
 */
export function getPromptPresetOptions(stage: StageName, selectedId: string | null): PresetOption[] {
    const presets = getPromptPresets(stage);

    return presets.map(p => ({
        id: p.id,
        name: p.isBuiltin ? `${p.name} (builtin)` : p.name,
        isBuiltin: p.isBuiltin,
        isSelected: p.id === selectedId,
    }));
}

/**
 * Get schema presets formatted for a dropdown, with selection state
 */
export function getSchemaPresetOptions(stage: StageName, selectedId: string | null): PresetOption[] {
    const presets = getSchemaPresets(stage);

    return presets.map(p => ({
        id: p.id,
        name: p.isBuiltin ? `${p.name} (builtin)` : p.name,
        isBuiltin: p.isBuiltin,
        isSelected: p.id === selectedId,
    }));
}

/**
 * Get the display name for a preset (handles null/missing)
 */
export function getPresetDisplayName(type: 'prompt' | 'schema', id: string | null): string {
    if (!id) {
        return 'Custom';
    }

    const preset = type === 'prompt' ? getPromptPreset(id) : getSchemaPreset(id);
    if (!preset) {
        return 'Unknown';
    }

    return preset.name;
}

// ============================================================================
// SCHEMA HELPERS
// ============================================================================

/**
 * Get the schema JSON string for editing, either from preset or custom
 */
export function getSchemaForEditing(config: StageConfig): string {
    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) {
            return formatSchema(preset.schema);
        }
    }

    return config.customSchema;
}

/**
 * Validate a schema string and return user-friendly result
 */
export interface SchemaValidationUIResult {
  isValid: boolean;
  isEmpty: boolean;
  errorMessage: string | null;
  warnings: string[];
  info: string[];
}

export function validateSchemaForUI(schemaJson: string): SchemaValidationUIResult {
    if (!schemaJson.trim()) {
        return {
            isValid: true,
            isEmpty: true,
            errorMessage: null,
            warnings: [],
            info: ['Empty schema = structured output disabled'],
        };
    }

    const result = validateSchema(schemaJson);

    return {
        isValid: result.valid,
        isEmpty: false,
        errorMessage: result.error || null,
        warnings: result.warnings || [],
        info: result.info || [],
    };
}

// ============================================================================
// PRESET VALIDATION
// ============================================================================

/**
 * Validate a prompt preset before saving
 */
export interface PresetValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export function validatePromptPreset(preset: Partial<PromptPreset>): PresetValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!preset.name?.trim()) {
        errors.push('Name is required');
    } else if (preset.name.length > 100) {
        errors.push('Name must be 100 characters or less');
    }

    if (!preset.prompt?.trim()) {
        errors.push('Prompt is required');
    } else if (preset.prompt.length > 50000) {
        errors.push('Prompt is too long (max 50,000 characters)');
    }

    // Check for common issues
    if (preset.prompt) {
        if (preset.prompt.includes('{{') && !promptHasPlaceholders(preset.prompt).length) {
            warnings.push('Prompt contains {{ but no recognized placeholders');
        }
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

/**
 * Validate a schema preset before saving
 */
export function validateSchemaPreset(preset: Partial<SchemaPreset>): PresetValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!preset.name?.trim()) {
        errors.push('Name is required');
    } else if (preset.name.length > 100) {
        errors.push('Name must be 100 characters or less');
    }

    if (!preset.schema) {
        errors.push('Schema is required');
    } else {
        const schemaJson = typeof preset.schema === 'string'
            ? preset.schema
            : JSON.stringify(preset.schema);

        const result = validateSchema(schemaJson);
        if (!result.valid) {
            errors.push(result.error || 'Invalid schema');
        }
        if (result.warnings) {
            warnings.push(...result.warnings);
        }
    }

    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Check if a preset name is unique (for validation)
 */
export function isPresetNameUnique(type: 'prompt' | 'schema', name: string, excludeId?: string): boolean {
    const presets = type === 'prompt' ? getPromptPresets() : getSchemaPresets();

    return !presets.some(p =>
        p.name.toLowerCase() === name.toLowerCase() && p.id !== excludeId,
    );
}

/**
 * Generate a unique preset name by appending a number if needed
 */
export function generateUniquePresetName(type: 'prompt' | 'schema', baseName: string): string {
    let name = baseName;
    let counter = 1;

    while (!isPresetNameUnique(type, name)) {
        name = `${baseName} (${counter})`;
        counter++;
    }

    return name;
}
```

## FILE: src/ui/formatter.ts
```ts
// src/ui/formatter.ts
//
// Response formatting for display

import type { StructuredOutputSchema, JsonSchemaValue } from '../types';

// ============================================================================
// MAIN ENTRY POINTS
// ============================================================================

/**
 * Format a plain text/markdown response
 */
export function formatResponse(response: string, moduleName: string): string {
    const { showdown, DOMPurify } = SillyTavern.libs;
    const text = typeof response === 'string' ? response : String(response ?? '');

    const converter = new showdown.Converter({
        tables: true,
        strikethrough: true,
        simpleLineBreaks: false,
        headerLevelStart: 1,
        ghCodeBlocks: true,
        tasklists: true,
        openLinksInNewWindow: true,
        emoji: true,
        parseImgDimensions: true,
        simplifiedAutoLink: true,
    });

    const html = converter.makeHtml(text);
    const wrapped = `<div class="${moduleName}_markdown_content">${html}</div>`;

    return DOMPurify.sanitize(wrapped);
}

/**
 * Format a structured JSON response
 */
export function formatStructuredResponse(
    response: string,
    schema: StructuredOutputSchema | null,
    moduleName: string,
): string {
    const { DOMPurify } = SillyTavern.libs;
    const text = typeof response === 'string' ? response : String(response ?? '');

    const parsed = parseStructuredResponse(text);

    if (!parsed || typeof parsed !== 'object') {
        return formatResponse(text, moduleName);
    }

    const schemaValue = schema?.value ?? inferSchema(parsed);
    const html = renderStructuredRoot(parsed as Record<string, unknown>, schemaValue, moduleName);

    return DOMPurify.sanitize(html);
}

/**
 * Parse a structured response (handles JSON and code blocks)
 */
export function parseStructuredResponse(response: string): unknown | null {
    try {
        return JSON.parse(response);
    } catch {
    // Try to extract JSON from markdown code blocks
        const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
        if (codeBlockMatch) {
            try {
                return JSON.parse(codeBlockMatch[1].trim());
            } catch {
                return null;
            }
        }
        return null;
    }
}

// ============================================================================
// SCHEMA INFERENCE
// ============================================================================

function inferSchema(data: unknown): JsonSchemaValue {
    if (data === null) return { type: 'null' };
    if (Array.isArray(data)) {
        return {
            type: 'array',
            items: data.length > 0 ? inferSchema(data[0]) : { type: 'string' },
        };
    }
    if (typeof data === 'object') {
        const properties: Record<string, JsonSchemaValue> = {};
        for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
            properties[key] = inferSchema(value);
        }
        return { type: 'object', properties };
    }
    return { type: typeof data as 'string' | 'number' | 'boolean' };
}

// ============================================================================
// STRUCTURED RENDERING
// ============================================================================

const MAX_DEPTH = 8;

function renderStructuredRoot(
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
): string {
    const heroKey = findHeroKey(data);
    const heroValue = heroKey ? data[heroKey] : null;

    const sections: string[] = [];

    // Hero score at top
    if (heroKey && typeof heroValue === 'number') {
        sections.push(renderHero(heroKey, heroValue, moduleName));
    }

    // Render all fields
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    for (const key of keys) {
        if (key === heroKey) continue;
        const value = data[key];
        if (value === undefined) continue;

        const propSchema = properties[key] || { type: inferType(value) };
        sections.push(renderField(key, value, propSchema as JsonSchemaValue, moduleName, 0));
    }

    return `<div class="${moduleName}_structured_content">${sections.join('')}</div>`;
}

function renderHero(key: string, value: number, moduleName: string): string {
    const label = formatLabel(key);
    const color = getScoreColor(value > 10 ? value / 10 : value);
    const display = Number.isInteger(value) ? value : value.toFixed(1);
    const max = value > 10 ? 100 : 10;

    return `
    <div class="${moduleName}_hero">
      <div class="${moduleName}_hero_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_hero_value" style="color: ${color}">
        ${display}<span class="${moduleName}_hero_max">/${max}</span>
      </div>
    </div>
  `;
}

function renderField(
    key: string,
    value: unknown,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    if (depth > MAX_DEPTH) {
        return renderJson(value, moduleName);
    }

    const label = formatLabel(key);
    const type = schema.type || inferType(value);

    if (type === 'array' && Array.isArray(value)) {
        return renderArrayField(label, value, schema, moduleName, depth);
    }

    if (type === 'object' && typeof value === 'object' && value !== null) {
        return renderObjectField(label, value as Record<string, unknown>, schema, moduleName, depth);
    }

    const rendered = renderValue(value, schema, moduleName, key);

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_field_value">${rendered}</div>
    </div>
  `;
}

function renderArrayField(
    label: string,
    items: unknown[],
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    if (items.length === 0) {
        return `
      <div class="${moduleName}_field">
        <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
        <div class="${moduleName}_field_value ${moduleName}_empty">(none)</div>
      </div>
    `;
    }

    const itemSchema = (schema.items || { type: inferType(items[0]) }) as JsonSchemaValue;

    // Simple values as list
    if (items.every(isSimpleValue)) {
        const listItems = items.map(item => `<li>${renderSimpleValue(item, moduleName)}</li>`).join('');
        return `
      <div class="${moduleName}_field">
        <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
        <ol class="${moduleName}_list">${listItems}</ol>
      </div>
    `;
    }

    // Complex values as cards
    const cards = items.map((item, index) => {
        if (typeof item === 'object' && item !== null) {
            return renderCard(item as Record<string, unknown>, itemSchema, moduleName, depth + 1, index);
        }
        return `<div class="${moduleName}_card">${renderValue(item, itemSchema, moduleName)}</div>`;
    }).join('');

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_cards">${cards}</div>
    </div>
  `;
}

function renderCard(
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
    _index: number,
): string {
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    // Find title, score, and body fields
    const titleKey = keys.find(k => typeof data[k] === 'string' && (data[k] as string).length < 100);
    const scoreKey = keys.find(k => typeof data[k] === 'number' && ((data[k] as number) >= 0 && (data[k] as number) <= 100));
    const bodyKey = keys.find(k => typeof data[k] === 'string' && (data[k] as string).length >= 50 && k !== titleKey);

    let header = '';
    if (titleKey || scoreKey) {
        const titlePart = titleKey
            ? `<span class="${moduleName}_card_title">${escapeHtml(String(data[titleKey]))}</span>`
            : '';
        const scorePart = scoreKey
            ? renderScore(data[scoreKey] as number, moduleName)
            : '';
        header = `<div class="${moduleName}_card_header">${titlePart}${scorePart}</div>`;
    }

    let body = '';
    if (bodyKey) {
        body = `<div class="${moduleName}_card_body">${renderLongText(String(data[bodyKey]), moduleName)}</div>`;
    }

    const remainingKeys = keys.filter(k => k !== titleKey && k !== scoreKey && k !== bodyKey);
    const remaining = remainingKeys.map(k => {
        const v = data[k];
        if (v === undefined) return '';
        const propSchema = properties[k] || { type: inferType(v) };
        return renderField(k, v, propSchema as JsonSchemaValue, moduleName, depth + 1);
    }).filter(Boolean).join('');

    const extra = remaining ? `<div class="${moduleName}_card_extra">${remaining}</div>` : '';

    return `<div class="${moduleName}_card">${header}${body}${extra}</div>`;
}

function renderObjectField(
    label: string,
    data: Record<string, unknown>,
    schema: JsonSchemaValue,
    moduleName: string,
    depth: number,
): string {
    const properties = (schema.properties || {}) as Record<string, JsonSchemaValue>;
    const keys = Object.keys(properties).length > 0 ? Object.keys(properties) : Object.keys(data);

    const fields = keys.map(k => {
        const v = data[k];
        if (v === undefined) return '';
        const propSchema = properties[k] || { type: inferType(v) };
        return renderField(k, v, propSchema as JsonSchemaValue, moduleName, depth + 1);
    }).filter(Boolean).join('');

    return `
    <div class="${moduleName}_field">
      <div class="${moduleName}_field_label">${escapeHtml(label)}</div>
      <div class="${moduleName}_nested">${fields}</div>
    </div>
  `;
}

function renderValue(
    value: unknown,
    schema: JsonSchemaValue,
    moduleName: string,
    fieldName?: string,
): string {
    if (value === null || value === undefined) {
        return `<span class="${moduleName}_null">—</span>`;
    }

    const type = schema.type || inferType(value);

    switch (type) {
        case 'string':
            return renderString(value as string, schema, moduleName);
        case 'number':
        case 'integer':
            return renderNumber(value as number, schema, moduleName, fieldName);
        case 'boolean':
            return renderBoolean(value as boolean, moduleName);
        default:
            return `<span>${escapeHtml(String(value))}</span>`;
    }
}

function renderString(data: string, schema: JsonSchemaValue, moduleName: string): string {
    if (!data.trim()) {
        return `<span class="${moduleName}_empty">(empty)</span>`;
    }

    const format = schema.format as string | undefined;

    if (format === 'uri' || format === 'url' || isUrl(data)) {
        const display = data.length > 50 ? data.substring(0, 47) + '...' : data;
        return `<a href="${escapeHtml(data)}" target="_blank" rel="noopener" class="${moduleName}_link">${escapeHtml(display)}</a>`;
    }

    if (format === 'email' || isEmail(data)) {
        return `<a href="mailto:${escapeHtml(data)}" class="${moduleName}_link">${escapeHtml(data)}</a>`;
    }

    if (data.length > 100 || data.includes('\n')) {
        return renderLongText(data, moduleName);
    }

    return `<span>${escapeHtml(data)}</span>`;
}

function renderLongText(data: string, moduleName: string): string {
    const formatted = formatResponse(data, moduleName);
    return `<div class="${moduleName}_text">${formatted}</div>`;
}

function renderNumber(
    data: number,
    schema: JsonSchemaValue,
    moduleName: string,
    fieldName?: string,
): string {
    const label = String(schema.title || schema.description || fieldName || '').toLowerCase();

    if (looksLikeScore(label, data)) {
        return renderScore(data, moduleName);
    }

    const formatted = data.toLocaleString(undefined, { maximumFractionDigits: 2 });
    return `<span class="${moduleName}_num">${formatted}</span>`;
}

function renderScore(data: number, moduleName: string): string {
    const normalized = data > 10 ? data / 10 : data;
    const color = getScoreColor(normalized);
    const display = Number.isInteger(data) ? data : data.toFixed(1);
    const max = data > 10 ? 100 : 10;

    return `<span class="${moduleName}_score" style="color: ${color}">${display}<span class="${moduleName}_score_max">/${max}</span></span>`;
}

function renderBoolean(data: boolean, moduleName: string): string {
    const icon = data ? 'fa-check-circle' : 'fa-times-circle';
    const cls = data ? `${moduleName}_yes` : `${moduleName}_no`;
    return `<span class="${cls}"><i class="fa-solid ${icon}"></i> ${data ? 'Yes' : 'No'}</span>`;
}

function renderSimpleValue(data: unknown, moduleName: string): string {
    if (typeof data === 'boolean') {
        return renderBoolean(data, moduleName);
    }
    if (typeof data === 'number') {
        return `<span class="${moduleName}_num">${data.toLocaleString()}</span>`;
    }
    return escapeHtml(String(data));
}

function renderJson(data: unknown, moduleName: string): string {
    const { hljs } = SillyTavern.libs;
    const json = JSON.stringify(data, null, 2);
    const highlighted = hljs.highlight(json, { language: 'json' }).value;
    return `<pre class="${moduleName}_json"><code class="hljs">${highlighted}</code></pre>`;
}

// ============================================================================
// HELPERS
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}

function inferType(value: unknown): string {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    return typeof value;
}

function isSimpleValue(value: unknown): boolean {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null;
}

function formatLabel(key: string): string {
    return key
        .replace(/_/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/\b\w/g, c => c.toUpperCase());
}

function findHeroKey(data: Record<string, unknown>): string | null {
    const heroPatterns = ['overallscore', 'totalscore', 'overall', 'total', 'score', 'rating'];

    for (const pattern of heroPatterns) {
        for (const key of Object.keys(data)) {
            if (key.toLowerCase().replace(/_/g, '') === pattern && typeof data[key] === 'number') {
                return key;
            }
        }
    }

    return null;
}

function looksLikeScore(label: string, value: number): boolean {
    const scoreWords = ['score', 'rating', 'rank', 'grade', 'level', 'confidence', 'quality'];
    if (scoreWords.some(word => label.includes(word))) return true;
    if (value >= 0 && value <= 10 && Number.isFinite(value)) return true;
    if (value >= 0 && value <= 100 && Number.isInteger(value)) return true;
    return false;
}

function getScoreColor(score: number): string {
    if (score >= 8) return 'var(--success, #2ecc71)';
    if (score >= 5) return 'var(--warning, #f39c12)';
    return 'var(--failure, #e74c3c)';
}

function isUrl(str: string): boolean {
    return /^https?:\/\//i.test(str);
}

function isEmail(str: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str);
}
```

## FILE: src/ui/panel.ts
```ts
// src/ui/panel.ts
//
// Extension panel - minimal, just the launch button and settings access.

import { MODULE_NAME, EXTENSION_PATH } from '../constants';
import { getSettings, setDebugMode } from '../settings';
import { debugLog } from '../debug';
import { openMainPopup } from './popup';

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize the extension panel in ST's extensions settings
 */
export async function initPanel(): Promise<void> {
    const { renderExtensionTemplateAsync } = SillyTavern.getContext();

    const container = document.getElementById('extensions_settings');
    if (!container) {
        console.error(`[${MODULE_NAME}] Extensions container not found`);
        return;
    }

    try {
        const html = await renderExtensionTemplateAsync(EXTENSION_PATH, 'templates/panel', {}, true);

        const wrapper = document.createElement('div');
        wrapper.id = `${MODULE_NAME}_wrapper`;
        wrapper.innerHTML = html;
        container.appendChild(wrapper);

        initEventListeners();

        debugLog('info', 'Panel initialized', null);
    } catch (error) {
        console.error(`[${MODULE_NAME}] Failed to load panel template:`, error);
    }
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function initEventListeners(): void {
    // Open button
    const openBtn = document.getElementById(`${MODULE_NAME}_open_btn`);
    openBtn?.addEventListener('click', () => {
        openMainPopup();
    });

    // Debug toggle
    const debugToggle = document.getElementById(`${MODULE_NAME}_debug_toggle`) as HTMLInputElement;
    if (debugToggle) {
        debugToggle.checked = getSettings().debugMode;
        debugToggle.addEventListener('change', () => {
            setDebugMode(debugToggle.checked);
            toastr.info(`Debug mode ${debugToggle.checked ? 'enabled' : 'disabled'}`);
        });
    }
}

// ============================================================================
// REFRESH
// ============================================================================

/**
 * Refresh panel state (called when settings change externally)
 */
export function refreshPanel(): void {
    const debugToggle = document.getElementById(`${MODULE_NAME}_debug_toggle`) as HTMLInputElement;
    if (debugToggle) {
        debugToggle.checked = getSettings().debugMode;
    }
}
```

## FILE: src/ui/popup.ts
```ts
// src/ui/popup.ts
//
// Main popup controller - orchestrates all components and manages state.

import { MODULE_NAME, STAGES, STAGE_LABELS, STAGE_ICONS } from '../constants';
import { debugLog } from '../debug';
import {
    createPipelineState,
    resetPipeline,
    setCharacter,
    toggleStage,
    updateStageConfig as pipelineUpdateStageConfig,
    startStage,
    completeStage,
    failStage,
    lockStageResult,
    unlockStageResult,
    clearStageResult,
    getNextStage,
    canRunStage,
    canRefine,
    validatePipeline,
    validateRefinement,
    setExportData,
    buildStagePrompt,
    getStageSchema,
    startRefinement,
    completeRefinement,
    acceptRewrite,
    revertToIteration,
} from '../pipeline';
import { runStageGeneration, runRefinementGeneration, getStageTokenCount, getRefinementTokenCount, getApiInfo, isApiReady } from '../generator';
import { renderCharacterSelect, updateCharacterSelectState, renderDropdownItems, updateFieldTokenCounts } from './components/character-select';
import { getPopulatedFields } from '../character';
import { renderPipelineNav, updatePipelineNavState } from './components/pipeline-nav';
import {
    renderStageConfig,
    updateStageConfigState,
    handleSavePromptPreset,
    handleSaveSchemaPreset,
    handleValidateSchema,
    handleFixSchema,
    handleFormatSchema,
    handleGenerateSchema,
} from './components/stage-config';
import { renderResultsPanel, updateResultsPanelState, renderRefinementLoading } from './components/results-panel';
import { renderIterationHistory, updateIterationHistoryState, renderIterationViewContent } from './components/iteration-history';
import { openSettingsModal } from './settings-modal';
import type { PipelineState, StageName, Character, IterationSnapshot } from '../types';

// ============================================================================
// STATE
// ============================================================================

let popupState: {
    pipeline: PipelineState;
    isGenerating: boolean;
    isRefining: boolean;
    abortController: AbortController | null;
    activeStageView: StageName;
    characters: Character[];
} | null = null;

let popupElement: HTMLElement | null = null;

// ============================================================================
// EVENT MANAGEMENT
// ============================================================================

const eventCleanup: Array<() => void> = [];

function subscribeEvents(): void {
    const { eventSource, eventTypes } = SillyTavern.getContext();

    const handlers = {
        onStatusChange: () => {
            debugLog('info', 'API status changed', { isReady: isApiReady() });
            updateApiStatus();
        },

        onCharEdited: () => {
            debugLog('info', 'Character edited externally', null);
            refreshSelectedCharacter();
        },

        onCharDeleted: (data: { id: number; character: Character }) => {
            debugLog('info', 'Character deleted', { id: data.id });
            handleCharacterDeleted(data.id);
        },

        onPresetChanged: () => {
            debugLog('info', 'OAI preset changed', null);
            if (popupState) {
                updateTokenEstimate();
            }
        },

        onSourceChanged: () => {
            debugLog('info', 'Chat completion source changed', null);
            updateApiStatus();
            updateTokenEstimate();
        },

        onModelChanged: () => {
            debugLog('info', 'Chat completion model changed', null);
            updateApiStatus();
            updateTokenEstimate();
        },
    };

    eventSource.on(eventTypes.ONLINE_STATUS_CHANGED, handlers.onStatusChange);
    eventSource.on(eventTypes.CHARACTER_EDITED, handlers.onCharEdited);
    eventSource.on(eventTypes.CHARACTER_DELETED, handlers.onCharDeleted);
    eventSource.on(eventTypes.OAI_PRESET_CHANGED_AFTER, handlers.onPresetChanged);
    eventSource.on(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, handlers.onSourceChanged);
    eventSource.on(eventTypes.CHATCOMPLETION_MODEL_CHANGED, handlers.onModelChanged);

    eventCleanup.push(
        () => eventSource.removeListener(eventTypes.ONLINE_STATUS_CHANGED, handlers.onStatusChange),
        () => eventSource.removeListener(eventTypes.CHARACTER_EDITED, handlers.onCharEdited),
        () => eventSource.removeListener(eventTypes.CHARACTER_DELETED, handlers.onCharDeleted),
        () => eventSource.removeListener(eventTypes.OAI_PRESET_CHANGED_AFTER, handlers.onPresetChanged),
        () => eventSource.removeListener(eventTypes.CHATCOMPLETION_SOURCE_CHANGED, handlers.onSourceChanged),
        () => eventSource.removeListener(eventTypes.CHATCOMPLETION_MODEL_CHANGED, handlers.onModelChanged),
    );

    debugLog('info', 'Event listeners subscribed', { count: eventCleanup.length });
}

function unsubscribeEvents(): void {
    eventCleanup.forEach(fn => fn());
    eventCleanup.length = 0;
    debugLog('info', 'Event listeners unsubscribed', null);
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

function updateApiStatus(): void {
    if (!popupElement) return;

    const apiInfo = getApiInfo();
    const statusEl = popupElement.querySelector(`.${MODULE_NAME}_api_status`);

    if (statusEl) {
        statusEl.className = `${MODULE_NAME}_api_status ${apiInfo.isReady ? 'connected' : 'disconnected'}`;
        const textSpan = statusEl.querySelector('span');
        if (textSpan) {
            textSpan.textContent = apiInfo.source;
        }
    }

    updatePipelineNav();
}

function refreshSelectedCharacter(): void {
    if (!popupState || popupState.pipeline.characterIndex === null) return;

    const { characters } = SillyTavern.getContext();
    const charList = characters as Character[];
    const index = popupState.pipeline.characterIndex;

    popupState.characters = charList;

    if (index >= 0 && index < charList.length) {
        const updatedChar = charList[index];

        if (updatedChar.name === popupState.pipeline.character?.name) {
            popupState.pipeline = {
                ...popupState.pipeline,
                character: updatedChar,
            };
            updateCharacterSelect();
            updateTokenEstimate();
            debugLog('info', 'Character refreshed', { name: updatedChar.name });
        } else {
            handleCharacterInvalidated();
        }
    } else {
        handleCharacterInvalidated();
    }
}

function handleCharacterDeleted(deletedId: number): void {
    if (!popupState) return;

    const currentIndex = popupState.pipeline.characterIndex;

    if (currentIndex === null) return;

    if (currentIndex === deletedId) {
        handleCharacterInvalidated();
        toastr.warning('Selected character was deleted');
    } else if (currentIndex > deletedId) {
        const newIndex = currentIndex - 1;
        const { characters } = SillyTavern.getContext();
        const charList = characters as Character[];

        if (newIndex >= 0 && newIndex < charList.length) {
            popupState.pipeline = {
                ...popupState.pipeline,
                characterIndex: newIndex,
                character: charList[newIndex],
            };
            popupState.characters = charList;
            debugLog('info', 'Character index adjusted after deletion', { oldIndex: currentIndex, newIndex });
        } else {
            handleCharacterInvalidated();
        }
    }
}

function handleCharacterInvalidated(): void {
    if (!popupState) return;

    debugLog('info', 'Character invalidated, clearing selection', null);

    popupState.pipeline = setCharacter(popupState.pipeline, null, null);
    updateAllComponents();
    toastr.info('Character selection cleared');
}

// ============================================================================
// GLOBAL LISTENERS
// ============================================================================

let documentClickHandler: ((e: MouseEvent) => void) | null = null;
let keyboardHandler: ((e: KeyboardEvent) => void) | null = null;

function initGlobalListeners(): void {
    keyboardHandler = (e: KeyboardEvent) => {
        if (!popupState) return;

        // Ctrl+Enter to run current stage
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            if (!popupState.isGenerating && !popupState.isRefining) {
                runSingleStage(popupState.activeStageView);
            }
        }

        // Escape to cancel generation
        if (e.key === 'Escape' && (popupState.isGenerating || popupState.isRefining) && popupState.abortController) {
            popupState.abortController.abort();
        }
    };

    document.addEventListener('keydown', keyboardHandler);
}

function removeGlobalListeners(): void {
    if (keyboardHandler) {
        document.removeEventListener('keydown', keyboardHandler);
        keyboardHandler = null;
    }
    if (documentClickHandler) {
        document.removeEventListener('click', documentClickHandler);
        documentClickHandler = null;
    }
}

// ============================================================================
// MAIN ENTRY
// ============================================================================

export async function openMainPopup(): Promise<void> {
    const { Popup, POPUP_TYPE, characters } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const charList = characters as Character[];

    popupState = {
        pipeline: createPipelineState(),
        isGenerating: false,
        isRefining: false,
        abortController: null,
        activeStageView: 'score',
        characters: charList,
    };

    const content = buildPopupContent();

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: false,
        cancelButton: false,
    });

    popup.show().then(() => {
        if (popupState?.abortController) {
            popupState.abortController.abort();
        }
        popupState = null;
        popupElement = null;
        unsubscribeEvents();
        removeGlobalListeners();
        debugLog('info', 'Popup closed', null);
    });

    await new Promise<void>(resolve => setTimeout(resolve, 0));

    popupElement = document.getElementById(`${MODULE_NAME}_popup`);

    subscribeEvents();
    initGlobalListeners();
    initComponents(charList);
    updateAllComponents();

    debugLog('info', 'Popup opened', { characterCount: charList.length });
}

// ============================================================================
// POPUP HTML
// ============================================================================

function buildPopupContent(): string {
    const apiInfo = getApiInfo();

    return `
    <div class="${MODULE_NAME}_popup" id="${MODULE_NAME}_popup">
      <!-- Header -->
      <div class="${MODULE_NAME}_popup_header">
        <div class="${MODULE_NAME}_popup_title">
          <i class="fa-solid fa-wand-magic-sparkles"></i>
          <span>Character Tools</span>
        </div>
        <div class="${MODULE_NAME}_popup_header_right">
          <div class="${MODULE_NAME}_api_status ${apiInfo.isReady ? 'connected' : 'disconnected'}">
            <i class="fa-solid fa-circle"></i>
            <span>${apiInfo.source}</span>
          </div>
          <button id="${MODULE_NAME}_settings_btn" class="${MODULE_NAME}_icon_btn" title="Settings">
            <i class="fa-solid fa-gear"></i>
          </button>
          <button id="${MODULE_NAME}_close_btn" class="${MODULE_NAME}_icon_btn" title="Close">
            <i class="fa-solid fa-xmark"></i>
          </button>
        </div>
      </div>

      <!-- Character Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_character_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-user"></i>
          <span>Character</span>
        </div>
        <div id="${MODULE_NAME}_character_select_container"></div>
      </div>

      <!-- Pipeline Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_pipeline_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-diagram-project"></i>
          <span>Pipeline</span>
        </div>
        <div id="${MODULE_NAME}_pipeline_nav_container"></div>
      </div>

      <!-- Stage Config Section -->
      <div class="${MODULE_NAME}_section" id="${MODULE_NAME}_stage_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid ${STAGE_ICONS.score}" id="${MODULE_NAME}_stage_icon"></i>
          <span id="${MODULE_NAME}_stage_title">Score</span>
        </div>
        <div id="${MODULE_NAME}_stage_config_container"></div>
      </div>

      <!-- Results Section -->
      <div class="${MODULE_NAME}_section ${MODULE_NAME}_section_grow" id="${MODULE_NAME}_results_section">
        <div class="${MODULE_NAME}_section_header">
          <i class="fa-solid fa-file-lines"></i>
          <span>Results</span>
          <span id="${MODULE_NAME}_iteration_indicator" class="${MODULE_NAME}_iteration_indicator hidden"></span>
        </div>
        <div id="${MODULE_NAME}_results_container"></div>
        <div id="${MODULE_NAME}_iteration_history_container"></div>
      </div>
    </div>
  `;
}

// ============================================================================
// COMPONENT INITIALIZATION
// ============================================================================

function initComponents(characters: Character[]): void {
    if (!popupState || !popupElement) return;

    // Character select
    const charContainer = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (charContainer) {
        charContainer.innerHTML = renderCharacterSelect(characters, popupState.pipeline.characterIndex);
        initCharacterSelectListeners(characters);
    }

    // Pipeline nav
    const pipelineContainer = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (pipelineContainer) {
        pipelineContainer.innerHTML = renderPipelineNav(
            popupState.pipeline.selectedStages,
            popupState.pipeline.stageStatus,
            popupState.activeStageView,
            !!popupState.pipeline.character,
        );
        initPipelineNavListeners();
    }

    // Stage config
    const stageContainer = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (stageContainer) {
        stageContainer.innerHTML = renderStageConfig(
            popupState.activeStageView,
            popupState.pipeline.configs[popupState.activeStageView],
            null,
        );
        initStageConfigListeners();
    }

    // Results panel
    const resultsContainer = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (resultsContainer) {
        resultsContainer.innerHTML = renderResultsPanel(
            popupState.activeStageView,
            popupState.pipeline.results[popupState.activeStageView],
            popupState.pipeline.stageStatus[popupState.activeStageView],
            popupState.isGenerating,
        );
        initResultsPanelListeners();
    }

    // Iteration history
    const historyContainer = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (historyContainer) {
        historyContainer.innerHTML = renderIterationHistory(
            popupState.pipeline.iterationHistory,
            popupState.pipeline.iterationCount,
            handleRevertToIteration,
        );
        initIterationHistoryListeners();
    }

    // Header buttons
    popupElement.querySelector(`#${MODULE_NAME}_settings_btn`)?.addEventListener('click', () => {
        openSettingsModal(() => {
            updateAllComponents();
        });
    });

    popupElement.querySelector(`#${MODULE_NAME}_close_btn`)?.addEventListener('click', () => {
        const dialog = popupElement?.closest('.popup');
        if (dialog) {
            const cancelBtn = dialog.querySelector('.popup-button-cancel, .popup-button-ok') as HTMLElement;
            cancelBtn?.click();
        }
    });
}

// ============================================================================
// CHARACTER SELECT LISTENERS
// ============================================================================

function initCharacterSelectListeners(characters: Character[]): void {
    if (!popupElement) return;

    const { Fuse, lodash } = SillyTavern.libs;

    const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (!container) return;

    const searchInput = container.querySelector(`#${MODULE_NAME}_char_search`) as HTMLInputElement;
    const dropdown = container.querySelector(`#${MODULE_NAME}_char_dropdown`) as HTMLElement;

    if (!searchInput || !dropdown) return;

    let selectedIndex = -1;
    let currentResults: Array<{ char: Character; index: number }> = [];

    const handleSearch = () => {
        const currentChars = popupState?.characters || characters;
        const currentCharData = currentChars
            .map((char, index) => ({ char, index }))
            .filter(({ char }) => char?.name);

        const fuse = new Fuse(currentCharData, {
            keys: ['char.name', 'char.description'],
            threshold: 0.4,
            includeScore: true,
            minMatchCharLength: 1,
        });

        const query = searchInput.value.trim();

        if (!query) {
            dropdown.classList.add('hidden');
            currentResults = [];
            return;
        }

        const results = fuse.search(query, { limit: 10 });
        currentResults = results.map((r: { item: { char: Character; index: number } }) => r.item);

        if (currentResults.length === 0) {
            dropdown.innerHTML = `<div class="${MODULE_NAME}_dropdown_empty">No characters found</div>`;
            dropdown.classList.remove('hidden');
            return;
        }

        selectedIndex = -1;
        renderDropdownItems(currentResults, dropdown, -1);
        dropdown.classList.remove('hidden');
    };

    const debouncedSearch = lodash.debounce(handleSearch, 150);
    searchInput.addEventListener('input', debouncedSearch);

    searchInput.addEventListener('keydown', (e) => {
        if (currentResults.length === 0) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
            renderDropdownItems(currentResults, dropdown, selectedIndex);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, 0);
            renderDropdownItems(currentResults, dropdown, selectedIndex);
        } else if (e.key === 'Enter' && selectedIndex >= 0) {
            e.preventDefault();
            selectCharacter(currentResults[selectedIndex].char, currentResults[selectedIndex].index);
            dropdown.classList.add('hidden');
            searchInput.value = '';
        } else if (e.key === 'Escape') {
            dropdown.classList.add('hidden');
            searchInput.value = '';
        }
    });

    documentClickHandler = (e: MouseEvent) => {
        if (!searchInput.contains(e.target as Node) && !dropdown.contains(e.target as Node)) {
            dropdown.classList.add('hidden');
        }
    };
    document.addEventListener('click', documentClickHandler);

    dropdown.addEventListener('click', (e) => {
        const item = (e.target as HTMLElement).closest(`.${MODULE_NAME}_dropdown_item`);
        if (item) {
            const index = parseInt(item.getAttribute('data-index') || '-1', 10);
            const charItem = currentResults.find(c => c.index === index);
            if (charItem) {
                selectCharacter(charItem.char, charItem.index);
                dropdown.classList.add('hidden');
                searchInput.value = '';
            }
        }
    });

    container.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;

        if (target.closest(`#${MODULE_NAME}_char_clear`)) {
            if (!popupState) return;
            popupState.pipeline = setCharacter(popupState.pipeline, null, null);
            updateAllComponents();
            return;
        }

        const toggle = target.closest(`.${MODULE_NAME}_field_toggle`);
        if (toggle) {
            const fieldKey = toggle.getAttribute('data-field');
            const content = container.querySelector(`#${MODULE_NAME}_field_content_${fieldKey}`);
            const icon = toggle.querySelector('i');

            if (content && icon) {
                content.classList.toggle('hidden');
                icon.classList.toggle('fa-chevron-right');
                icon.classList.toggle('fa-chevron-down');
            }
        }
    });
}

function selectCharacter(char: Character, index: number): void {
    if (!popupState) return;

    popupState.pipeline = setCharacter(popupState.pipeline, char, index);
    updateAllComponents();

    setTimeout(async () => {
        if (!popupElement || !popupState?.pipeline.character) return;

        const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
        if (container) {
            const fields = getPopulatedFields(popupState.pipeline.character);
            await updateFieldTokenCounts(container as HTMLElement, fields);
        }
    }, 50);

    debugLog('info', 'Character selected', { name: char.name, index });
}

// ============================================================================
// PIPELINE NAV LISTENERS
// ============================================================================

function initPipelineNavListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (!container) return;

    container.addEventListener('change', (e) => {
        const checkbox = e.target as HTMLInputElement;
        if (checkbox.classList.contains(`${MODULE_NAME}_stage_checkbox`)) {
            const stage = checkbox.getAttribute('data-stage') as StageName;
            if (stage && popupState) {
                popupState.pipeline = toggleStage(popupState.pipeline, stage);
                updatePipelineNav();
            }
        }
    });

    container.addEventListener('click', (e) => {
        const btn = (e.target as HTMLElement).closest(`.${MODULE_NAME}_stage_btn`);
        if (btn && popupState) {
            const stage = btn.getAttribute('data-stage') as StageName;
            if (stage) {
                popupState.activeStageView = stage;
                updateStageSection();
                updateResultsPanel();
                updateTokenEstimate();
                updatePipelineNav();
            }
        }

        const runBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_run_selected_btn`);
        if (runBtn) {
            runSelectedStages();
        }

        const runAllBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_run_all_btn`);
        if (runAllBtn) {
            runAllStages();
        }

        const resetBtn = (e.target as HTMLElement).closest(`#${MODULE_NAME}_reset_pipeline_btn`);
        if (resetBtn && popupState) {
            popupState.pipeline = resetPipeline(popupState.pipeline, true);
            updateAllComponents();
        }
    });
}

// ============================================================================
// STAGE CONFIG LISTENERS
// ============================================================================

function initStageConfigListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (!container) return;

    container.addEventListener('change', (e) => {
        const select = e.target as HTMLSelectElement;

        if (select.id === `${MODULE_NAME}_prompt_preset_select` && popupState) {
            const value = select.value || null;
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                promptPresetId: value,
            });
            updateStageConfigUI();
            updateTokenEstimate();
        }

        if (select.id === `${MODULE_NAME}_schema_preset_select` && popupState) {
            const value = select.value || null;
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                schemaPresetId: value,
            });
            updateStageConfigUI();
        }
    });

    const { lodash } = SillyTavern.libs;
    container.addEventListener('input', lodash.debounce((e: Event) => {
        const textarea = e.target as HTMLTextAreaElement;

        if (textarea.id === `${MODULE_NAME}_custom_prompt` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                customPrompt: textarea.value,
                promptPresetId: null,
            });
            updateTokenEstimate();
            updateStageConfigUI();
        }

        if (textarea.id === `${MODULE_NAME}_custom_schema` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                customSchema: textarea.value,
                schemaPresetId: null,
            });
            updateStageConfigUI();
        }
    }, 300));

    container.addEventListener('change', (e) => {
        const checkbox = e.target as HTMLInputElement;
        if (checkbox.id === `${MODULE_NAME}_use_structured` && popupState) {
            popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                useStructuredOutput: checkbox.checked,
            });
            updateStageConfigUI();
        }
    });

    container.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;

        const runBtn = target.closest(`#${MODULE_NAME}_run_stage_btn`);
        if (runBtn && popupState) {
            runSingleStage(popupState.activeStageView);
            return;
        }

        const savePromptBtn = target.closest(`#${MODULE_NAME}_save_prompt_preset_btn`);
        if (savePromptBtn && popupState) {
            const promptTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
            if (promptTextarea) {
                const result = await handleSavePromptPreset(popupState.activeStageView, promptTextarea.value);
                if (result.success && result.presetId) {
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        promptPresetId: result.presetId,
                        customPrompt: '',
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const saveSchemaBtn = target.closest(`#${MODULE_NAME}_save_schema_preset_btn`);
        if (saveSchemaBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const result = await handleSaveSchemaPreset(popupState.activeStageView, schemaTextarea.value);
                if (result.success && result.presetId) {
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        schemaPresetId: result.presetId,
                        customSchema: '',
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const generateBtn = target.closest(`#${MODULE_NAME}_generate_schema_btn`);
        if (generateBtn && popupState) {
            const generated = await handleGenerateSchema();
            if (generated) {
                const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
                if (schemaTextarea) {
                    schemaTextarea.value = generated;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: generated,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const validateBtn = target.closest(`#${MODULE_NAME}_validate_schema_btn`);
        if (validateBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                handleValidateSchema(schemaTextarea.value);
            }
            return;
        }

        const fixBtn = target.closest(`#${MODULE_NAME}_fix_schema_btn`);
        if (fixBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const fixed = handleFixSchema(schemaTextarea.value);
                if (fixed) {
                    schemaTextarea.value = fixed;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: fixed,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }

        const formatBtn = target.closest(`#${MODULE_NAME}_format_schema_btn`);
        if (formatBtn && popupState) {
            const schemaTextarea = popupElement?.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
            if (schemaTextarea) {
                const formatted = handleFormatSchema(schemaTextarea.value);
                if (formatted) {
                    schemaTextarea.value = formatted;
                    popupState.pipeline = pipelineUpdateStageConfig(popupState.pipeline, popupState.activeStageView, {
                        customSchema: formatted,
                        schemaPresetId: null,
                    });
                    updateStageConfigUI();
                }
            }
            return;
        }
    });
}

// ============================================================================
// RESULTS PANEL LISTENERS
// ============================================================================

function initResultsPanelListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (!container) return;

    container.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;

        // Regenerate
        if (target.closest(`#${MODULE_NAME}_regenerate_btn`) && popupState) {
            popupState.pipeline = clearStageResult(popupState.pipeline, popupState.activeStageView);
            runSingleStage(popupState.activeStageView);
        }

        // Lock/Unlock
        if (target.closest(`#${MODULE_NAME}_lock_btn`) && popupState) {
            popupState.pipeline = lockStageResult(popupState.pipeline, popupState.activeStageView);
            updateResultsPanel();
        }

        if (target.closest(`#${MODULE_NAME}_unlock_btn`) && popupState) {
            popupState.pipeline = unlockStageResult(popupState.pipeline, popupState.activeStageView);
            updateResultsPanel();
        }

        // Continue to next stage
        if (target.closest(`#${MODULE_NAME}_continue_btn`) && popupState) {
            const nextStage = getNextStage(popupState.pipeline, popupState.activeStageView);
            if (nextStage) {
                popupState.activeStageView = nextStage;
                updateStageSection();
                updateResultsPanel();
                updateTokenEstimate();
            }
        }

        // Refine
        if (target.closest(`#${MODULE_NAME}_refine_btn`) && popupState) {
            runRefinement();
        }

        // Accept rewrite
        if (target.closest(`#${MODULE_NAME}_accept_btn`) && popupState) {
            popupState.pipeline = acceptRewrite(popupState.pipeline);
            toastr.success('Rewrite accepted as final');
            updateAllComponents();
        }

        // Copy
        if (target.closest(`#${MODULE_NAME}_copy_btn`) && popupState) {
            const result = popupState.pipeline.results[popupState.activeStageView];
            if (result) {
                navigator.clipboard.writeText(result.response);
                toastr.success('Copied to clipboard');
            }
        }

        // Export
        if (target.closest(`#${MODULE_NAME}_export_btn`) && popupState) {
            popupState.pipeline = setExportData(popupState.pipeline);
            if (popupState.pipeline.exportData) {
                navigator.clipboard.writeText(popupState.pipeline.exportData);
                toastr.success('Export copied to clipboard');
            }
        }

        // Cancel generation
        if (target.closest(`#${MODULE_NAME}_cancel_btn`) && popupState?.abortController) {
            popupState.abortController.abort();
        }
    });
}

// ============================================================================
// ITERATION HISTORY LISTENERS
// ============================================================================

function initIterationHistoryListeners(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (!container) return;

    container.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;

        // Revert button
        const revertBtn = target.closest(`.${MODULE_NAME}_iteration_revert_btn`);
        if (revertBtn && popupState) {
            const index = parseInt(revertBtn.getAttribute('data-index') || '-1', 10);
            if (index >= 0) {
                await handleRevertToIteration(index);
            }
        }

        // View button
        const viewBtn = target.closest(`.${MODULE_NAME}_iteration_view_btn`);
        if (viewBtn && popupState) {
            const index = parseInt(viewBtn.getAttribute('data-index') || '-1', 10);
            if (index >= 0 && index < popupState.pipeline.iterationHistory.length) {
                showIterationView(popupState.pipeline.iterationHistory[index]);
            }
        }
    });
}

async function handleRevertToIteration(index: number): Promise<void> {
    if (!popupState) return;

    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    const confirmed = await Popup.show.confirm(
        'Revert to Previous Iteration?',
        `This will restore the rewrite from iteration #${index + 1} and discard later changes.`,
    );

    if (confirmed !== POPUP_RESULT.AFFIRMATIVE) return;

    popupState.pipeline = revertToIteration(popupState.pipeline, index);
    toastr.info(`Reverted to iteration #${index + 1}`);
    updateAllComponents();
}

async function showIterationView(snap: IterationSnapshot): Promise<void> {
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const content = renderIterationViewContent(snap);

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: 'Close',
        cancelButton: false,
    });

    await popup.show();
}

// ============================================================================
// GENERATION
// ============================================================================

async function runSingleStage(stage: StageName): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const canRun = canRunStage(popupState.pipeline, stage);
    if (!canRun.canRun) {
        toastr.warning(canRun.reason || 'Cannot run this stage');
        return;
    }

    if (canRun.reason) {
        toastr.info(canRun.reason);
    }

    popupState.isGenerating = true;
    popupState.abortController = new AbortController();
    popupState.pipeline = startStage(popupState.pipeline, stage);
    updateAllComponents();

    const promptUsed = buildStagePrompt(popupState.pipeline, stage) || '';
    const schemaUsed = getStageSchema(popupState.pipeline, stage);

    try {
        const result = await runStageGeneration(
            popupState.pipeline,
            stage,
            popupState.abortController.signal,
        );

        if (result.success) {
            popupState.pipeline = completeStage(popupState.pipeline, stage, {
                response: result.response,
                isStructured: result.isStructured,
                promptUsed,
                schemaUsed,
            });
            toastr.success(`${STAGE_LABELS[stage]} complete`);
        } else {
            popupState.pipeline = failStage(popupState.pipeline, stage, result.error);
            if (result.error !== 'Generation cancelled') {
                toastr.error(result.error);
            }
        }
    } catch (e) {
        popupState.pipeline = failStage(popupState.pipeline, stage, (e as Error).message);
        toastr.error((e as Error).message);
    } finally {
        popupState.isGenerating = false;
        popupState.abortController = null;
        updateAllComponents();
    }
}

async function runSelectedStages(): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const validation = validatePipeline(popupState.pipeline);
    if (!validation.valid) {
        toastr.error(validation.errors.join('\n'));
        return;
    }

    if (validation.warnings.length > 0) {
        toastr.warning(validation.warnings.join('\n'));
    }

    for (const stage of popupState.pipeline.selectedStages) {
        const status = popupState.pipeline.stageStatus[stage];
        if (status === 'complete' || status === 'skipped') {
            continue;
        }

        popupState.activeStageView = stage;
        updateStageSection();

        await runSingleStage(stage);

        if (!popupState) break;

        const newStatus = popupState.pipeline.stageStatus[stage];
        if (newStatus !== 'complete') {
            break;
        }
    }
}

async function runAllStages(): Promise<void> {
    if (!popupState) return;

    popupState.pipeline.selectedStages = [...STAGES];
    updatePipelineNav();

    await runSelectedStages();
}

async function runRefinement(): Promise<void> {
    if (!popupState || popupState.isGenerating || popupState.isRefining) return;

    if (!isApiReady()) {
        toastr.error('API is not connected');
        return;
    }

    const canRefineResult = canRefine(popupState.pipeline);
    if (!canRefineResult.canRun) {
        toastr.warning(canRefineResult.reason || 'Cannot refine');
        return;
    }

    const validation = validateRefinement(popupState.pipeline);
    if (!validation.valid) {
        toastr.error(validation.errors.join('\n'));
        return;
    }

    if (validation.warnings.length > 0) {
        toastr.warning(validation.warnings.join('\n'));
    }

    // Start refinement - this snapshots current state
    popupState.pipeline = startRefinement(popupState.pipeline);
    popupState.isRefining = true;
    popupState.abortController = new AbortController();

    // Show refinement loading state
    const resultsContainer = popupElement?.querySelector(`#${MODULE_NAME}_results_container`);
    if (resultsContainer) {
        resultsContainer.innerHTML = renderRefinementLoading(popupState.pipeline.iterationCount);
    }

    updateIterationIndicator();
    updateIterationHistory();

    try {
        const result = await runRefinementGeneration(
            popupState.pipeline,
            popupState.abortController.signal,
        );

        if (result.success) {
            popupState.pipeline = completeRefinement(popupState.pipeline, {
                response: result.response,
                isStructured: false,
                promptUsed: '[Refinement prompt]',
                schemaUsed: null,
            });

            toastr.success(`Refinement #${popupState.pipeline.iterationCount} complete`);

            // Switch to analyze view so user can review
            popupState.activeStageView = 'analyze';
        } else {
            if (result.error !== 'Generation cancelled') {
                toastr.error(result.error);
            }
        }
    } catch (e) {
        toastr.error((e as Error).message);
    } finally {
        popupState.isRefining = false;
        popupState.abortController = null;
        updateAllComponents();
    }
}

// ============================================================================
// UPDATE FUNCTIONS
// ============================================================================

function updateAllComponents(): void {
    updateCharacterSelect();
    updatePipelineNav();
    updateStageSection();
    updateResultsPanel();
    updateTokenEstimate();
    updateIterationIndicator();
    updateIterationHistory();
}

function updateCharacterSelect(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_character_select_container`);
    if (container) {
        updateCharacterSelectState(
            container as HTMLElement,
            popupState.pipeline.character,
            popupState.pipeline.characterIndex,
        );
    }
}

function updatePipelineNav(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_pipeline_nav_container`);
    if (container) {
        updatePipelineNavState(
            container as HTMLElement,
            popupState.pipeline.selectedStages,
            popupState.pipeline.stageStatus,
            popupState.activeStageView,
            !!popupState.pipeline.character && isApiReady(),
            popupState.isGenerating || popupState.isRefining,
        );
    }
}

function updateStageSection(): void {
    if (!popupElement || !popupState) return;

    const icon = popupElement.querySelector(`#${MODULE_NAME}_stage_icon`);
    const title = popupElement.querySelector(`#${MODULE_NAME}_stage_title`);

    if (icon) {
        icon.className = `fa-solid ${STAGE_ICONS[popupState.activeStageView]}`;
    }
    if (title) {
        title.textContent = STAGE_LABELS[popupState.activeStageView];
    }

    updateStageConfigUI();
}

function updateStageConfigUI(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_stage_config_container`);
    if (container) {
        updateStageConfigState(
            container as HTMLElement,
            popupState.activeStageView,
            popupState.pipeline.configs[popupState.activeStageView],
            popupState.isGenerating || popupState.isRefining,
        );
    }
}

function updateResultsPanel(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_results_container`);
    if (container) {
        updateResultsPanelState(
            container as HTMLElement,
            popupState.activeStageView,
            popupState.pipeline.results[popupState.activeStageView],
            popupState.pipeline.stageStatus[popupState.activeStageView],
            popupState.isGenerating,
            getNextStage(popupState.pipeline, popupState.activeStageView),
            popupState.pipeline,
        );
    }
}

function updateIterationIndicator(): void {
    if (!popupElement || !popupState) return;

    const indicator = popupElement.querySelector(`#${MODULE_NAME}_iteration_indicator`);
    if (!indicator) return;

    if (popupState.pipeline.iterationCount > 0 || popupState.pipeline.isRefining) {
        indicator.classList.remove('hidden');
        indicator.innerHTML = `
      <i class="fa-solid fa-arrows-rotate"></i>
      Iteration #${popupState.pipeline.iterationCount + 1}
    `;
    } else {
        indicator.classList.add('hidden');
    }
}

function updateIterationHistory(): void {
    if (!popupElement || !popupState) return;

    const container = popupElement.querySelector(`#${MODULE_NAME}_iteration_history_container`);
    if (container) {
        updateIterationHistoryState(
            container as HTMLElement,
            popupState.pipeline.iterationHistory,
            popupState.pipeline.iterationCount,
        );
    }
}

async function updateTokenEstimate(): Promise<void> {
    if (!popupElement || !popupState) return;

    const tokenEl = popupElement.querySelector(`#${MODULE_NAME}_token_estimate`);
    if (!tokenEl) return;

    if (!popupState.pipeline.character) {
        tokenEl.innerHTML = '<i class="fa-solid fa-microchip"></i> Select a character';
        tokenEl.className = `${MODULE_NAME}_token_estimate`;
        return;
    }

    tokenEl.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
    tokenEl.className = `${MODULE_NAME}_token_estimate`;

    // Use refinement token count if we're in refinement mode
    let counts;
    if (popupState.pipeline.isRefining && popupState.pipeline.results.rewrite && popupState.pipeline.results.analyze) {
        counts = await getRefinementTokenCount(popupState.pipeline);
    } else {
        counts = await getStageTokenCount(popupState.pipeline, popupState.activeStageView);
    }

    if (!popupState || !popupElement) return;

    if (!counts) {
        tokenEl.innerHTML = '<i class="fa-solid fa-microchip"></i> --';
        tokenEl.className = `${MODULE_NAME}_token_estimate`;
        return;
    }

    let colorClass = '';
    if (counts.percentage > 100) colorClass = 'danger';
    else if (counts.percentage > 80) colorClass = 'warning';

    tokenEl.innerHTML = `<i class="fa-solid fa-microchip"></i> ${counts.promptTokens.toLocaleString()}t (${counts.percentage}%)`;
    tokenEl.className = `${MODULE_NAME}_token_estimate ${colorClass}`;
}
```

## FILE: src/ui/settings-modal.ts
```ts
// src/ui/settings-modal.ts
//
// Settings modal popup

import { MODULE_NAME, DEFAULT_SYSTEM_PROMPT, DEFAULT_REFINEMENT_PROMPT } from '../constants';
import {
    getSettings,
    updateSetting,
    updateGenerationConfig,
    updateSystemPrompt,
    resetSystemPrompt,
    updateRefinementPrompt,
    resetRefinementPrompt,
    setDebugMode,
    getPromptPresets,
    getSchemaPresets,
    deletePromptPreset,
    deleteSchemaPreset,
    exportCustomPresets,
    importPresets,
} from '../settings';
import { debugLog, getDebugLogs, clearDebugLogs, formatLogEntry, formatLogData, exportDebugInfo } from '../debug';
import type { GenerationConfig } from '../types';

// ============================================================================
// MAIN ENTRY
// ============================================================================

/**
 * Open the settings modal
 */
export async function openSettingsModal(onClose?: () => void): Promise<void> {
    const { Popup, POPUP_TYPE } = SillyTavern.getContext();
    const { DOMPurify } = SillyTavern.libs;

    const content = buildSettingsContent();

    const popup = new Popup(DOMPurify.sanitize(content), POPUP_TYPE.TEXT, '', {
        wide: true,
        large: true,
        allowVerticalScrolling: true,
        okButton: 'Save & Close',
        cancelButton: false,
    });

    popup.show().then(() => {
        onClose?.();
        debugLog('info', 'Settings modal closed', null);
    });

    // Wait for DOM
    await new Promise<void>(resolve => setTimeout(resolve, 0));

    initSettingsListeners();
    refreshModelSelects();

    debugLog('info', 'Settings modal opened', null);
}

// ============================================================================
// BUILD CONTENT
// ============================================================================

function buildSettingsContent(): string {
    const settings = getSettings();
    const config = settings.generationConfig;

    return `
    <div class="${MODULE_NAME}_settings_modal" id="${MODULE_NAME}_settings_modal">
      <div class="${MODULE_NAME}_settings_header">
        <i class="fa-solid fa-gear"></i>
        <span>Character Tools Settings</span>
      </div>

      <!-- Generation Settings -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-microchip"></i>
          <span>Generation</span>
        </div>

        <div class="${MODULE_NAME}_settings_row">
          <label class="${MODULE_NAME}_checkbox_label">
            <input
              type="checkbox"
              id="${MODULE_NAME}_use_current_settings"
              ${settings.useCurrentSettings ? 'checked' : ''}
            >
            <span>Use Current SillyTavern Settings</span>
          </label>
        </div>

        <div id="${MODULE_NAME}_custom_gen_config" class="${settings.useCurrentSettings ? 'hidden' : ''}">
          <div class="${MODULE_NAME}_settings_grid">
            <div class="${MODULE_NAME}_settings_field">
              <label>Source</label>
              <select id="${MODULE_NAME}_gen_source" class="text_pole"></select>
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Model</label>
              <select id="${MODULE_NAME}_gen_model" class="text_pole"></select>
            </div>
          </div>

          <div class="${MODULE_NAME}_settings_grid ${MODULE_NAME}_settings_grid_5">
            <div class="${MODULE_NAME}_settings_field">
              <label>Temp</label>
              <input type="number" id="${MODULE_NAME}_gen_temp" class="text_pole" value="${config.temperature}" min="0" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Max Tokens</label>
              <input type="number" id="${MODULE_NAME}_gen_tokens" class="text_pole" value="${config.maxTokens}" min="100" max="32000" step="100">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Freq Pen</label>
              <input type="number" id="${MODULE_NAME}_gen_freq" class="text_pole" value="${config.frequencyPenalty}" min="-2" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Pres Pen</label>
              <input type="number" id="${MODULE_NAME}_gen_pres" class="text_pole" value="${config.presencePenalty}" min="-2" max="2" step="0.1">
            </div>
            <div class="${MODULE_NAME}_settings_field">
              <label>Top P</label>
              <input type="number" id="${MODULE_NAME}_gen_top_p" class="text_pole" value="${config.topP}" min="0" max="1" step="0.05">
            </div>
          </div>
        </div>
      </div>

      <!-- System Prompt -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-message"></i>
          <span>System Prompt</span>
        </div>

        <p class="${MODULE_NAME}_settings_hint">Base instructions applied to all stages</p>

        <textarea
          id="${MODULE_NAME}_system_prompt"
          class="text_pole ${MODULE_NAME}_system_prompt_textarea"
          rows="6"
        >${escapeHtml(settings.systemPrompt)}</textarea>

        <div class="${MODULE_NAME}_settings_row_spread">
          <span id="${MODULE_NAME}_system_prompt_chars">${settings.systemPrompt.length.toLocaleString()} chars</span>
          <button id="${MODULE_NAME}_reset_system_prompt" class="menu_button">
            <i class="fa-solid fa-rotate-left"></i>
            Reset
          </button>
        </div>
      </div>

      <!-- Refinement Prompt -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-arrows-rotate"></i>
          <span>Refinement Prompt</span>
        </div>

        <p class="${MODULE_NAME}_settings_hint">Template for iterative refinement. Placeholders: {{original_character}}, {{current_rewrite}}, {{current_analysis}}, {{score_results}}, {{iteration_number}}</p>

        <textarea
          id="${MODULE_NAME}_refinement_prompt"
          class="text_pole ${MODULE_NAME}_system_prompt_textarea"
          rows="8"
        >${escapeHtml(settings.refinementPrompt)}</textarea>

        <div class="${MODULE_NAME}_settings_row_spread">
          <span id="${MODULE_NAME}_refinement_prompt_chars">${settings.refinementPrompt.length.toLocaleString()} chars</span>
          <button id="${MODULE_NAME}_reset_refinement_prompt" class="menu_button">
            <i class="fa-solid fa-rotate-left"></i>
            Reset
          </button>
        </div>
      </div>

      <!-- Preset Management -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-bookmark"></i>
          <span>Presets</span>
        </div>

        <div class="${MODULE_NAME}_presets_grid">
          <div class="${MODULE_NAME}_preset_column">
            <h4>Prompt Presets</h4>
            <div id="${MODULE_NAME}_prompt_presets_list" class="${MODULE_NAME}_preset_list">
              ${renderPresetList('prompt')}
            </div>
          </div>
          <div class="${MODULE_NAME}_preset_column">
            <h4>Schema Presets</h4>
            <div id="${MODULE_NAME}_schema_presets_list" class="${MODULE_NAME}_preset_list">
              ${renderPresetList('schema')}
            </div>
          </div>
        </div>

        <div class="${MODULE_NAME}_settings_row_spread">
          <button id="${MODULE_NAME}_export_presets" class="menu_button">
            <i class="fa-solid fa-file-export"></i>
            Export Custom
          </button>
          <button id="${MODULE_NAME}_import_presets" class="menu_button">
            <i class="fa-solid fa-file-import"></i>
            Import
          </button>
        </div>
      </div>

      <!-- Debug -->
      <div class="${MODULE_NAME}_settings_section">
        <div class="${MODULE_NAME}_settings_section_header">
          <i class="fa-solid fa-bug"></i>
          <span>Debug</span>
        </div>

        <div class="${MODULE_NAME}_settings_row">
          <label class="${MODULE_NAME}_checkbox_label">
            <input
              type="checkbox"
              id="${MODULE_NAME}_debug_mode"
              ${settings.debugMode ? 'checked' : ''}
            >
            <span>Enable Debug Logging</span>
          </label>
        </div>

        <div class="${MODULE_NAME}_debug_actions">
          <button id="${MODULE_NAME}_view_logs" class="menu_button">
            <i class="fa-solid fa-list"></i>
            View Logs
          </button>
          <button id="${MODULE_NAME}_clear_logs" class="menu_button">
            <i class="fa-solid fa-trash"></i>
            Clear
          </button>
          <button id="${MODULE_NAME}_copy_debug_info" class="menu_button">
            <i class="fa-solid fa-copy"></i>
            Copy Info
          </button>
        </div>

        <div id="${MODULE_NAME}_debug_log_viewer" class="${MODULE_NAME}_debug_log_viewer hidden">
          <div id="${MODULE_NAME}_debug_log_list" class="${MODULE_NAME}_debug_log_list"></div>
          <pre id="${MODULE_NAME}_debug_log_detail" class="${MODULE_NAME}_debug_log_detail">Select a log entry</pre>
        </div>
      </div>
    </div>
  `;
}

function renderPresetList(type: 'prompt' | 'schema'): string {
    const presets = type === 'prompt' ? getPromptPresets() : getSchemaPresets();

    if (presets.length === 0) {
        return `<div class="${MODULE_NAME}_preset_empty">No presets</div>`;
    }

    return presets.map(preset => `
    <div class="${MODULE_NAME}_preset_item ${preset.isBuiltin ? 'builtin' : ''}" data-id="${preset.id}">
      <span class="${MODULE_NAME}_preset_name">
        ${preset.isBuiltin ? '<i class="fa-solid fa-lock"></i>' : ''}
        ${escapeHtml(preset.name)}
      </span>
      ${!preset.isBuiltin ? `
        <button class="${MODULE_NAME}_preset_delete" data-type="${type}" data-id="${preset.id}" title="Delete">
          <i class="fa-solid fa-trash"></i>
        </button>
      ` : ''}
    </div>
  `).join('');
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function initSettingsListeners(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    // Use current settings toggle
    const useCurrentCheckbox = modal.querySelector(`#${MODULE_NAME}_use_current_settings`) as HTMLInputElement;
    const customConfig = modal.querySelector(`#${MODULE_NAME}_custom_gen_config`);

    useCurrentCheckbox?.addEventListener('change', () => {
        updateSetting('useCurrentSettings', useCurrentCheckbox.checked);
        customConfig?.classList.toggle('hidden', useCurrentCheckbox.checked);
    });

    // Generation config inputs
    const genSource = modal.querySelector(`#${MODULE_NAME}_gen_source`) as HTMLSelectElement;
    const genModel = modal.querySelector(`#${MODULE_NAME}_gen_model`) as HTMLSelectElement;
    const genTemp = modal.querySelector(`#${MODULE_NAME}_gen_temp`) as HTMLInputElement;
    const genTokens = modal.querySelector(`#${MODULE_NAME}_gen_tokens`) as HTMLInputElement;
    const genFreq = modal.querySelector(`#${MODULE_NAME}_gen_freq`) as HTMLInputElement;
    const genPres = modal.querySelector(`#${MODULE_NAME}_gen_pres`) as HTMLInputElement;
    const genTopP = modal.querySelector(`#${MODULE_NAME}_gen_top_p`) as HTMLInputElement;

    genSource?.addEventListener('change', () => {
        updateGenerationConfig({ source: genSource.value });
        populateModelSelect(genSource.value);
    });

    genModel?.addEventListener('change', () => {
        updateGenerationConfig({ model: genModel.value });
    });

    const handleNumberInput = (input: HTMLInputElement, key: keyof GenerationConfig, isInt = false) => {
        input?.addEventListener('change', () => {
            const val = isInt ? parseInt(input.value, 10) : parseFloat(input.value);
            if (!isNaN(val)) {
                updateGenerationConfig({ [key]: val });
            }
        });
    };

    handleNumberInput(genTemp, 'temperature');
    handleNumberInput(genTokens, 'maxTokens', true);
    handleNumberInput(genFreq, 'frequencyPenalty');
    handleNumberInput(genPres, 'presencePenalty');
    handleNumberInput(genTopP, 'topP');

    // System prompt
    const systemPromptTextarea = modal.querySelector(`#${MODULE_NAME}_system_prompt`) as HTMLTextAreaElement;
    const systemPromptChars = modal.querySelector(`#${MODULE_NAME}_system_prompt_chars`);
    const resetSystemPromptBtn = modal.querySelector(`#${MODULE_NAME}_reset_system_prompt`);

    systemPromptTextarea?.addEventListener('input', () => {
        updateSystemPrompt(systemPromptTextarea.value);
        if (systemPromptChars) {
            systemPromptChars.textContent = `${systemPromptTextarea.value.length.toLocaleString()} chars`;
        }
    });

    resetSystemPromptBtn?.addEventListener('click', () => {
        resetSystemPrompt();
        if (systemPromptTextarea) {
            systemPromptTextarea.value = DEFAULT_SYSTEM_PROMPT;
        }
        if (systemPromptChars) {
            systemPromptChars.textContent = `${DEFAULT_SYSTEM_PROMPT.length.toLocaleString()} chars`;
        }
        toastr.info('System prompt reset to default');
    });

    // Refinement prompt
    const refinementPromptTextarea = modal.querySelector(`#${MODULE_NAME}_refinement_prompt`) as HTMLTextAreaElement;
    const refinementPromptChars = modal.querySelector(`#${MODULE_NAME}_refinement_prompt_chars`);
    const resetRefinementPromptBtn = modal.querySelector(`#${MODULE_NAME}_reset_refinement_prompt`);

    refinementPromptTextarea?.addEventListener('input', () => {
        updateRefinementPrompt(refinementPromptTextarea.value);
        if (refinementPromptChars) {
            refinementPromptChars.textContent = `${refinementPromptTextarea.value.length.toLocaleString()} chars`;
        }
    });

    resetRefinementPromptBtn?.addEventListener('click', () => {
        resetRefinementPrompt();
        if (refinementPromptTextarea) {
            refinementPromptTextarea.value = DEFAULT_REFINEMENT_PROMPT;
        }
        if (refinementPromptChars) {
            refinementPromptChars.textContent = `${DEFAULT_REFINEMENT_PROMPT.length.toLocaleString()} chars`;
        }
        toastr.info('Refinement prompt reset to default');
    });

    // Preset management
    modal.addEventListener('click', (e) => {
        const deleteBtn = (e.target as HTMLElement).closest(`.${MODULE_NAME}_preset_delete`);
        if (deleteBtn) {
            const type = deleteBtn.getAttribute('data-type') as 'prompt' | 'schema';
            const id = deleteBtn.getAttribute('data-id');
            if (type && id) {
                handleDeletePreset(type, id);
            }
        }
    });

    const exportPresetsBtn = modal.querySelector(`#${MODULE_NAME}_export_presets`);
    const importPresetsBtn = modal.querySelector(`#${MODULE_NAME}_import_presets`);

    exportPresetsBtn?.addEventListener('click', () => {
        const json = exportCustomPresets();
        navigator.clipboard.writeText(json);
        toastr.success('Custom presets copied to clipboard');
    });

    importPresetsBtn?.addEventListener('click', async () => {
        try {
            const json = await navigator.clipboard.readText();
            const result = importPresets(json);

            if (result.errors.length > 0) {
                toastr.error(result.errors.join('\n'));
            } else {
                toastr.success(`Imported ${result.prompts} prompts, ${result.schemas} schemas`);
                refreshPresetLists();
            }
        } catch {
            toastr.error('Failed to read clipboard');
        }
    });

    // Debug
    const debugModeCheckbox = modal.querySelector(`#${MODULE_NAME}_debug_mode`) as HTMLInputElement;
    const viewLogsBtn = modal.querySelector(`#${MODULE_NAME}_view_logs`);
    const clearLogsBtn = modal.querySelector(`#${MODULE_NAME}_clear_logs`);
    const copyDebugBtn = modal.querySelector(`#${MODULE_NAME}_copy_debug_info`);
    const logViewer = modal.querySelector(`#${MODULE_NAME}_debug_log_viewer`);

    debugModeCheckbox?.addEventListener('change', () => {
        setDebugMode(debugModeCheckbox.checked);
        toastr.info(`Debug mode ${debugModeCheckbox.checked ? 'enabled' : 'disabled'}`);
    });

    viewLogsBtn?.addEventListener('click', () => {
        logViewer?.classList.toggle('hidden');
        if (!logViewer?.classList.contains('hidden')) {
            refreshDebugLogs();
        }
    });

    clearLogsBtn?.addEventListener('click', () => {
        clearDebugLogs();
        refreshDebugLogs();
        toastr.info('Debug logs cleared');
    });

    copyDebugBtn?.addEventListener('click', () => {
        navigator.clipboard.writeText(exportDebugInfo());
        toastr.success('Debug info copied to clipboard');
    });
}

function handleDeletePreset(type: 'prompt' | 'schema', id: string): void {
    const success = type === 'prompt' ? deletePromptPreset(id) : deleteSchemaPreset(id);

    if (success) {
        toastr.success('Preset deleted');
        refreshPresetLists();
    } else {
        toastr.error('Cannot delete builtin preset');
    }
}

function refreshPresetLists(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    const promptList = modal.querySelector(`#${MODULE_NAME}_prompt_presets_list`);
    const schemaList = modal.querySelector(`#${MODULE_NAME}_schema_presets_list`);

    if (promptList) {
        promptList.innerHTML = renderPresetList('prompt');
    }
    if (schemaList) {
        schemaList.innerHTML = renderPresetList('schema');
    }
}

function refreshDebugLogs(): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    if (!modal) return;

    const logList = modal.querySelector(`#${MODULE_NAME}_debug_log_list`);
    const logDetail = modal.querySelector(`#${MODULE_NAME}_debug_log_detail`);

    if (!logList || !logDetail) return;

    const logs = getDebugLogs();

    logList.innerHTML = logs.length
        ? logs.map((entry, i) => `
        <div class="${MODULE_NAME}_debug_log_entry" data-index="${i}">
          ${formatLogEntry(entry)}
        </div>
      `).join('')
        : `<div class="${MODULE_NAME}_debug_log_empty">No logs</div>`;

    // Click handler for log entries
    logList.querySelectorAll(`.${MODULE_NAME}_debug_log_entry`).forEach(el => {
        el.addEventListener('click', () => {
            const index = parseInt((el as HTMLElement).dataset.index || '0', 10);
            const entry = logs[index];
            if (entry && logDetail) {
                logDetail.textContent = formatLogData(entry.data);
            }
        });
    });
}

// ============================================================================
// MODEL SELECTS
// ============================================================================

function refreshModelSelects(): void {
    const settings = getSettings();
    populateSourceSelect(settings.generationConfig.source);
    populateModelSelect(settings.generationConfig.source, settings.generationConfig.model);
}

function populateSourceSelect(currentSource: string): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    const sourceSelect = modal?.querySelector(`#${MODULE_NAME}_gen_source`) as HTMLSelectElement;
    if (!sourceSelect) return;

    sourceSelect.innerHTML = '';

    const stSourceSelect = document.getElementById('chat_completion_source') as HTMLSelectElement;

    if (stSourceSelect) {
        Array.from(stSourceSelect.options).forEach((opt: HTMLOptionElement) => {
            if (opt.value) {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.textContent || opt.value;
                sourceSelect.appendChild(option);
            }
        });
    }

    if (sourceSelect.options.length === 0) {
        ['openrouter', 'openai', 'claude', 'makersuite', 'mistralai', 'groq'].forEach(src => {
            const option = document.createElement('option');
            option.value = src;
            option.textContent = src;
            sourceSelect.appendChild(option);
        });
    }

    sourceSelect.value = currentSource;
}

function populateModelSelect(source: string, currentModel?: string): void {
    const modal = document.getElementById(`${MODULE_NAME}_settings_modal`);
    const modelSelect = modal?.querySelector(`#${MODULE_NAME}_gen_model`) as HTMLSelectElement;
    if (!modelSelect) return;

    modelSelect.innerHTML = '';

    const selectIdMap: Record<string, string> = {
        openrouter: 'model_openrouter_select',
        openai: 'model_openai_select',
        claude: 'model_claude_select',
        makersuite: 'model_google_select',
        google: 'model_google_select',
        mistralai: 'model_mistralai_select',
        cohere: 'model_cohere_select',
        perplexity: 'model_perplexity_select',
        groq: 'model_groq_select',
        ai21: 'model_ai21_select',
        deepseek: 'model_deepseek_select',
        custom: 'model_custom_select',
    };

    const stSelect = selectIdMap[source] ? document.getElementById(selectIdMap[source]) as HTMLSelectElement : null;

    if (stSelect?.options.length) {
        Array.from(stSelect.options).forEach((opt: HTMLOptionElement) => {
            if (opt.value) {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.textContent || opt.value;
                modelSelect.appendChild(option);
            }
        });
    } else {
        const option = document.createElement('option');
        option.value = currentModel || '';
        option.textContent = currentModel || `No models for ${source}`;
        modelSelect.appendChild(option);
    }

    if (currentModel && Array.from(modelSelect.options).some(o => o.value === currentModel)) {
        modelSelect.value = currentModel;
    } else if (modelSelect.options.length) {
        modelSelect.value = modelSelect.options[0].value;
        updateGenerationConfig({ model: modelSelect.options[0].value });
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/character-select.ts
```ts
// src/ui/components/character-select.ts
//
// Character search and preview component

import { MODULE_NAME } from '../../constants';
import { getPopulatedFields } from '../../character';
import type { Character, PopulatedField } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the character select component
 */
export function renderCharacterSelect(
    characters: Character[],
    selectedIndex: number | null,
): string {
    const selectedChar = selectedIndex !== null ? characters[selectedIndex] : null;

    return `
    <div class="${MODULE_NAME}_char_select">
      <!-- Search -->
      <div class="${MODULE_NAME}_search_wrapper ${selectedChar ? 'hidden' : ''}">
        <div class="${MODULE_NAME}_search_container">
          <i class="fa-solid fa-search ${MODULE_NAME}_search_icon"></i>
          <input
            type="text"
            id="${MODULE_NAME}_char_search"
            class="text_pole ${MODULE_NAME}_search_input"
            placeholder="Search characters..."
            autocomplete="off"
          >
        </div>
        <div id="${MODULE_NAME}_char_dropdown" class="${MODULE_NAME}_dropdown hidden"></div>
      </div>

      <!-- Selected Character Preview -->
      ${selectedChar ? renderCharacterPreview(selectedChar) : ''}
    </div>
  `;
}

/**
 * Render character preview with expandable fields
 */
function renderCharacterPreview(char: Character): string {
    const { getThumbnailUrl } = SillyTavern.getContext();
    const fields = getPopulatedFields(char);

    const avatar = getThumbnailUrl('avatar', char.avatar);

    return `
    <div class="${MODULE_NAME}_char_preview" id="${MODULE_NAME}_char_preview">
      <div class="${MODULE_NAME}_char_header">
        <img
          class="${MODULE_NAME}_char_avatar"
          src="${avatar}"
          alt=""
          onerror="this.src='/img/ai4.png'"
        >
        <div class="${MODULE_NAME}_char_info">
          <div class="${MODULE_NAME}_char_name">${escapeHtml(char.name)}</div>
          <div class="${MODULE_NAME}_char_meta">
            ${fields.length} fields • <span id="${MODULE_NAME}_total_tokens">counting...</span>
          </div>
        </div>
        <button id="${MODULE_NAME}_char_clear" class="${MODULE_NAME}_icon_btn" title="Clear selection">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="${MODULE_NAME}_char_fields">
        ${fields.map(f => renderFieldRow(f)).join('')}
      </div>
    </div>
  `;
}

/**
 * Render a single field row with expand/collapse
 */
function renderFieldRow(field: PopulatedField): string {
    return `
    <div class="${MODULE_NAME}_field_row">
      <div class="${MODULE_NAME}_field_header ${MODULE_NAME}_field_toggle" data-field="${field.key}">
        <i class="fa-solid fa-chevron-right"></i>
        <span class="${MODULE_NAME}_field_label">${field.label}</span>
        <span class="${MODULE_NAME}_field_tokens" data-field="${field.key}">...</span>
      </div>
      <div class="${MODULE_NAME}_field_content hidden" id="${MODULE_NAME}_field_content_${field.key}">
        <div class="${MODULE_NAME}_field_text">${escapeHtml(field.value)}</div>
      </div>
    </div>
  `;
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update character select state without full re-render
 */
export function updateCharacterSelectState(
    container: HTMLElement,
    character: Character | null,
    _characterIndex: number | null,
): void {
    const searchWrapper = container.querySelector(`.${MODULE_NAME}_search_wrapper`);
    const existingPreview = container.querySelector(`#${MODULE_NAME}_char_preview`);

    if (character) {
        searchWrapper?.classList.add('hidden');

        if (!existingPreview) {
            const previewHtml = renderCharacterPreview(character);
            const searchEl = container.querySelector(`.${MODULE_NAME}_search_wrapper`);
            if (searchEl) {
                searchEl.insertAdjacentHTML('afterend', previewHtml);
            }
        }
    } else {
        searchWrapper?.classList.remove('hidden');
        existingPreview?.remove();

        const searchInput = container.querySelector(`#${MODULE_NAME}_char_search`) as HTMLInputElement;
        if (searchInput) {
            searchInput.value = '';
        }
    }
}

/**
 * Update token counts for character fields and total
 */
export async function updateFieldTokenCounts(container: HTMLElement, fields: PopulatedField[]): Promise<void> {
    const { getTokenCountAsync } = SillyTavern.getContext();

    let totalTokens = 0;

    for (const field of fields) {
        const tokenSpan = container.querySelector(`.${MODULE_NAME}_field_tokens[data-field="${field.key}"]`);
        if (tokenSpan) {
            try {
                const tokens = await getTokenCountAsync(field.value);
                totalTokens += tokens;
                tokenSpan.textContent = `${tokens.toLocaleString()}t`;
            } catch {
                tokenSpan.textContent = '?';
            }
        }
    }

    // Update total
    const totalSpan = container.querySelector(`#${MODULE_NAME}_total_tokens`);
    if (totalSpan) {
        totalSpan.textContent = `${totalTokens.toLocaleString()} tokens`;
    }
}

/**
 * Render dropdown items - called from popup.ts
 */
export function renderDropdownItems(
    results: Array<{ char: Character; index: number }>,
    dropdown: HTMLElement,
    selectedIndex: number,
): void {
    const { getThumbnailUrl } = SillyTavern.getContext();

    if (results.length === 0) {
        dropdown.innerHTML = `<div class="${MODULE_NAME}_dropdown_empty">No characters found</div>`;
        return;
    }

    dropdown.innerHTML = results.map(({ char, index }, i) => {
        const avatar = getThumbnailUrl('avatar', char.avatar);
        const isSelected = i === selectedIndex;
        const descPreview = (char.description || 'No description').substring(0, 80);

        return `
      <div class="${MODULE_NAME}_dropdown_item ${isSelected ? 'selected' : ''}" data-index="${index}">
        <img class="${MODULE_NAME}_dropdown_avatar" src="${avatar}" alt="" onerror="this.src='/img/ai4.png'">
        <div class="${MODULE_NAME}_dropdown_info">
          <span class="${MODULE_NAME}_dropdown_name">${escapeHtml(char.name)}</span>
          <span class="${MODULE_NAME}_dropdown_desc">${escapeHtml(descPreview)}${descPreview.length >= 80 ? '...' : ''}</span>
        </div>
      </div>
    `;
    }).join('');
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/pipeline-nav.ts
```ts
// src/ui/components/pipeline-nav.ts
//
// Pipeline stage selection and navigation component

import { MODULE_NAME, STAGES, STAGE_LABELS, STAGE_ICONS } from '../../constants';
import type { StageName, StageStatus } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the pipeline navigation component
 */
export function renderPipelineNav(
    selectedStages: StageName[],
    stageStatus: Record<StageName, StageStatus>,
    activeStage: StageName,
    hasCharacter: boolean,
): string {
    return `
    <div class="${MODULE_NAME}_pipeline_nav">
      <!-- Stage Selection -->
      <div class="${MODULE_NAME}_stage_row">
        ${STAGES.map((stage, i) => renderStageNode(
        stage,
        selectedStages.includes(stage),
        stageStatus[stage],
        stage === activeStage,
        i < STAGES.length - 1,
    )).join('')}
      </div>

      <!-- Action Buttons -->
      <div class="${MODULE_NAME}_pipeline_actions">
        <button
          id="${MODULE_NAME}_run_selected_btn"
          class="menu_button"
          ${!hasCharacter ? 'disabled' : ''}
        >
          <i class="fa-solid fa-play"></i>
          <span>Run Selected</span>
        </button>
        <button
          id="${MODULE_NAME}_run_all_btn"
          class="menu_button"
          ${!hasCharacter ? 'disabled' : ''}
        >
          <i class="fa-solid fa-forward"></i>
          <span>Run All</span>
        </button>
        <button
          id="${MODULE_NAME}_reset_pipeline_btn"
          class="menu_button"
        >
          <i class="fa-solid fa-rotate-left"></i>
          <span>Reset</span>
        </button>
      </div>
    </div>
  `;
}

/**
 * Render a single stage node
 */
function renderStageNode(
    stage: StageName,
    isSelected: boolean,
    status: StageStatus,
    isActive: boolean,
    hasConnector: boolean,
): string {
    const statusIcon = getStatusIcon(status);

    return `
    <div class="${MODULE_NAME}_stage_node ${isActive ? 'active' : ''} ${MODULE_NAME}_stage_${status}">
      <input
        type="checkbox"
        class="${MODULE_NAME}_stage_checkbox"
        id="${MODULE_NAME}_stage_cb_${stage}"
        data-stage="${stage}"
        ${isSelected ? 'checked' : ''}
      >
      <button
        class="${MODULE_NAME}_stage_btn ${isActive ? 'active' : ''}"
        data-stage="${stage}"
        title="${STAGE_LABELS[stage]}"
      >
        <i class="fa-solid ${STAGE_ICONS[stage]}"></i>
        <span>${STAGE_LABELS[stage]}</span>
        ${statusIcon ? `<i class="fa-solid ${statusIcon} ${MODULE_NAME}_status_icon"></i>` : ''}
      </button>
      ${hasConnector ? `<div class="${MODULE_NAME}_stage_connector ${isSelected ? 'active' : ''}"></div>` : ''}
    </div>
  `;
}

function getStatusIcon(status: StageStatus): string | null {
    switch (status) {
        case 'complete': return 'fa-check';
        case 'running': return 'fa-spinner fa-spin';
        case 'skipped': return 'fa-forward';
        default: return null;
    }
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update pipeline nav state without full re-render
 */
export function updatePipelineNavState(
    container: HTMLElement,
    selectedStages: StageName[],
    stageStatus: Record<StageName, StageStatus>,
    activeStage: StageName,
    hasCharacter: boolean,
    isGenerating: boolean,
): void {
    // Update checkboxes and buttons
    for (const stage of STAGES) {
        const checkbox = container.querySelector(`#${MODULE_NAME}_stage_cb_${stage}`) as HTMLInputElement;
        const btn = container.querySelector(`.${MODULE_NAME}_stage_btn[data-stage="${stage}"]`);
        const node = container.querySelector(`.${MODULE_NAME}_stage_node:has([data-stage="${stage}"])`);

        if (checkbox) {
            checkbox.checked = selectedStages.includes(stage);
        }

        if (btn) {
            btn.classList.toggle('active', stage === activeStage);
        }

        if (node) {
            node.classList.toggle('active', stage === activeStage);

            // Update status classes
            for (const s of ['pending', 'running', 'complete', 'skipped']) {
                node.classList.toggle(`${MODULE_NAME}_stage_${s}`, stageStatus[stage] === s);
            }
        }

        // Update connector
        const connector = node?.querySelector(`.${MODULE_NAME}_stage_connector`);
        connector?.classList.toggle('active', selectedStages.includes(stage));
    }

    // Update action buttons
    const runSelectedBtn = container.querySelector(`#${MODULE_NAME}_run_selected_btn`) as HTMLButtonElement;
    const runAllBtn = container.querySelector(`#${MODULE_NAME}_run_all_btn`) as HTMLButtonElement;
    const resetBtn = container.querySelector(`#${MODULE_NAME}_reset_pipeline_btn`) as HTMLButtonElement;

    if (runSelectedBtn) runSelectedBtn.disabled = !hasCharacter || isGenerating;
    if (runAllBtn) runAllBtn.disabled = !hasCharacter || isGenerating;
    if (resetBtn) resetBtn.disabled = isGenerating;
}
```

## FILE: src/ui/components/stage-config.ts
```ts
// src/ui/components/stage-config.ts
//
// Stage configuration component - prompt/schema selection and editing

import { MODULE_NAME, STAGE_LABELS } from '../../constants';
import { getPromptPresets, getSchemaPresets, getPromptPreset, getSchemaPreset, savePromptPreset, saveSchemaPreset } from '../../settings';
import { validateSchema, autoFixSchema, generateSchemaFromDescription } from '../../schema';
import type { StageName, StageConfig, PromptPreset, SchemaPreset } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

export function renderStageConfig(
    stage: StageName,
    config: StageConfig,
    tokenEstimate: { tokens: number; percentage: number } | null,
): string {
    const promptPresets = getPromptPresets(stage);
    const schemaPresets = getSchemaPresets(stage);

    // Get current prompt content
    let promptContent = config.customPrompt;
    if (config.promptPresetId) {
        const preset = getPromptPreset(config.promptPresetId);
        if (preset) promptContent = preset.prompt;
    }

    // Get current schema content
    let schemaContent = config.customSchema;
    if (config.schemaPresetId) {
        const preset = getSchemaPreset(config.schemaPresetId);
        if (preset) schemaContent = JSON.stringify(preset.schema, null, 2);
    }

    // Validate schema if present
    let schemaStatus = '';
    let schemaValidation: { valid: boolean; error?: string; warnings?: string[] } = { valid: true };
    if (config.useStructuredOutput && schemaContent.trim()) {
        schemaValidation = validateSchema(schemaContent);
        if (!schemaValidation.valid) {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status error"><i class="fa-solid fa-circle-xmark"></i> ${escapeHtml(schemaValidation.error || 'Invalid schema')}</div>`;
        } else if (schemaValidation.warnings?.length) {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status warning"><i class="fa-solid fa-triangle-exclamation"></i> ${schemaValidation.warnings.length} warning(s)</div>`;
        } else {
            schemaStatus = `<div class="${MODULE_NAME}_schema_status success"><i class="fa-solid fa-circle-check"></i> Valid schema</div>`;
        }
    }

    // Token estimate display
    let tokenDisplay = '<i class="fa-solid fa-microchip"></i> Select a character';
    let tokenClass = '';
    if (tokenEstimate) {
        tokenDisplay = `<i class="fa-solid fa-microchip"></i> ~${tokenEstimate.tokens.toLocaleString()} tokens (${tokenEstimate.percentage}%)`;
        if (tokenEstimate.percentage > 80) tokenClass = 'danger';
        else if (tokenEstimate.percentage > 50) tokenClass = 'warning';
    }

    // Check if current content differs from selected preset (for save button state)
    const promptDiffersFromPreset = config.promptPresetId
        ? getPromptPreset(config.promptPresetId)?.prompt !== promptContent
        : promptContent.trim().length > 0;

    const schemaDiffersFromPreset = config.schemaPresetId
        ? JSON.stringify(getSchemaPreset(config.schemaPresetId)?.schema, null, 2) !== schemaContent
        : schemaContent.trim().length > 0;

    // Show fix button if schema has warnings or is invalid but parseable
    const showFixButton = config.useStructuredOutput && schemaContent.trim() &&
        (schemaValidation.warnings?.length || !schemaValidation.valid);

    return `
    <div class="${MODULE_NAME}_stage_config">
      <!-- Prompt Section -->
      <div class="${MODULE_NAME}_config_group">
        <div class="${MODULE_NAME}_config_header">
          <span class="${MODULE_NAME}_config_label">Prompt</span>
          <div class="${MODULE_NAME}_config_header_actions">
            <button
              id="${MODULE_NAME}_save_prompt_preset_btn"
              class="${MODULE_NAME}_icon_btn"
              title="Save as Preset"
              ${!promptDiffersFromPreset ? 'disabled' : ''}
            >
              <i class="fa-solid fa-floppy-disk"></i>
            </button>
            <select id="${MODULE_NAME}_prompt_preset_select" class="${MODULE_NAME}_preset_select">
              <option value="">Custom</option>
              ${renderPresetOptions(promptPresets, config.promptPresetId)}
            </select>
          </div>
        </div>
        <textarea
          id="${MODULE_NAME}_custom_prompt"
          class="${MODULE_NAME}_prompt_textarea text_pole"
          placeholder="Enter your prompt for the ${STAGE_LABELS[stage]} stage..."
        >${escapeHtml(promptContent)}</textarea>
        <div class="${MODULE_NAME}_config_footer">
          <span class="${MODULE_NAME}_char_count">${promptContent.length.toLocaleString()} chars</span>
        </div>
      </div>

      <!-- Structured Output Toggle -->
      <div class="${MODULE_NAME}_config_group">
        <label class="${MODULE_NAME}_checkbox_label">
          <input
            type="checkbox"
            id="${MODULE_NAME}_use_structured"
            ${config.useStructuredOutput ? 'checked' : ''}
          >
          <span>Use Structured Output (JSON Schema)</span>
        </label>
      </div>

      <!-- Schema Section -->
      <div class="${MODULE_NAME}_schema_section ${config.useStructuredOutput ? '' : 'hidden'}">
        <div class="${MODULE_NAME}_config_header">
          <span class="${MODULE_NAME}_config_label">JSON Schema</span>
          <div class="${MODULE_NAME}_config_header_actions">
            <button
              id="${MODULE_NAME}_save_schema_preset_btn"
              class="${MODULE_NAME}_icon_btn"
              title="Save as Preset"
              ${!schemaDiffersFromPreset || !schemaContent.trim() ? 'disabled' : ''}
            >
              <i class="fa-solid fa-floppy-disk"></i>
            </button>
            <select id="${MODULE_NAME}_schema_preset_select" class="${MODULE_NAME}_preset_select">
              <option value="">Custom</option>
              ${renderPresetOptions(schemaPresets, config.schemaPresetId)}
            </select>
          </div>
        </div>
        <textarea
          id="${MODULE_NAME}_custom_schema"
          class="${MODULE_NAME}_schema_textarea text_pole"
          placeholder='{"name": "MySchema", "value": {"type": "object", ...}}'
        >${escapeHtml(schemaContent)}</textarea>
        ${schemaStatus}

        <!-- Schema Actions -->
        <div class="${MODULE_NAME}_schema_actions">
          <button
            id="${MODULE_NAME}_generate_schema_btn"
            class="menu_button menu_button_icon"
            title="Generate schema from description"
          >
            <i class="fa-solid fa-wand-magic-sparkles"></i>
            <span>Generate</span>
          </button>
          <button
            id="${MODULE_NAME}_validate_schema_btn"
            class="menu_button menu_button_icon"
            title="Validate schema"
            ${!schemaContent.trim() ? 'disabled' : ''}
          >
            <i class="fa-solid fa-check-double"></i>
            <span>Validate</span>
          </button>
          <button
            id="${MODULE_NAME}_fix_schema_btn"
            class="menu_button menu_button_icon"
            title="Auto-fix schema (adds additionalProperties: false, etc.)"
            ${!showFixButton ? 'disabled' : ''}
          >
            <i class="fa-solid fa-wrench"></i>
            <span>Auto-Fix</span>
          </button>
          <button
            id="${MODULE_NAME}_format_schema_btn"
            class="menu_button menu_button_icon"
            title="Format/prettify JSON"
            ${!schemaContent.trim() ? 'disabled' : ''}
          >
            <i class="fa-solid fa-align-left"></i>
            <span>Format</span>
          </button>
        </div>
      </div>

      <!-- Actions -->
      <div class="${MODULE_NAME}_config_actions">
        <div id="${MODULE_NAME}_token_estimate" class="${MODULE_NAME}_token_estimate ${tokenClass}">
          ${tokenDisplay}
        </div>
      </div>
    </div>
  `;
}


// ============================================================================
// UPDATE STATE
// ============================================================================
// Export this new handler
export async function handleGenerateSchema(): Promise<string | null> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    const description = await Popup.show.input(
        'Generate Schema',
        'Describe the structure you want (e.g., <q>"scores for each field 1-10, list of suggestions, overall rating"</q>):\n',
        '',
    );

    if (description === null || description === POPUP_RESULT.CANCELLED || !description.trim()) {
        return null;
    }

    toastr.info('Generating schema...');

    const result = await generateSchemaFromDescription(description);

    if (result.success) {
        toastr.success('Schema generated!');
        return result.schema!;
    } else {
        toastr.error(result.error || 'Generation failed');
        // Return the broken schema anyway so they can see/fix it
        return result.schema || null;
    }
}



export function updateStageConfigState(
    container: HTMLElement,
    stage: StageName,
    config: StageConfig,
    isGenerating: boolean,
): void {
    const promptPresets = getPromptPresets(stage);
    const schemaPresets = getSchemaPresets(stage);

    // Update prompt preset select
    const promptSelect = container.querySelector(`#${MODULE_NAME}_prompt_preset_select`) as HTMLSelectElement;
    if (promptSelect) {
        promptSelect.innerHTML = `<option value="">Custom</option>${renderPresetOptions(promptPresets, config.promptPresetId)}`;
        promptSelect.value = config.promptPresetId || '';
        promptSelect.disabled = isGenerating;
    }

    // Update prompt textarea
    const promptTextarea = container.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
    if (promptTextarea) {
        let promptContent = config.customPrompt;
        if (config.promptPresetId) {
            const preset = getPromptPreset(config.promptPresetId);
            if (preset) promptContent = preset.prompt;
        }
        // Only update if different to preserve cursor position
        if (promptTextarea.value !== promptContent) {
            promptTextarea.value = promptContent;
        }
        promptTextarea.disabled = isGenerating;

        // Update char count
        const charCount = container.querySelector(`.${MODULE_NAME}_char_count`);
        if (charCount) {
            charCount.textContent = `${promptContent.length.toLocaleString()} chars`;
        }
    }

    // Update structured output toggle
    const structuredToggle = container.querySelector(`#${MODULE_NAME}_use_structured`) as HTMLInputElement;
    if (structuredToggle) {
        structuredToggle.checked = config.useStructuredOutput;
        structuredToggle.disabled = isGenerating;
    }

    // Update schema section visibility
    const schemaSection = container.querySelector(`.${MODULE_NAME}_schema_section`);
    if (schemaSection) {
        schemaSection.classList.toggle('hidden', !config.useStructuredOutput);
    }

    // Update schema preset select
    const schemaSelect = container.querySelector(`#${MODULE_NAME}_schema_preset_select`) as HTMLSelectElement;
    if (schemaSelect) {
        schemaSelect.innerHTML = `<option value="">Custom</option>${renderPresetOptions(schemaPresets, config.schemaPresetId)}`;
        schemaSelect.value = config.schemaPresetId || '';
        schemaSelect.disabled = isGenerating;
    }

    // Update schema textarea
    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;
    if (schemaTextarea) {
        let schemaContent = config.customSchema;
        if (config.schemaPresetId) {
            const preset = getSchemaPreset(config.schemaPresetId);
            if (preset) schemaContent = JSON.stringify(preset.schema, null, 2);
        }
        if (schemaTextarea.value !== schemaContent) {
            schemaTextarea.value = schemaContent;
        }
        schemaTextarea.disabled = isGenerating;
    }

    // Update schema validation status
    if (config.useStructuredOutput) {
        updateSchemaValidation(container, schemaTextarea?.value || '');
    }

    // Update schema action buttons
    updateSchemaActionButtons(container, schemaTextarea?.value || '');

    // Update run button
    const runBtn = container.querySelector(`#${MODULE_NAME}_run_stage_btn`) as HTMLButtonElement;
    if (runBtn) {
        runBtn.disabled = isGenerating;
        if (isGenerating) {
            runBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Running...';
        } else {
            runBtn.innerHTML = `<i class="fa-solid fa-play"></i> Run ${STAGE_LABELS[stage]} <kbd>Ctrl+Enter</kbd>`;
        }
    }

    // Update save preset buttons
    updateSavePresetButtons(container, config);
}

// ============================================================================
// SCHEMA ACTION BUTTONS
// ============================================================================

function updateSchemaActionButtons(container: HTMLElement, schemaContent: string): void {
    const validateBtn = container.querySelector(`#${MODULE_NAME}_validate_schema_btn`) as HTMLButtonElement;
    const fixBtn = container.querySelector(`#${MODULE_NAME}_fix_schema_btn`) as HTMLButtonElement;
    const formatBtn = container.querySelector(`#${MODULE_NAME}_format_schema_btn`) as HTMLButtonElement;

    const hasContent = schemaContent.trim().length > 0;

    if (validateBtn) {
        validateBtn.disabled = !hasContent;
    }

    if (formatBtn) {
        formatBtn.disabled = !hasContent;
    }

    if (fixBtn && hasContent) {
        const validation = validateSchema(schemaContent);
        // Enable fix button if there are warnings or if it's invalid but might be fixable
        const needsFix = (validation.warnings?.length ?? 0) > 0 || !validation.valid;
        fixBtn.disabled = !needsFix;
    } else if (fixBtn) {
        fixBtn.disabled = true;
    }
}

// ============================================================================
// SCHEMA ACTION HANDLERS (called from popup.ts)
// ============================================================================

export function handleValidateSchema(schemaContent: string): void {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to validate');
        return;
    }

    const validation = validateSchema(schemaContent);

    if (!validation.valid) {
        toastr.error(`Invalid: ${validation.error}`);
        return;
    }

    if (validation.warnings?.length) {
        toastr.warning(`Valid with ${validation.warnings.length} warning(s):\n${validation.warnings.join('\n')}`);
        return;
    }

    if (validation.info?.length) {
        toastr.success(`Valid!\n${validation.info.join('\n')}`);
    } else {
        toastr.success('Schema is valid!');
    }
}

export function handleFixSchema(schemaContent: string): string | null {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to fix');
        return null;
    }

    // First try to parse it
    const validation = validateSchema(schemaContent);

    if (!validation.schema) {
        toastr.error('Cannot fix: schema is not valid JSON or missing required structure');
        return null;
    }

    try {
        const fixed = autoFixSchema(validation.schema);
        const fixedJson = JSON.stringify(fixed, null, 2);

        // Validate the fixed version
        const revalidation = validateSchema(fixedJson);

        if (!revalidation.valid) {
            toastr.warning('Auto-fix applied but schema still has issues');
        } else if (revalidation.warnings?.length) {
            toastr.info(`Fixed! ${revalidation.warnings.length} warning(s) remain`);
        } else {
            toastr.success('Schema fixed successfully!');
        }

        return fixedJson;
    } catch (e) {
        toastr.error(`Fix failed: ${(e as Error).message}`);
        return null;
    }
}

export function handleFormatSchema(schemaContent: string): string | null {
    if (!schemaContent.trim()) {
        toastr.warning('No schema to format');
        return null;
    }

    try {
        const parsed = JSON.parse(schemaContent);
        const formatted = JSON.stringify(parsed, null, 2);
        toastr.success('Schema formatted');
        return formatted;
    } catch (e) {
        toastr.error(`Cannot format: ${(e as Error).message}`);
        return null;
    }
}

// ============================================================================
// SAVE PRESET BUTTONS
// ============================================================================

function updateSavePresetButtons(container: HTMLElement, config: StageConfig): void {
    const promptTextarea = container.querySelector(`#${MODULE_NAME}_custom_prompt`) as HTMLTextAreaElement;
    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`) as HTMLTextAreaElement;

    const savePromptBtn = container.querySelector(`#${MODULE_NAME}_save_prompt_preset_btn`) as HTMLButtonElement;
    const saveSchemaBtn = container.querySelector(`#${MODULE_NAME}_save_schema_preset_btn`) as HTMLButtonElement;

    if (savePromptBtn && promptTextarea) {
        const currentPrompt = promptTextarea.value.trim();
        const presetPrompt = config.promptPresetId
            ? getPromptPreset(config.promptPresetId)?.prompt || ''
            : '';

        // Enable if there's content and it differs from the selected preset
        const hasContent = currentPrompt.length > 0;
        const isDifferent = currentPrompt !== presetPrompt;
        savePromptBtn.disabled = !hasContent || (config.promptPresetId !== null && !isDifferent);
    }

    if (saveSchemaBtn && schemaTextarea) {
        const currentSchema = schemaTextarea.value.trim();
        const presetSchema = config.schemaPresetId
            ? JSON.stringify(getSchemaPreset(config.schemaPresetId)?.schema, null, 2)
            : '';

        // Enable if there's valid content and it differs from the selected preset
        const hasContent = currentSchema.length > 0;
        const isDifferent = currentSchema !== presetSchema;
        const isValid = hasContent ? validateSchema(currentSchema).valid : false;
        saveSchemaBtn.disabled = !hasContent || !isValid || (config.schemaPresetId !== null && !isDifferent);
    }
}

// ============================================================================
// SAVE PRESET HANDLERS (called from popup.ts)
// ============================================================================

export interface SavePresetResult {
    success: boolean;
    presetId?: string;
}

export async function handleSavePromptPreset(stage: StageName, promptContent: string): Promise<SavePresetResult> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    if (!promptContent.trim()) {
        toastr.warning('No prompt content to save');
        return { success: false };
    }

    const name = await Popup.show.input(
        'Save Prompt Preset',
        'Enter a name for this preset:',
        `Custom ${STAGE_LABELS[stage]} Prompt`,
    );

    if (name === null || name === POPUP_RESULT.CANCELLED) {
        return { success: false };
    }

    if (!name.trim()) {
        toastr.warning('Preset name cannot be empty');
        return { success: false };
    }

    try {
        const newPreset = savePromptPreset({
            name: name.trim(),
            prompt: promptContent,
            stages: [stage],
        });
        toastr.success(`Prompt preset "${name}" saved`);
        return { success: true, presetId: newPreset.id };
    } catch (e) {
        toastr.error(`Failed to save preset: ${(e as Error).message}`);
        return { success: false };
    }
}

export async function handleSaveSchemaPreset(stage: StageName, schemaContent: string): Promise<SavePresetResult> {
    const { Popup, POPUP_RESULT } = SillyTavern.getContext();

    if (!schemaContent.trim()) {
        toastr.warning('No schema content to save');
        return { success: false };
    }

    // Validate first
    const validation = validateSchema(schemaContent);
    if (!validation.valid) {
        toastr.error(`Invalid schema: ${validation.error}`);
        return { success: false };
    }

    const name = await Popup.show.input(
        'Save Schema Preset',
        'Enter a name for this preset:',
        `Custom ${STAGE_LABELS[stage]} Schema`,
    );

    if (name === null || name === POPUP_RESULT.CANCELLED) {
        return { success: false };
    }

    if (!name.trim()) {
        toastr.warning('Preset name cannot be empty');
        return { success: false };
    }

    try {
        const newPreset = saveSchemaPreset({
            name: name.trim(),
            schema: validation.schema!,
            stages: [stage],
        });
        toastr.success(`Schema preset "${name}" saved`);
        return { success: true, presetId: newPreset.id };
    } catch (e) {
        toastr.error(`Failed to save preset: ${(e as Error).message}`);
        return { success: false };
    }
}

// ============================================================================
// HELPERS
// ============================================================================

function renderPresetOptions(presets: (PromptPreset | SchemaPreset)[], selectedId: string | null): string {
    return presets.map(p => {
        const selected = p.id === selectedId ? 'selected' : '';
        const icon = p.isBuiltin ? '📦' : '📝';
        return `<option value="${p.id}" ${selected}>${icon} ${escapeHtml(p.name)}</option>`;
    }).join('');
}

function updateSchemaValidation(container: HTMLElement, schemaContent: string): void {
    // Remove existing status
    const existingStatus = container.querySelector(`.${MODULE_NAME}_schema_status`);
    if (existingStatus) {
        existingStatus.remove();
    }

    if (!schemaContent.trim()) {
        return;
    }

    const validation = validateSchema(schemaContent);
    let statusHtml = '';

    if (!validation.valid) {
        statusHtml = `<div class="${MODULE_NAME}_schema_status error"><i class="fa-solid fa-circle-xmark"></i> ${escapeHtml(validation.error || 'Invalid schema')}</div>`;
    } else if (validation.warnings?.length) {
        statusHtml = `<div class="${MODULE_NAME}_schema_status warning"><i class="fa-solid fa-triangle-exclamation"></i> ${validation.warnings.length} warning(s)</div>`;
    } else {
        statusHtml = `<div class="${MODULE_NAME}_schema_status success"><i class="fa-solid fa-circle-check"></i> Valid schema</div>`;
    }

    const schemaTextarea = container.querySelector(`#${MODULE_NAME}_custom_schema`);
    if (schemaTextarea) {
        schemaTextarea.insertAdjacentHTML('afterend', statusHtml);
    }
}

function escapeHtml(text: string): string {
    const { DOMPurify } = SillyTavern.libs;
    return DOMPurify.sanitize(text, { ALLOWED_TAGS: [] });
}
```

## FILE: src/ui/components/results-panel.ts
```ts
// src/ui/components/results-panel.ts
//
// Results display and actions component

import { MODULE_NAME, STAGE_LABELS } from '../../constants';
import { formatResponse, formatStructuredResponse } from '../formatter';
import { canExport, canRefine, extractVerdict } from '../../pipeline';
import type { StageName, StageStatus, StageResult, PipelineState, IterationVerdict } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the results panel
 */
export function renderResultsPanel(
    stage: StageName,
    result: StageResult | null,
    status: StageStatus,
    isGenerating: boolean,
): string {
    if (isGenerating && status === 'running') {
        return renderLoading(stage);
    }

    if (!result) {
        return renderPlaceholder(stage, status);
    }

    return renderResult(stage, result);
}

function renderLoading(stage: StageName): string {
    return `
    <div class="${MODULE_NAME}_results_loading">
      <i class="fa-solid fa-spinner fa-spin fa-2x"></i>
      <p>Running ${STAGE_LABELS[stage]}...</p>
      <button id="${MODULE_NAME}_cancel_btn" class="menu_button">
        <i class="fa-solid fa-stop"></i>
        <span>Cancel</span>
      </button>
    </div>
  `;
}

/**
 * Render loading state for refinement
 */
export function renderRefinementLoading(iteration: number): string {
    return `
    <div class="${MODULE_NAME}_results_loading">
      <i class="fa-solid fa-spinner fa-spin fa-2x"></i>
      <p>Refining (Iteration #${iteration + 1})...</p>
      <button id="${MODULE_NAME}_cancel_btn" class="menu_button">
        <i class="fa-solid fa-stop"></i>
        <span>Cancel</span>
      </button>
    </div>
  `;
}

function renderPlaceholder(stage: StageName, status: StageStatus): string {
    let message = `Run ${STAGE_LABELS[stage]} to see results`;
    let icon = 'fa-play';

    if (status === 'skipped') {
        message = `${STAGE_LABELS[stage]} was skipped`;
        icon = 'fa-forward';
    }

    return `
    <div class="${MODULE_NAME}_results_placeholder">
      <i class="fa-solid ${icon}"></i>
      <p>${message}</p>
    </div>
  `;
}

function renderResult(stage: StageName, result: StageResult): string {
    const formattedContent = result.isStructured
        ? formatStructuredResponse(result.response, null, MODULE_NAME)
        : formatResponse(result.response, MODULE_NAME);

    const timestamp = new Date(result.timestamp).toLocaleTimeString();

    // Extract verdict if this is an analyze result
    let verdictBadge = '';
    if (stage === 'analyze') {
        const verdict = extractVerdict(result.response);
        verdictBadge = renderVerdictBadge(verdict);
    }

    return `
    <div class="${MODULE_NAME}_results_content">
      <!-- Toolbar -->
      <div class="${MODULE_NAME}_results_toolbar">
        <div class="${MODULE_NAME}_results_info">
          <span class="${MODULE_NAME}_badge">${STAGE_LABELS[stage]}</span>
          ${verdictBadge}
          <span class="${MODULE_NAME}_results_time">${timestamp}</span>
          ${result.locked ? `<span class="${MODULE_NAME}_badge ${MODULE_NAME}_badge_locked"><i class="fa-solid fa-lock"></i> Locked</span>` : ''}
        </div>
        <div class="${MODULE_NAME}_results_actions">
          ${result.locked
        ? `<button id="${MODULE_NAME}_unlock_btn" class="${MODULE_NAME}_icon_btn" title="Unlock for editing">
                <i class="fa-solid fa-lock-open"></i>
              </button>`
        : `<button id="${MODULE_NAME}_lock_btn" class="${MODULE_NAME}_icon_btn" title="Lock result">
                <i class="fa-solid fa-lock"></i>
              </button>`
}
          <button id="${MODULE_NAME}_copy_btn" class="${MODULE_NAME}_icon_btn" title="Copy to clipboard">
            <i class="fa-solid fa-copy"></i>
          </button>
        </div>
      </div>

      <!-- Content -->
      <div class="${MODULE_NAME}_results_body">
        ${formattedContent}
      </div>

      <!-- Footer Actions -->
      <div class="${MODULE_NAME}_results_footer" id="${MODULE_NAME}_results_footer">
        <!-- Populated by updateResultsPanelState -->
      </div>
    </div>
  `;
}

function renderVerdictBadge(verdict: IterationVerdict): string {
    const icons: Record<IterationVerdict, string> = {
        accept: 'fa-check-circle',
        needs_refinement: 'fa-wrench',
        regression: 'fa-arrow-down',
    };

    const labels: Record<IterationVerdict, string> = {
        accept: 'Accept',
        needs_refinement: 'Needs Work',
        regression: 'Regression',
    };

    return `
    <span class="${MODULE_NAME}_badge ${MODULE_NAME}_verdict_badge ${MODULE_NAME}_verdict_${verdict}">
      <i class="fa-solid ${icons[verdict]}"></i>
      ${labels[verdict]}
    </span>
  `;
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update results panel state
 */
export function updateResultsPanelState(
    container: HTMLElement,
    stage: StageName,
    result: StageResult | null,
    status: StageStatus,
    isGenerating: boolean,
    nextStage: StageName | null,
    pipeline: PipelineState,
): void {
    const shouldShowLoading = isGenerating && status === 'running';
    const shouldShowResult = result && !shouldShowLoading;
    const shouldShowPlaceholder = !result && !shouldShowLoading;

    // Always re-render if state type changes OR if showing placeholder (stage name might have changed)
    if (shouldShowLoading) {
        container.innerHTML = renderLoading(stage);
        return;
    }

    if (shouldShowPlaceholder) {
        container.innerHTML = renderPlaceholder(stage, status);
        return;
    }

    if (shouldShowResult) {
        // Only re-render result if we don't have content or timestamp changed
        const existingContent = container.querySelector(`.${MODULE_NAME}_results_content`);
        const existingTimestamp = container.querySelector(`.${MODULE_NAME}_results_time`)?.textContent;
        const newTimestamp = new Date(result.timestamp).toLocaleTimeString();

        if (!existingContent || existingTimestamp !== newTimestamp) {
            container.innerHTML = renderResult(stage, result);
        }
    }

    // Update footer actions
    const footer = container.querySelector(`#${MODULE_NAME}_results_footer`);
    if (footer && result) {
        footer.innerHTML = renderFooterActions(stage, result, nextStage, pipeline);
    }

    // Update lock button state
    const lockBtn = container.querySelector(`#${MODULE_NAME}_lock_btn`);
    const unlockBtn = container.querySelector(`#${MODULE_NAME}_unlock_btn`);

    if (result?.locked) {
        lockBtn?.classList.add('hidden');
        unlockBtn?.classList.remove('hidden');
    } else {
        lockBtn?.classList.remove('hidden');
        unlockBtn?.classList.add('hidden');
    }
}

function renderFooterActions(
    stage: StageName,
    result: StageResult,
    nextStage: StageName | null,
    pipeline: PipelineState,
): string {
    const actions: string[] = [];

    // Regenerate (if not locked)
    if (!result.locked) {
        actions.push(`
      <button id="${MODULE_NAME}_regenerate_btn" class="menu_button">
        <i class="fa-solid fa-rotate"></i>
        <span>Regenerate</span>
      </button>
    `);
    }

    // Stage-specific actions
    if (stage === 'analyze') {
        const verdict = extractVerdict(result.response);
        const canRefineResult = canRefine(pipeline);

        // Refine button (if we can refine)
        if (canRefineResult.canRun) {
            const isRecommended = verdict === 'needs_refinement';
            actions.push(`
        <button id="${MODULE_NAME}_refine_btn" class="menu_button ${isRecommended ? MODULE_NAME + '_refine_recommended' : ''}">
          <i class="fa-solid fa-arrows-rotate"></i>
          <span>Refine</span>
          ${pipeline.iterationCount > 0 ? `<span class="${MODULE_NAME}_iteration_badge">#${pipeline.iterationCount + 1}</span>` : ''}
        </button>
      `);
        }

        // Accept button (if we have a rewrite)
        if (pipeline.results.rewrite && !pipeline.results.rewrite.locked) {
            const isRecommended = verdict === 'accept';
            actions.push(`
        <button id="${MODULE_NAME}_accept_btn" class="menu_button ${isRecommended ? MODULE_NAME + '_accept_recommended' : ''}">
          <i class="fa-solid fa-check"></i>
          <span>Accept Rewrite</span>
        </button>
      `);
        }
    }

    // Continue to next stage (not on analyze - use refine/accept instead)
    if (nextStage && stage !== 'analyze') {
        actions.push(`
      <button id="${MODULE_NAME}_continue_btn" class="menu_button ${MODULE_NAME}_continue_btn">
        <i class="fa-solid fa-arrow-right"></i>
        <span>Continue to ${STAGE_LABELS[nextStage]}</span>
      </button>
    `);
    }

    // Export (if we have rewrite results)
    if (canExport(pipeline)) {
        actions.push(`
      <button id="${MODULE_NAME}_export_btn" class="menu_button">
        <i class="fa-solid fa-file-export"></i>
        <span>Export</span>
      </button>
    `);
    }

    return `<div class="${MODULE_NAME}_footer_actions">${actions.join('')}</div>`;
}
```

## FILE: src/ui/components/iteration-history.ts
```ts
// src/ui/components/iteration-history.ts
//
// Iteration history display component

import { MODULE_NAME } from '../../constants';
import type { IterationSnapshot, IterationVerdict } from '../../types';

// ============================================================================
// RENDER
// ============================================================================

/**
 * Render the iteration history panel
 */
export function renderIterationHistory(
    history: IterationSnapshot[],
    currentIteration: number,
    onRevert: (index: number) => void,
): string {
    if (history.length === 0 && currentIteration === 0) {
        return '';
    }

    return `
    <div class="${MODULE_NAME}_iteration_history" id="${MODULE_NAME}_iteration_history">
      <div class="${MODULE_NAME}_iteration_header">
        <i class="fa-solid fa-clock-rotate-left"></i>
        <span>Iteration History</span>
        <span class="${MODULE_NAME}_iteration_count">${currentIteration > 0 ? `Current: #${currentIteration + 1}` : 'Initial'}</span>
      </div>
      <div class="${MODULE_NAME}_iteration_list">
        ${history.length === 0
        ? `<div class="${MODULE_NAME}_iteration_empty">No previous iterations</div>`
        : history.map((snap, i) => renderIterationItem(snap, i, history.length)).join('')
}
      </div>
    </div>
  `;
}

function renderIterationItem(snap: IterationSnapshot, index: number, total: number): string {
    const verdictIcon = getVerdictIcon(snap.verdict);
    const verdictClass = getVerdictClass(snap.verdict);
    const time = new Date(snap.timestamp).toLocaleTimeString();

    return `
    <div class="${MODULE_NAME}_iteration_item ${verdictClass}" data-index="${index}">
      <div class="${MODULE_NAME}_iteration_item_header">
        <span class="${MODULE_NAME}_iteration_num">#${snap.iteration + 1}</span>
        <span class="${MODULE_NAME}_iteration_verdict">
          <i class="fa-solid ${verdictIcon}"></i>
          ${formatVerdict(snap.verdict)}
        </span>
        <span class="${MODULE_NAME}_iteration_time">${time}</span>
      </div>
      <div class="${MODULE_NAME}_iteration_preview">
        ${escapeHtml(snap.rewritePreview)}...
      </div>
      <div class="${MODULE_NAME}_iteration_actions">
        <button
          class="${MODULE_NAME}_iteration_revert_btn menu_button"
          data-index="${index}"
          title="Revert to this version"
        >
          <i class="fa-solid fa-rotate-left"></i>
          Revert
        </button>
        <button
          class="${MODULE_NAME}_iteration_view_btn menu_button"
          data-index="${index}"
          title="View full content"
        >
          <i class="fa-solid fa-eye"></i>
          View
        </button>
      </div>
    </div>
  `;
}

function getVerdictIcon(verdict: IterationVerdict): string {
    switch (verdict) {
        case 'accept': return 'fa-check-circle';
        case 'needs_refinement': return 'fa-wrench';
        case 'regression': return 'fa-arrow-down';
        default: return 'fa-question-circle';
    }
}

function getVerdictClass(verdict: IterationVerdict): string {
    return `${MODULE_NAME}_verdict_${verdict}`;
}

function formatVerdict(verdict: IterationVerdict): string {
    switch (verdict) {
        case 'accept': return 'Accepted';
        case 'needs_refinement': return 'Needs Work';
        case 'regression': return 'Regression';
        default: return 'Unknown';
    }
}

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update iteration history state
 */
export function updateIterationHistoryState(
    container: HTMLElement,
    history: IterationSnapshot[],
    currentIteration: number,
): void {
    const historyEl = container.querySelector(`#${MODULE_NAME}_iteration_history`);

    if (!historyEl && (history.length > 0 || currentIteration > 0)) {
        // Need to add history panel
        const html = renderIterationHistory(history, currentIteration, () => {});
        container.insertAdjacentHTML('beforeend', html);
    } else if (historyEl) {
        // Update existing
        const countEl = historyEl.querySelector(`.${MODULE_NAME}_iteration_count`);
        if (countEl) {
            countEl.textContent = currentIteration > 0 ? `Current: #${currentIteration + 1}` : 'Initial';
        }

        const listEl = historyEl.querySelector(`.${MODULE_NAME}_iteration_list`);
        if (listEl) {
            if (history.length === 0) {
                listEl.innerHTML = `<div class="${MODULE_NAME}_iteration_empty">No previous iterations</div>`;
            } else {
                listEl.innerHTML = history.map((snap, i) => renderIterationItem(snap, i, history.length)).join('');
            }
        }
    }
}

/**
 * Render iteration view modal content
 */
export function renderIterationViewContent(snap: IterationSnapshot): string {
    return `
    <div class="${MODULE_NAME}_iteration_view">
      <div class="${MODULE_NAME}_iteration_view_header">
        <h3>Iteration #${snap.iteration + 1}</h3>
        <span class="${MODULE_NAME}_iteration_verdict ${getVerdictClass(snap.verdict)}">
          <i class="fa-solid ${getVerdictIcon(snap.verdict)}"></i>
          ${formatVerdict(snap.verdict)}
        </span>
        <span class="${MODULE_NAME}_iteration_time">${new Date(snap.timestamp).toLocaleString()}</span>
      </div>

      <div class="${MODULE_NAME}_iteration_view_section">
        <h4>Rewrite</h4>
        <div class="${MODULE_NAME}_iteration_view_content">
          ${escapeHtml(snap.rewriteResponse)}
        </div>
      </div>

      <div class="${MODULE_NAME}_iteration_view_section">
        <h4>Analysis</h4>
        <div class="${MODULE_NAME}_iteration_view_content">
          ${escapeHtml(snap.analysisResponse)}
        </div>
      </div>
    </div>
  `;
}

// ============================================================================
// UTILITIES
// ============================================================================

function escapeHtml(value: unknown): string {
    const { DOMPurify } = SillyTavern.libs;
    const str = typeof value === 'string' ? value : String(value ?? '');
    return DOMPurify.sanitize(str, { ALLOWED_TAGS: [] });
}
```

## FILE: templates/panel.html
```html
<div id="character_tools_settings" class="extension_settings">
  <div class="inline-drawer">
    <div class="inline-drawer-toggle inline-drawer-header">
      <b><i class="fa-solid fa-wand-magic-sparkles"></i> Character Tools</b>
      <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
    </div>
    <div class="inline-drawer-content">

      <!-- Quick Launch -->
      <div class="character_tools_panel_launch">
        <button id="character_tools_open_btn" class="menu_button menu_button_icon wide100p">
          <i class="fa-solid fa-rocket"></i>
          <span>Open Character Tools</span>
        </button>
      </div>

      <hr>

      <!-- Debug Toggle -->
      <div class="character_tools_panel_row">
        <label class="checkbox_label">
          <input type="checkbox" id="character_tools_debug_toggle">
          <span>Debug Mode</span>
        </label>
        <small class="opacity50">Log requests/responses to console</small>
      </div>

    </div>
  </div>
</div>
```

## FILE: style.css
```css
/* style.css - Character Tools Extension v2 */

/* ============================================================================
   VARIABLES - Extension-specific only, inherit ST for everything else
   ============================================================================ */

:root {
  --ct-spacing-xs: 4px;
  --ct-spacing-sm: 8px;
  --ct-spacing-md: 12px;
  --ct-spacing-lg: 16px;
  --ct-spacing-xl: 24px;
  --ct-radius-sm: 4px;
  --ct-radius-md: 6px;
  --ct-radius-lg: 8px;
  --ct-transition: 0.15s ease;
}

/* ============================================================================
   EXTENSION PANEL
   ============================================================================ */

.character_tools_panel_launch {
  margin-bottom: var(--ct-spacing-md);
}

.character_tools_panel_launch .menu_button {
  font-size: 1.05em;
  padding: var(--ct-spacing-md) var(--ct-spacing-lg);
}

.character_tools_panel_row {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-xs);
}

/* ============================================================================
   POPUP - LAYOUT
   ============================================================================ */

.character_tools_popup {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  min-width: 600px;
  max-width: 900px;
  color: var(--SmartThemeBodyColor);
  font-family: var(--mainFontFamily);
}

/* Header */
.character_tools_popup_header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_popup_title {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 1.3em;
  font-weight: 600;
  color: var(--SmartThemeBodyColor);
}

.character_tools_popup_header_right {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
}

.character_tools_api_status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.85em;
  color: var(--SmartThemeBodyColor);
  opacity: 0.7;
}

.character_tools_api_status i {
  font-size: 8px;
}

.character_tools_api_status.connected i {
  color: var(--success);
}

.character_tools_api_status.disconnected i {
  color: var(--failure);
}

/* Sections */
.character_tools_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_section_grow {
  flex: 1;
  min-height: 200px;
}

.character_tools_section_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-weight: 600;
  font-size: 0.95em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_section_header i {
  width: 18px;
  text-align: center;
  opacity: 0.8;
}

/* ============================================================================
   ICON BUTTON
   ============================================================================ */

.character_tools_icon_btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  background: transparent;
  border: 1px solid transparent;
  border-radius: var(--ct-radius-md);
  cursor: pointer;
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
  transition: all var(--ct-transition);
}

.character_tools_icon_btn:hover {
  opacity: 1;
  background: var(--SmartThemeBorderColor);
}

.character_tools_icon_btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* ============================================================================
   BADGES
   ============================================================================ */

.character_tools_badge {
  display: inline-flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.75em;
  font-weight: 600;
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.character_tools_badge_locked {
  background: var(--SmartThemeBorderColor);
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   CHARACTER SELECT
   ============================================================================ */

.character_tools_char_select {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
  position: relative;
}

/* Search */
.character_tools_search_wrapper {
  position: relative;
}

.character_tools_search_container {
  position: relative;
  display: flex;
  align-items: center;
}

.character_tools_search_icon {
  position: absolute;
  left: 12px;
  opacity: 0.5;
  pointer-events: none;
  z-index: 1;
  color: var(--SmartThemeBodyColor);
}

.character_tools_search_input {
  padding-left: 36px !important;
  width: 100%;
}

/* Dropdown */
.character_tools_dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 300px;
  overflow-y: auto;
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-top: none;
  border-radius: 0 0 var(--ct-radius-lg) var(--ct-radius-lg);
  z-index: 1000;
  box-shadow: 0 8px 24px var(--SmartThemeShadowColor, rgba(0, 0, 0, 0.5));
}

.character_tools_dropdown.hidden {
  display: none;
}

.character_tools_dropdown_item {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  cursor: pointer;
  transition: background var(--ct-transition);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  min-height: 56px;
  color: var(--SmartThemeBodyColor);
}

.character_tools_dropdown_item:last-child {
  border-bottom: none;
}

.character_tools_dropdown_item:hover,
.character_tools_dropdown_item.selected {
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_dropdown_avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  background: var(--SmartThemeBorderColor);
}

.character_tools_dropdown_info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
  flex: 1;
  overflow: hidden;
}

.character_tools_dropdown_name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.character_tools_dropdown_desc {
  font-size: 0.8em;
  opacity: 0.6;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.character_tools_dropdown_empty {
  padding: var(--ct-spacing-lg);
  text-align: center;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

/* Character Preview */
.character_tools_char_preview {
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  overflow: hidden;
}

.character_tools_char_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
}

.character_tools_char_avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  background: var(--SmartThemeBorderColor);
}

.character_tools_char_info {
  flex: 1;
  min-width: 0;
}

.character_tools_char_name {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_char_meta {
  font-size: 0.85em;
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
}

/* Character Fields */
.character_tools_char_fields {
  max-height: 200px;
  overflow-y: auto;
}

.character_tools_field_row {
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_field_row:last-child {
  border-bottom: none;
}

.character_tools_field_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  cursor: pointer;
  transition: background var(--ct-transition);
  color: var(--SmartThemeBodyColor);
}

.character_tools_field_header:hover {
  background: var(--SmartThemeChatTintColor);
}

.character_tools_field_header i {
  font-size: 0.8em;
  opacity: 0.5;
  width: 12px;
  transition: transform var(--ct-transition);
}

.character_tools_field_label {
  flex: 1;
  font-weight: 500;
}

.character_tools_field_tokens {
  font-size: 0.8em;
  opacity: 0.7;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
}

.character_tools_field_content {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md) var(--ct-spacing-md);
  padding-left: calc(var(--ct-spacing-md) + 20px);
  background: var(--SmartThemeChatTintColor);
}

.character_tools_field_text {
  font-size: 0.9em;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 150px;
  overflow-y: auto;
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   PIPELINE NAV
   ============================================================================ */

.character_tools_pipeline_nav {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-md);
}

.character_tools_stage_row {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: var(--ct-spacing-xs);
}

.character_tools_stage_node {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
}

/* Stage Checkbox */
.character_tools_stage_checkbox {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: var(--SmartThemeQuoteColor);
}

/* Stage Button */
.character_tools_stage_btn {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  cursor: pointer;
  color: var(--SmartThemeBodyColor);
  font-size: 0.9em;
  font-family: var(--mainFontFamily);
  transition: all var(--ct-transition);
}

.character_tools_stage_btn:hover {
  background: var(--SmartThemeBorderColor);
}

.character_tools_stage_btn.active {
  background: var(--SmartThemeQuoteColor);
  border-color: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_status_icon {
  font-size: 0.75em;
  margin-left: 4px;
}

.character_tools_stage_complete .character_tools_status_icon {
  color: var(--success);
}

.character_tools_stage_running .character_tools_status_icon {
  color: var(--warning);
}

/* Stage Connector */
.character_tools_stage_connector {
  width: 20px;
  height: 2px;
  background: var(--SmartThemeBorderColor);
  margin: 0 4px;
}

.character_tools_stage_connector.active {
  background: var(--SmartThemeQuoteColor);
}

/* Pipeline Actions */
.character_tools_pipeline_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

/* ============================================================================
   STAGE CONFIG
   ============================================================================ */

.character_tools_stage_config {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-md);
}

.character_tools_config_group {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_config_header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-md);
}

.character_tools_config_header_actions {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
}

.character_tools_config_header_actions .character_tools_icon_btn {
  width: 28px;
  height: 28px;
}

.character_tools_config_header_actions .character_tools_icon_btn:disabled {
  opacity: 0.3;
}

.character_tools_config_label {
  font-weight: 500;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_preset_select {
  width: auto;
  min-width: 180px;
}

.character_tools_prompt_textarea {
  resize: vertical;
  min-height: 100px;
  font-size: 0.9em;
  line-height: 1.5;
}

.character_tools_schema_textarea {
  resize: vertical;
  min-height: 80px;
  font-size: 0.85em;
  font-family: var(--monoFontFamily);
}

.character_tools_config_footer {
  display: flex;
  justify-content: flex-end;
}

.character_tools_char_count {
  font-size: 0.8em;
  opacity: 0.5;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
}

/* Schema Section */
.character_tools_schema_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_schema_section.hidden {
  display: none;
}

.character_tools_schema_status {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.85em;
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  border-radius: var(--ct-radius-sm);
}

.character_tools_schema_status.success {
  color: var(--success);
  background: color-mix(in srgb, var(--success) 15%, transparent);
}

.character_tools_schema_status.warning {
  color: var(--warning);
  background: color-mix(in srgb, var(--warning) 15%, transparent);
}

.character_tools_schema_status.error {
  color: var(--failure);
  background: color-mix(in srgb, var(--failure) 15%, transparent);
}

.character_tools_schema_status.info {
  color: var(--SmartThemeBodyColor);
  opacity: 0.6;
}

/* Schema Actions */
.character_tools_schema_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  margin-top: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_schema_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

.character_tools_schema_actions .menu_button i {
  margin-right: var(--ct-spacing-xs);
}

/* Config Actions */
.character_tools_config_actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: var(--ct-spacing-sm);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_token_estimate {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.85em;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
  opacity: 0.7;
}

.character_tools_token_estimate.warning {
  color: var(--warning);
  opacity: 1;
}

.character_tools_token_estimate.danger {
  color: var(--failure);
  opacity: 1;
}

#character_tools_run_stage_btn kbd {
  font-size: 0.7em;
  padding: 2px 6px;
  background: var(--SmartThemeBorderColor);
  border-radius: 3px;
  opacity: 0.7;
  font-family: var(--monoFontFamily);
  margin-left: var(--ct-spacing-sm);
}

/* Checkbox Label */
.character_tools_checkbox_label {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  cursor: pointer;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_checkbox_label input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: var(--SmartThemeQuoteColor);
}

/* ============================================================================
   RESULTS PANEL
   ============================================================================ */

.character_tools_results_loading,
.character_tools_results_placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--ct-spacing-md);
  padding: var(--ct-spacing-xl) var(--ct-spacing-lg);
  text-align: center;
  min-height: 150px;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_placeholder {
  opacity: 0.5;
}

.character_tools_results_placeholder i,
.character_tools_results_loading i:not(.fa-spinner) {
  font-size: 2em;
}

.character_tools_spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--SmartThemeBorderColor);
  border-top-color: var(--SmartThemeQuoteColor);
  border-radius: 50%;
  animation: character_tools_spin 0.8s linear infinite;
}

@keyframes character_tools_spin {
  to { transform: rotate(360deg); }
}

/* Results Content */
.character_tools_results_content {
  display: flex;
  flex-direction: column;
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  background: var(--SmartThemeBlurTintColor);
  overflow: hidden;
}

.character_tools_results_toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_results_info {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 0.85em;
}

.character_tools_results_time {
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_actions {
  display: flex;
  gap: var(--ct-spacing-xs);
}

.character_tools_results_body {
  padding: var(--ct-spacing-lg);
  max-height: 400px;
  overflow-y: auto;
  line-height: 1.6;
  color: var(--SmartThemeBodyColor);
}

.character_tools_results_footer {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_footer_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_continue_btn {
  background: var(--SmartThemeQuoteColor) !important;
  color: var(--SmartThemeBlurTintColor) !important;
}

/* ============================================================================
   SETTINGS MODAL
   ============================================================================ */

.character_tools_settings_modal {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  min-width: 500px;
  max-width: 700px;
  color: var(--SmartThemeBodyColor);
  font-family: var(--mainFontFamily);
}

.character_tools_settings_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-size: 1.2em;
  font-weight: 600;
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_settings_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_settings_section_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  font-weight: 600;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_settings_hint {
  font-size: 0.85em;
  opacity: 0.6;
  margin: 0;
  color: var(--SmartThemeBodyColor);
}

.character_tools_settings_row {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
}

.character_tools_settings_row_spread {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-md);
}

.character_tools_settings_grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--ct-spacing-md);
}

.character_tools_settings_grid_5 {
  grid-template-columns: repeat(5, 1fr);
}

.character_tools_settings_field {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-xs);
}

.character_tools_settings_field label {
  font-size: 0.85em;
  opacity: 0.8;
  color: var(--SmartThemeBodyColor);
}

.character_tools_system_prompt_textarea {
  resize: vertical;
  min-height: 100px;
  font-size: 0.9em;
}

/* Presets */
.character_tools_presets_grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--ct-spacing-lg);
}

.character_tools_preset_column h4 {
  margin: 0 0 var(--ct-spacing-sm);
  font-size: 0.9em;
  opacity: 0.8;
  color: var(--SmartThemeBodyColor);
}

.character_tools_preset_list {
  max-height: 150px;
  overflow-y: auto;
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  background: var(--SmartThemeBlurTintColor);
}

.character_tools_preset_item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_preset_item:last-child {
  border-bottom: none;
}

.character_tools_preset_item.builtin {
  opacity: 0.7;
}

.character_tools_preset_name {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
}

.character_tools_preset_name i {
  font-size: 0.75em;
  opacity: 0.5;
}

.character_tools_preset_delete {
  background: none;
  border: none;
  color: var(--failure);
  cursor: pointer;
  padding: var(--ct-spacing-xs);
  opacity: 0.6;
  transition: opacity var(--ct-transition);
}

.character_tools_preset_delete:hover {
  opacity: 1;
}

.character_tools_preset_empty {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

/* Debug */
.character_tools_debug_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_debug_log_viewer {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
  margin-top: var(--ct-spacing-sm);
}

.character_tools_debug_log_viewer.hidden {
  display: none;
}

.character_tools_debug_log_list {
  max-height: 120px;
  overflow-y: auto;
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  font-family: var(--monoFontFamily);
  font-size: 0.8em;
}

.character_tools_debug_log_entry {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  cursor: pointer;
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  transition: background var(--ct-transition);
  color: var(--SmartThemeBodyColor);
}

.character_tools_debug_log_entry:hover {
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
}

.character_tools_debug_log_entry:last-child {
  border-bottom: none;
}

.character_tools_debug_log_empty {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_debug_log_detail {
  max-height: 120px;
  overflow: auto;
  margin: 0;
  padding: var(--ct-spacing-sm);
  background: var(--SmartThemeBlurTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  font-family: var(--monoFontFamily);
  font-size: 0.75em;
  white-space: pre-wrap;
  word-break: break-all;
  color: var(--SmartThemeBodyColor);
}

/* ============================================================================
   STRUCTURED OUTPUT FORMATTING
   ============================================================================ */

.character_tools_structured_content,
.character_tools_markdown_content {
  text-align: left;
  color: var(--SmartThemeBodyColor);
}

.character_tools_hero {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--ct-spacing-lg) var(--ct-spacing-xl);
  margin-bottom: var(--ct-spacing-lg);
  background: var(--SmartThemeChatTintColor);
  border-radius: var(--ct-radius-lg);
  border-left: 4px solid var(--SmartThemeQuoteColor);
}

.character_tools_hero_label {
  font-size: 1.1em;
  font-weight: 600;
  opacity: 0.9;
}

.character_tools_hero_value {
  font-size: 2em;
  font-weight: 700;
}

.character_tools_hero_max {
  font-size: 0.5em;
  opacity: 0.5;
  font-weight: 400;
}

.character_tools_field {
  margin-bottom: var(--ct-spacing-md);
}

.character_tools_field:last-child {
  margin-bottom: 0;
}

/* Note: .character_tools_field_label is also used in char select, keep consistent */

.character_tools_field_value {
  line-height: 1.5;
}

.character_tools_nested {
  padding-left: var(--ct-spacing-lg);
  border-left: 2px solid var(--SmartThemeBorderColor);
  margin-top: var(--ct-spacing-sm);
}

.character_tools_list {
  margin: 0;
  padding-left: 20px;
  line-height: 1.6;
}

.character_tools_list li {
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_list li:last-child {
  margin-bottom: 0;
}

.character_tools_cards {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_card {
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
}

.character_tools_card_header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_card_title {
  font-weight: 600;
}

.character_tools_card_body {
  opacity: 0.9;
}

.character_tools_card_extra {
  margin-top: var(--ct-spacing-sm);
  padding-top: var(--ct-spacing-sm);
  border-top: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_score {
  font-weight: 700;
}

.character_tools_score_max {
  font-size: 0.7em;
  opacity: 0.5;
  font-weight: 400;
}

.character_tools_num {
  font-family: var(--monoFontFamily);
}

.character_tools_yes {
  color: var(--success);
}

.character_tools_no {
  color: var(--failure);
}

.character_tools_null,
.character_tools_empty {
  opacity: 0.5;
  font-style: italic;
}

.character_tools_link {
  color: var(--SmartThemeQuoteColor);
  text-decoration: underline;
}

.character_tools_text p {
  margin: 0.4em 0;
}

.character_tools_text p:first-child {
  margin-top: 0;
}

.character_tools_text p:last-child {
  margin-bottom: 0;
}

.character_tools_json {
  margin: 0;
  padding: var(--ct-spacing-sm);
  background: var(--SmartThemeChatTintColor);
  border-radius: var(--ct-radius-sm);
  font-size: 0.8em;
  overflow-x: auto;
  max-height: 200px;
}

/* ============================================================================
   MARKDOWN FORMATTING
   ============================================================================ */

.character_tools_markdown_content h1 {
  font-size: 1.4em;
  color: var(--SmartThemeQuoteColor);
  margin: 1em 0 0.5em;
  padding-bottom: 0.3em;
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_markdown_content h1:first-child {
  margin-top: 0;
}

.character_tools_markdown_content h2 {
  font-size: 1.2em;
  color: var(--SmartThemeQuoteColor);
  margin: 1em 0 0.4em;
}

.character_tools_markdown_content h3 {
  font-size: 1.1em;
  color: var(--SmartThemeQuoteColor);
  margin: 0.8em 0 0.3em;
}

.character_tools_markdown_content h4,
.character_tools_markdown_content h5,
.character_tools_markdown_content h6 {
  font-size: 1em;
  color: var(--SmartThemeQuoteColor);
  margin: 0.6em 0 0.2em;
}

.character_tools_markdown_content p {
  margin: 0.6em 0;
  line-height: 1.6;
}

.character_tools_markdown_content ul,
.character_tools_markdown_content ol {
  padding-left: 1.8em;
  margin: 0.6em 0;
}

.character_tools_markdown_content li {
  margin-bottom: 0.4em;
  line-height: 1.5;
}

.character_tools_markdown_content code {
  background: var(--SmartThemeChatTintColor);
  padding: 0.15em 0.4em;
  border-radius: 3px;
  font-size: 0.9em;
  font-family: var(--monoFontFamily);
}

.character_tools_markdown_content pre {
  background: var(--SmartThemeChatTintColor);
  padding: var(--ct-spacing-md);
  border-radius: var(--ct-radius-md);
  overflow-x: auto;
  margin: 0.8em 0;
  border: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_markdown_content pre code {
  background: none;
  padding: 0;
  font-size: 0.85em;
}

.character_tools_markdown_content blockquote {
  border-left: 3px solid var(--SmartThemeQuoteColor);
  margin: 0.8em 0;
  padding: 0.5em 0 0.5em 1em;
  background: var(--SmartThemeChatTintColor);
  border-radius: 0 var(--ct-radius-sm) var(--ct-radius-sm) 0;
}

.character_tools_markdown_content table {
  border-collapse: collapse;
  width: 100%;
  margin: 0.8em 0;
}

.character_tools_markdown_content th,
.character_tools_markdown_content td {
  border: 1px solid var(--SmartThemeBorderColor);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  text-align: left;
}

.character_tools_markdown_content th {
  background: var(--SmartThemeChatTintColor);
  font-weight: 600;
}

.character_tools_markdown_content hr {
  border: none;
  border-top: 1px solid var(--SmartThemeBorderColor);
  margin: 1.5em 0;
}

.character_tools_markdown_content a {
  color: var(--SmartThemeQuoteColor);
  text-decoration: underline;
}

/* ============================================================================
   UTILITIES
   ============================================================================ */

.hidden {
  display: none !important;
}

.character_tools_api_status.connected i {
  color: var(--success, #2ecc71);
}

.character_tools_api_status.disconnected i {
  color: var(--failure, #e74c3c);
}

/* Fix preset select - constrain width, show arrow */
.character_tools_preset_select {
  width: auto;
  min-width: 150px;
  max-width: 220px;
  text-overflow: ellipsis;
  padding-right: 24px !important; /* Room for arrow */
}

/* Fix character fields - left align */
.character_tools_field_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  cursor: pointer;
  transition: background var(--ct-transition);
  color: var(--SmartThemeBodyColor);
  text-align: left;
}

.character_tools_field_label {
  flex: 1;
  font-weight: 500;
  text-align: left;
}

.character_tools_field_tokens {
  font-size: 0.8em;
  opacity: 0.7;
  font-family: var(--monoFontFamily);
  color: var(--SmartThemeBodyColor);
  text-align: right;
  flex-shrink: 0;
}

/* Fix character header - left align name */
.character_tools_char_info {
  flex: 1;
  min-width: 0;
  text-align: left;
}

/* Fix pipeline action buttons - smaller, no wrap */
.character_tools_pipeline_actions {
  display: flex;
  gap: var(--ct-spacing-xs);
  flex-wrap: nowrap;
}

.character_tools_pipeline_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
  white-space: nowrap;
}

.character_tools_pipeline_actions .menu_button i {
  margin-right: 4px;
}

.character_tools_pipeline_actions .menu_button span {
  display: inline;
}

/* Fix settings buttons - smaller */
.character_tools_settings_row_spread .menu_button,
.character_tools_debug_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

/* Fix settings grid on small widths */
.character_tools_settings_grid_5 {
  grid-template-columns: repeat(5, 1fr);
  gap: var(--ct-spacing-sm);
}

.character_tools_settings_grid_5 .text_pole {
  min-width: 0;
  width: 100%;
}

/* Fix footer actions - smaller buttons */
.character_tools_footer_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.85em;
}

/* Fix config header actions alignment */
.character_tools_config_header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-sm);
}

.character_tools_config_header_actions {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  flex-shrink: 0;
}

/* Settings modal buttons - single line, proper sizing */
.character_tools_settings_modal .menu_button {
  white-space: nowrap;
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  font-size: 0.9em;
}

/* Export/Import row - flex with gap */
.character_tools_settings_row_spread {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--ct-spacing-md);
  flex-wrap: wrap;
}

/* Debug actions - horizontal, no wrap on buttons */
.character_tools_debug_actions {
  display: flex;
  gap: var(--ct-spacing-sm);
  flex-wrap: wrap;
}

.character_tools_debug_actions .menu_button {
  white-space: nowrap;
}

/* Settings grid 5 columns - give more room on smaller widths */
.character_tools_settings_grid_5 {
  grid-template-columns: repeat(5, minmax(60px, 1fr));
  gap: var(--ct-spacing-sm);
}

/* Preset columns - ensure headers don't center */
.character_tools_preset_column h4 {
  margin: 0 0 var(--ct-spacing-sm);
  font-size: 0.9em;
  opacity: 0.8;
  color: var(--SmartThemeBodyColor);
  text-align: center;
}

/* Global fix - all menu buttons in the extension get icon spacing */
.character_tools_settings_modal .menu_button i,
.character_tools_popup .menu_button i {
  margin-right: var(--ct-spacing-xs);
}

/* ============================================================================
   ITERATION SYSTEM
   ============================================================================ */

/* Iteration Indicator in Header */
.character_tools_iteration_indicator {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.8em;
  font-weight: 600;
  background: var(--SmartThemeQuoteColor);
  color: var(--SmartThemeBlurTintColor);
  margin-left: auto;
}

.character_tools_iteration_indicator.hidden {
  display: none;
}

/* Iteration History Panel */
.character_tools_iteration_history {
  margin-top: var(--ct-spacing-md);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-lg);
  background: var(--SmartThemeBlurTintColor);
  overflow: hidden;
}

.character_tools_iteration_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  font-weight: 600;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_count {
  margin-left: auto;
  font-weight: normal;
  opacity: 0.7;
}

.character_tools_iteration_list {
  max-height: 200px;
  overflow-y: auto;
}

.character_tools_iteration_empty {
  padding: var(--ct-spacing-md);
  text-align: center;
  opacity: 0.5;
  font-size: 0.9em;
  color: var(--SmartThemeBodyColor);
}

/* Iteration Item */
.character_tools_iteration_item {
  padding: var(--ct-spacing-sm) var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
  transition: background var(--ct-transition);
}

.character_tools_iteration_item:last-child {
  border-bottom: none;
}

.character_tools_iteration_item:hover {
  background: var(--SmartThemeChatTintColor);
}

.character_tools_iteration_item_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-sm);
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_iteration_num {
  font-weight: 600;
  font-size: 0.9em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_iteration_verdict {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  font-size: 0.8em;
  font-weight: 500;
}

.character_tools_iteration_time {
  margin-left: auto;
  font-size: 0.75em;
  opacity: 0.5;
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_preview {
  font-size: 0.85em;
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--SmartThemeBodyColor);
  margin-bottom: var(--ct-spacing-xs);
}

.character_tools_iteration_actions {
  display: flex;
  gap: var(--ct-spacing-xs);
}

.character_tools_iteration_actions .menu_button {
  padding: var(--ct-spacing-xs) var(--ct-spacing-sm);
  font-size: 0.8em;
}

/* Verdict Colors */
.character_tools_verdict_accept .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_accept {
  color: var(--success);
}

.character_tools_verdict_needs_refinement .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_needs_refinement {
  color: var(--warning);
}

.character_tools_verdict_regression .character_tools_iteration_verdict,
.character_tools_verdict_badge.character_tools_verdict_regression {
  color: var(--failure);
}

/* Verdict Badge in Results */
.character_tools_verdict_badge {
  display: inline-flex;
  align-items: center;
  gap: var(--ct-spacing-xs);
  padding: 3px 10px;
  border-radius: var(--ct-radius-sm);
  font-size: 0.75em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.character_tools_verdict_badge.character_tools_verdict_accept {
  background: color-mix(in srgb, var(--success) 20%, transparent);
}

.character_tools_verdict_badge.character_tools_verdict_needs_refinement {
  background: color-mix(in srgb, var(--warning) 20%, transparent);
}

.character_tools_verdict_badge.character_tools_verdict_regression {
  background: color-mix(in srgb, var(--failure) 20%, transparent);
}

/* Refine/Accept Button Styling */
.character_tools_refine_recommended {
  background: var(--warning) !important;
  color: var(--SmartThemeBlurTintColor) !important;
  border-color: var(--warning) !important;
}

.character_tools_accept_recommended {
  background: var(--success) !important;
  color: var(--SmartThemeBlurTintColor) !important;
  border-color: var(--success) !important;
}

.character_tools_iteration_badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  border-radius: 10px;
  background: var(--SmartThemeBorderColor);
  font-size: 0.75em;
  font-weight: 600;
  margin-left: var(--ct-spacing-xs);
}

/* Iteration View Modal */
.character_tools_iteration_view {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-lg);
  color: var(--SmartThemeBodyColor);
}

.character_tools_iteration_view_header {
  display: flex;
  align-items: center;
  gap: var(--ct-spacing-md);
  padding-bottom: var(--ct-spacing-md);
  border-bottom: 1px solid var(--SmartThemeBorderColor);
}

.character_tools_iteration_view_header h3 {
  margin: 0;
  font-size: 1.2em;
}

.character_tools_iteration_view_section {
  display: flex;
  flex-direction: column;
  gap: var(--ct-spacing-sm);
}

.character_tools_iteration_view_section h4 {
  margin: 0;
  font-size: 1em;
  color: var(--SmartThemeQuoteColor);
}

.character_tools_iteration_view_content {
  padding: var(--ct-spacing-md);
  background: var(--SmartThemeChatTintColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: var(--ct-radius-md);
  max-height: 300px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-size: 0.9em;
  line-height: 1.5;
}
```

## FILE: manifest.json
```json
{
  "display_name": "Character Tools",
  "loading_order": 1,
  "requires": [],
  "optional": [],
  "dependencies": [],
  "js": "dist/index.js",
  "css": "style.css",
  "author": "Inktomi",
  "version": "1.0.0",
  "homePage": "https://github.com/Inktomi93/SillyTavern-CharacterTools",
  "auto_update": true,
  "minimum_client_version": "",
  "i18n": {}
}
```

## FILE: globals.d.ts
```ts
// globals.d.ts
export {};

// Development: absolute path to your ST install
import '/home/inktomi/SillyTavern/public/global';

// Production paths (uncomment when publishing, comment out dev path above)
// import '../../../../public/global'; // user-scoped
// import '../../../../global'; // server-scoped

// Extend ST's types with what we need
declare global {
  // toastr is a global loaded by ST
  const toastr: {
    success: (message: string, title?: string) => void;
    error: (message: string, title?: string) => void;
    warning: (message: string, title?: string) => void;
    info: (message: string, title?: string) => void;
  };

  interface PresetManager {
    apiId: string;
    getPresetList: (api?: string) => {
      presets: Record<string, unknown>[];
      preset_names: Record<string, number>;
      settings: Record<string, unknown>;
    };
    getSelectedPreset: () => unknown;
    getSelectedPresetName: () => string;
    selectPreset: (value: string) => boolean;
    getAllPresets: () => unknown[];
  }

  interface ChatCompletionResult {
    content: string;
    reasoning?: string;
  }

  interface ChatCompletionRequestOptions {
    stream: boolean;
    messages: Array<{ role: string; content: string }>;
    max_tokens?: number;
    temperature?: number;
  }

  interface ChatCompletionService {
    sendRequest: (options: ChatCompletionRequestOptions) => Promise<ChatCompletionResult>;
    processRequest: (
      options: ChatCompletionRequestOptions,
      presetOptions: { presetName?: string },
      extractData: boolean,
      signal: AbortSignal | null
    ) => Promise<ChatCompletionResult>;
  }
}
```

## FILE: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES6",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "./out",
    "strict": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "globals.d.ts"],
  "exclude": ["node_modules", "dist", "bin"]
}
```

## FILE: webpack.config.js
```js
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import TerserPlugin from 'terser-webpack-plugin';

const __dirname =
  import.meta.dirname ?? path.dirname(fileURLToPath(import.meta.url));

export default {
    mode: 'production',
    entry: path.join(__dirname, 'src/index.ts'),
    output: {
        path: path.join(__dirname, 'dist/'),
        filename: 'index.js',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: 'ts-loader',
                exclude: /node_modules/,
            },
        ],
    },
    optimization: {
        minimizer: [
            new TerserPlugin({
                extractComments: false,
                terserOptions: {
                    format: {
                        comments: false,
                    },
                },
            }),
        ],
    },
};
```

## FILE: package.json
```json
{
  "name": "extension-webpack-template",
  "type": "module",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "webpack --mode production",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "css-loader": "^7.1.2",
    "globals": "^16.0.0",
    "html-loader": "^5.1.0",
    "style-loader": "^4.0.0",
    "ts-loader": "^9.5.1",
    "typescript-eslint": "^8.29.0",
    "webpack-cli": "^5.1.4"
  }
}
```

